<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[工具使用--第2节 HEXO+GitHub 搭建个人博客]]></title>
    <url>%2F2017%2F10%2F29%2F%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8-%E7%AC%AC2%E8%8A%82-HEXO-GitHub-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[今天突然想搭建一个自己的私人博客，但是又不想为此买一台服务器，所以百度了一下，发现可以利用HEXO+码云 搭建私人博客，所以就写篇教程，记录一下吧。 1、环境安装配置1.1 安装node下载地址：https://nodejs.org/en/download/默认安装就好。 1.2 安装gitmsysgit是Windows版的Git，从https://git-for-windows.github.io下载（百度一下也有很多下载链接），然后按默认选项安装即可。msysgit的操作命令和Linux基本一致，很多命令是通用的，例如ls，mv，rm等；mygit安装完成后，在开始菜单里找到“Git”-&gt;“Git Bash”，蹦出一个类似命令行窗口的东西，就说明Git安装成功！（详情可参见 第1节 ） 1.3 申请GitHub账号 打开https://github.com/，自行申请账号； 1.4 安装HEXO 切换到命令行工具，CMD输入命令安装： npm install -g hexo 等待安装完成；不过国内NPM镜像速度极慢，可以安装淘宝的cnpm； npm install -g cnpm –registry=https://registry.npm.taobao.org 然后使用cnpm来下载HEXO，如下： cnpm install -g hexo 1.5 配置HEXO 切换CMD到你希望创建博客项目的目录，然后输入hexo init来初始化一个项目，如： cd c:/workspase/bloghexo init 继续输入命令： hexo generate 或者 hexo g 生成静态页面 1.6 启动本地服务 hexo server 可以看到提示Hexo已经运行在http://localhost:4000/上，我们用浏览器打开 http://localhost:4000/看看效果： 神奇的博客界面就出现了； 2、配合Github搭建个人博客2.1 登录Github创建一个项目 登录Github，点击上方的添加项目：我们来添加一个GIT版本仓，点击+号，选择“New repository”，如图： 打开创建对话框之后，输入repository名，*.github.io，星号代表你的用户名，记住结尾一定要用.github.io结尾，如果你输入的格式或者用户名不匹配，最后创建的网站可能加载不出css，js等资源，具体原因还没弄清，待以后验证，暂时就按照规范来，如图：其余的默认就好，点击“Create repository”来创建仓库；（我的由于已经创建同名的，所以弹出提示，请无视） 创建好之后进入创建好的界面，如下：由于我的已经上传过文件，所以你们是没有红框中的内容，不急，接下来我们来看怎么上传文件； 本地mygit还需要配置ssh秘钥，邮箱等才能和github进行上传，修改等操作；这一步如果没设置过，参见工具使用–第1节 git使用简记2.2 关联Github和HEXO 进入我们在 1.5 配置HEXO 创建的HEXO项目目录，打开根目录中的_config.yml文件（以记事本文件打开）；在文件最末尾添加如下三行：将其中的repo改为你自己repository地址，你的repository地址在github界面的这里获取，如图：点击“2”处就可以直接复制地址,最后添加的三条就是： 1234deploy: type: git repo: https://github.com/AmuUncle/AmuUncle.github.io.git branch: master 注意：每项的冒号后都要留一个英文的空格号； 在HEXO项目根目录中右击选择“Git Bash Here” 生成静态网站并同步到github执行下面两个命令： hexo g // 生成hexo d // 同步或者直接用：hexo d -g // 在同步前先生成网站 中间可能会让你输入github的账号密码，输入就好：运行结果如下：这样网站就同步到github中了；我们可以刷新github页面。可以看到已经有很多文件了： 2.3 让网站显示出来我们点击github界面上的Settings按钮，进入设置界面：往下拖动，找到“github pages”选项，点击“Launch Automatic page generator”按钮，开启github pages功能；这时我们就可已输入“https://AmuUncle.github.io”来打开我们创建的blog网站；如下：至此，我们已经成功将网站部署到GITHUB，并且是个人独立博客哦。。。 3、设置HEXO的主题这里网上很多教程，很简单，很多人推荐NEXT主题，我也用的是这款，功能很齐全，这里我就直接给教程链接了，很详细； NEXT主题官网，教程非常详细：http://theme-next.iissnan.com/getting-started.htmlHEXO主题类列表：https://hexo.io/themes/ 其他主题也差不多配置方法，自己研究吧。。 4、将域名和github博客地址关联（个人需求）4.1 购买域名我是在阿里云购买的.site域名,很便宜，一年才几块钱，有需要的可以去看看： https://wanwang.aliyun.com/domain/?spm=5176.8076989.763973.3.5a54fa45x7NU0Z 4.2 配置域名进入域名解析配置界面，添加一下三项：解析列表：| 方法记录类型 | 主机记录| 记录值 || ——– | ——– | —–: || CNAME | www | AmuUncle.github.io || A | @ | 192.30.252.154 || A | @ | 192.30.252.153 | 其中 192.30.252.153和 192.30.252.154 为github的IP地址；域名这边已经配置好，但还没结束，我们再来到HEXO博客的目录，进入source目录，新建一个CNAME文件，没有任何后缀名，编辑内容为：amuuncle.site 接下来输入： hexo d -g 重新生成同步网站到github，接下来就是见证奇迹的时候我们到浏览器输入我们的域名，就打开了我们的blog页面，如图（如果打不开，请等待10分钟，因为更改域名解析要十分钟后才能生效）最终效果图，完美，接下来我们就可以自由写个人微博，并且部署到github了，配置好域名之后，不注意根本发现不了你是在github上部署的网站哦。使用如下命令添加一篇博客，然后进入项目的source_posts目录找打创建的md文件，编辑此文件就是在写博客； hexo new post “工具使用–第2节 HEXO+GitHub 搭建个人博客” 对于md文件的编写，网上有很对教程，我使用的工具是：Haroopad，完全没费，可自行下载。记住写完之后还是要输入： hexo d -g 来重新生成同步网站到github； 最后，我的blog地址就是：amuuncle.site欢饮大家光临指教。]]></content>
      <categories>
        <category>GitHub</category>
      </categories>
      <tags>
        <tag>HEXO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python selenium 自动化查询上海公交卡余额，并邮件通知]]></title>
    <url>%2F2017%2F10%2F29%2Fpython-selenium-%E8%87%AA%E5%8A%A8%E5%8C%96%E6%9F%A5%E8%AF%A2%E4%B8%8A%E6%B5%B7%E5%85%AC%E4%BA%A4%E5%8D%A1%E4%BD%99%E9%A2%9D%EF%BC%8C%E5%B9%B6%E9%82%AE%E4%BB%B6%E9%80%9A%E7%9F%A5%2F</url>
    <content type="text"><![CDATA[python selenium 自动化查询上海公交卡余额，并邮件通知1、下载python安装。 https://www.python.org/downloads/release/python-351/2、安装selenium2.1、通过pip 安装 pip install selenium 2.2、通过下载包安装 ,直接下载selenium包： https://pypi.python.org/pypi/selenium 解压，cmd进入目录: python setup.py install 3 、 安装Chrome driver 下载地址：http://npm.taobao.org/mirrors/chromedriver 下载解压，将 chromedriver.exe 文件放到chrome的安装目录下…\Google\Chrome\Application\ ,然后设置path环境变量； 4、全部代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273 # coding = utf-8from selenium import webdriverfrom time import sleepimport smtplibimport tracebackfrom email.mime.text import MIMETextfrom email.mime.multipart import MIMEMultipartcardIDList = [u&quot;u54311******&quot;, u&quot;u728833******&quot;]def sendmail(subject,msg,toaddrs,fromaddr,smtpaddr,password): &apos;&apos;&apos; @subject:邮件主题 @msg:邮件内容 @toaddrs:收信人的邮箱地址 @fromaddr:发信人的邮箱地址 @smtpaddr:smtp服务地址，可以在邮箱看，比如163邮箱为smtp.163.com @password:发信人的邮箱密码 &apos;&apos;&apos; mail_msg = MIMEMultipart() mail_msg[&apos;Subject&apos;] = subject mail_msg[&apos;From&apos;] =fromaddr mail_msg[&apos;To&apos;] = &apos;,&apos;.join(toaddrs) mail_msg.attach(MIMEText(msg, &apos;html&apos;, &apos;utf-8&apos;)) try: s = smtplib.SMTP() s.connect(smtpaddr) #连接smtp服务器 s.login(fromaddr,password) #登录邮箱 s.sendmail(fromaddr, toaddrs, mail_msg.as_string()) #发送邮件 s.quit() except : print (&quot;Error: unable to send email&quot;) print (traceback.format_exc())def get_gj_info(cardID): for i in range(1, 10, 1): try: print(&quot;第%d次尝试。。。。&quot; % i) driver = webdriver.Chrome() print(&quot;###########&gt;&gt;&gt;&gt;&gt;&gt;&gt;开始打开上海交通网站&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;#########&quot;) driver.get(&apos;http://www.sptcc.com/&apos;) print(driver.title) print(&quot;网站打开成功&quot;) sleep(2) print(&quot;查询公交卡号:%s&quot; % cardID) driver.find_element_by_id(&quot;pL1i1&quot;).send_keys(cardID) driver.find_element_by_css_selector(&quot;a[class=\&quot;pL1b1\&quot;]&quot;).click() sleep(2) data = driver.find_element_by_css_selector(&quot;p[class=\&quot;amt\&quot;]&quot;).text print(&quot;公交卡 &#123;0&#125; &#123;1&#125; &quot;.format(cardID, data)) driver.quit() return &quot;公交卡 &#123;0&#125; &#123;1&#125; \n&quot;.format(cardID, data) break except: print(&quot;查询出错。。。，再次尝试。。。&quot;) print(&quot;##################&gt;&gt;&gt;&gt;&gt;&gt;&gt;退出查询&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;##############&quot;) return &quot;查询出错。。。&quot;if __name__ == &apos;__main__&apos;: fromaddr = &quot;*******@163.com&quot; smtpaddr = &quot;smtp.163.com&quot; # 163邮件smtp服务器地址 toaddrs = [&quot;*******@qq.com&quot;, &quot;*******@163.com&quot;] gj_info =&apos;&apos; for cardID in cardIDList: gj_info += get_gj_info(cardID) subject = gj_info password = &quot;*******&quot; msg = gj_info sendmail(subject,msg,toaddrs,fromaddr,smtpaddr,password)]]></content>
      <categories>
        <category>PYTHON实战</category>
      </categories>
      <tags>
        <tag>PYTHON</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[工具使用--第1节 git使用简记]]></title>
    <url>%2F2017%2F10%2F28%2F%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8-%E7%AC%AC1%E8%8A%82-git%E4%BD%BF%E7%94%A8%E7%AE%80%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[工具使用–第1节 git使用简记GIT （分布式版本控制系统） Git是一款免费、开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。 Git的读音为/gɪt/。 Git是一个开源的分布式版本控制系统，可以有效、高速的处理从很小到非常大的项目版本管理。 Git 是 Linus Torvalds 为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件。 Torvalds 开始着手开发 Git 是为了作为一种过渡方案来替代 BitKeeper，后者之前一直是 Linux 内核开发人员在全球使用的主要源代码工具。开放源码社区中的有些人觉得BitKeeper 的许可证并不适合开放源码社区的工作，因此 Torvalds 决定着手研究许可证更为灵活的版本控制系统。尽管最初 Git 的开发是为了辅助 Linux 内核开发的过程，但是我们已经发现在很多其他自由软件项目中也使用了 Git。例如 很多 Freedesktop 的项目迁移到了Git 上。 — 百度百科 1.安装git这里只说windows版本安装使用，Linux版本等以后再研究； 1.1 下载msysgitmsysgit是Windows版的Git，从https://git-for-windows.github.io下载（百度一下也有很多下载链接），然后按默认选项安装即可。**msysgit**的操作命令和Linux基本一致，很多命令是通用的，例如ls，mv，rm等；mygit安装完成后，在开始菜单里找到“Git”-&gt;“Git Bash”，蹦出一个类似命令行窗口的东西，就说明Git安装成功！ 2. 配置msysgit在桌面空白处右击，选择“Git Bash here”进入msysgit的控制台，输入一下两条命令，配置全局的用户名和邮箱：12$ git config --global user.name &quot;你的用户名&quot;$ git config --global user.email &quot;邮箱地址&quot; 你的用户名：可以随意设置，但要记住用户名邮箱地址：你的邮箱地址 3.创建代码仓3.1 进入你想建仓的目录在目录空白处右击选择“Git Bash here”进入msysgit的控制台，输入git init命令把这个目录变成Git可以管理的仓库： $ git init Initialized empty Git repository in C:/Users/Administrator/Desktop/usb_encryption_5.4.0/git_demo/.git/ git会在此目录创建.git目录，这是Git来跟踪管理版本库的，无需我们来改动， 4.版本控制我们现在在此目录下来创建一个readme.md文件，随意填写些内容，如下 4.1 查看版本状态 git status 4.2 添加到缓存区1git add readme.md 4.3 提交代码到版本仓1git commit -m &quot;Add readme&quot; -m 后面跟得是你提交的代码的描述，建议所有提交都应该添加描述。 暂时先记录这么多，下次再补充完整]]></content>
      <categories>
        <category>git教程</category>
      </categories>
      <tags>
        <tag>GIT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第10节 MFC菜单]]></title>
    <url>%2F2017%2F10%2F28%2F%E7%AC%AC10%E8%8A%82-MFC%E8%8F%9C%E5%8D%95%2F</url>
    <content type="text"><![CDATA[Windows编程基础–第10节 MFC菜单MFC菜单（CMenu）MFC菜单分为两类： 窗体菜单快捷菜单:又叫弹出菜单，或者上下文菜单 1、创建项目打开vs2010，创建一个基于对话框的项目，项目名“day10”,注意这次主框架中就不要勾选“系统菜单”和“关于框”了，如图：创建好后，删除自动生成的文本控件，如图： 2、创建系统菜单切换到资源视图，右击我们的项目“day10”，选择添加资源，出现如下界面： 选择“Menu”点击新建,然后就可以看到我们的项目中Menu目录，这里就存放菜单资源，展开后就可以看到，我们刚添加的菜单ID，双击打开；我们可以直接输入想要添加的菜单选项，如图：我们可以在资源视图右击菜单ID，然后选择属性，修改ID为IDR_MENU_SYSTEM; 3、显示系统菜单我们打开刚才创建的主窗口，右击打开属性，在属性列表找到MENU属性，下拉框选择刚才创建的IDR_MENU_SYSTEM菜单，如图所示：这时主窗口就和IDR_MENU_SYSTEM菜单关联起来了，运行看看效果： 4、创建菜单消息事件我们切换到我们创建的菜单界面，来实现菜单中保存选项的处理事件，在“保存”选项上右击，选择“添加事件处理函数”，如下：，出现如下添加事件界面：这里我们类列表中选择Cday10Dlg中创建操作函数，函数名修改为OnMenuSaveClick，点击“添加编辑”，添加处理函数； 12345void Cday10Dlg::OnMenuSaveClick()&#123; // TODO: 在此添加命令处理程序代码 AfxMessageBox(_T(&quot;文件已保存！&quot;)); &#125; 运行效果，点击“文件”-&gt;“保存”,此时就会弹窗提示“””文件已保存！”，如图所示： 5、创建快捷菜单切换资源视图，选择“Menu”点击“插入MENU”,自动打开；我们可以直接输入想要添加的菜单选项，如图：注意：快捷菜单中最上面的“快捷菜单”不会显示，名字可以随意。修改次menu的ID为IDR_MENU_QUICK； 6、显示快捷菜单我们打开刚才创建的主窗口，右击打开属性，在属性列表上方选择“消息”按钮，找到“WM_OnContextMenu”,选择add OnContextMenu方法，如图所示： 1234567891011void Cday10Dlg::OnContextMenu(CWnd* pWnd, CPoint point)&#123; // TODO: 在此处添加消息处理程序代码 CMenu menu; if(!menu.LoadMenu(IDR_MENU_QUICK)) &#123; return; &#125; CMenu* pMenu = menu.GetSubMenu(0); pMenu-&gt;TrackPopupMenu(TPM_LEFTALIGN|TPM_RIGHTBUTTON,point.x,point.y,pWnd);&#125; 这段代码的意思就是：先试图加载IDR_MENU_QUICK菜单，加载成功之后，将菜单显示在鼠标右击（TPM_RIGHTBUTTON），靠左方（TPM_LEFTALIGN）的位置；运行效果：可以看见，菜单已经显示出来； 7、创建菜单消息事件同步骤4，如图：编辑OnCopy函数，如下： 12345void Cday10Dlg::OnCopy()&#123; // TODO: 在此添加命令处理程序代码 AfxMessageBox(_T(&quot;文件已复制！&quot;)); &#125; 效果图： 项目源码可以访问我的码云]]></content>
      <categories>
        <category>MFC从入门到放弃</category>
      </categories>
      <tags>
        <tag>MFC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第9节 MFC对话框控件访问的七种方法（下）]]></title>
    <url>%2F2017%2F10%2F28%2F%E7%AC%AC9%E8%8A%82-MFC%E5%AF%B9%E8%AF%9D%E6%A1%86%E6%8E%A7%E4%BB%B6%E8%AE%BF%E9%97%AE%E7%9A%84%E4%B8%83%E7%A7%8D%E6%96%B9%E6%B3%95%EF%BC%88%E4%B8%8B%EF%BC%89%2F</url>
    <content type="text"><![CDATA[Windows编程基础–第9节 MFC对话框控件访问的七种方法（下）上节学习了MFC访问控件的三种方法，这节我们来学习剩下的四种方法，四种方法分别如下： 第四种把控件和整型变量相关联 第五种把控件和控件变量相关联 第六种 SendMessage方法 第七种SendDlgItemMessage方法 方法四 把控件和整型变量相关联1. 创建项目打开上节用到的day08项目，切换到资源视图，添加一个按钮“方法4”，我们在此按钮上实现方法四，如图所示： 2. 关联整型变量单击选择身高的输入框（IDC_EDIT_SG）,右击选择“添加变量”，打开如下界面：现在我们先选择类别为“value”，然后选择变量类型选择“int”，变量名“m_Height”，其余的默认就好，不过你也可以尝试修改一下最大值，最小值等。如图所示：现在我们切换到解决方案视图，可以看见，day08Dlg.h中已经增加了一个类变量，m_Height，day08Dlg.cpp中DoDataExchange也增加该变量的关联方法，将变量 m_Height和IDC_EDIT_SG的输入框关联起来，如下： 12345void Cday08Dlg::DoDataExchange(CDataExchange* pDX)&#123; CDialogEx::DoDataExchange(pDX); DDX_Text(pDX, IDC_EDIT_SG, m_Height);&#125; 还有day08Dlg的构造函数中也对m_Height进行了初始化，如下： 123456Cday08Dlg::Cday08Dlg(CWnd* pParent /*=NULL*/) : CDialogEx(Cday08Dlg::IDD, pParent) , m_Height(0)&#123; m_hIcon = AfxGetApp()-&gt;LoadIcon(IDR_MAINFRAME);&#125; 我们可以看到m_Height的初始化值为0，现在我们编译运行程序，可以看到身高输入框中的值就为0，如图：接下来我们分别关联IDC_EDIT_TZ和IDC_EDIT_BMI为变量int m_Weight,double m_BMI; 123int m_Height;int m_Weight;double m_BMI; 3.实现按钮事件现在m_Height ，m_Weight ，m_BMI 分别和界面上的三个输入框相关联，所以我们可以直接取它们的值就可以，也可以直接进行赋值，但这是会用下面这个方法: UpdateData(TRUE); //把控件的值关联到变量UpdateData(FALSE); //把变量的值关联到控件 12345678void Cday08Dlg::OnBnClickedButtonFunc4()&#123; // TODO: 在此添加控件通知处理程序代码 UpdateData(TRUE); //把控件的值关联到变量 double dHeight = m_Height / 100.00; m_BMI = m_Weight / (dHeight * dHeight ); UpdateData(FALSE); //把变量的值关联到控件&#125; 编译运行，这时就可以看到点击方法4之后，BMI值就计算出来了，如图： 方法五 把控件和控件变量相关联1. 添加“方法5”按钮如图： 1. 关联控件变量单击选择身高的输入框（IDC_EDIT_SG）,右击选择“添加变量”，打开如下界面： 现在我们先选择类别为“control”，变量名“m_edit_Height”，其余的默认就好，不过你也可以尝试修改一下最大值，最小值等。如图所示：接下来我们分别关联IDC_EDIT_TZ和IDC_EDIT_BMI为变量 CEdit m_edit_tz, CEdit m_edit_bmi;123CEdit m_edit_sg;CEdit m_edit_tz;CEdit m_edit_bmi; 3.实现按钮事件现在m_edit_sg，m_edit_tz，m_edit_bmi分别和界面上的三个输入框相关联，所以我们可以直接取它们的值就可以，也可以直接进行赋值，但这是会用下面这个方法: 12345678910111213141516void Cday08Dlg::OnBnClickedButtonFunc5()&#123; // TODO: 在此添加控件通知处理程序代码 TCHAR tcHeight[10], tcWeight[10] , tcBMI[10]; m_edit_sg.GetWindowText(tcHeight,10); m_edit_tz.GetWindowText(tcWeight,10); int nHeight = _ttoi(tcHeight); double dHeight = nHeight / 100.00; int nWeight = _ttoi(tcWeight); double bmi = nWeight/(dHeight * dHeight); char buf[28]; sprintf(buf, &quot;%.3f&quot;, bmi); m_edit_bmi.SetWindowText(buf);&#125; 方法六 SendMessage方法通过SendMessage方法发送WM_GETTEXT消息到控件所在窗口来获取控件文本值，同样发送WM_SETTEXT消息到控件所在窗口来设置控件文本值；12345678910111213141516void Cday08Dlg::OnBnClickedButtonFunc6()&#123; // TODO: 在此添加控件通知处理程序代码 TCHAR tcHeight[10], tcWeight[10] , tcBMI[10]; ::SendMessage(GetDlgItem(IDC_EDIT_SG)-&gt;m_hWnd,WM_GETTEXT,10,(LPARAM)tcHeight); ::SendMessage(GetDlgItem(IDC_EDIT_TZ)-&gt;m_hWnd,WM_GETTEXT,10,(LPARAM)tcWeight); int nHeight = _ttoi(tcHeight); double dHeight = nHeight / 100.00; int nWeight = _ttoi(tcWeight); double bmi = nWeight/(dHeight * dHeight); char buf[28]; sprintf(buf, &quot;%.3f&quot;, bmi); ::SendMessage(GetDlgItem(IDC_EDIT_BMI)-&gt;m_hWnd,WM_SETTEXT,10,(LPARAM)buf);&#125; 方法七 SendDlgItemMessage方法通过SendDlgItemMessage方法发送WM_GETTEXT消息到控件所在窗口来获取控件文本值，同样发送WM_SETTEXT消息到控件所在窗口来设置控件文本值；1234567891011121314151617void Cday08Dlg::OnBnClickedButtonFunc7()&#123; // TODO: 在此添加控件通知处理程序代码 TCHAR tcHeight[10], tcWeight[10] , tcBMI[10]; SendDlgItemMessage(IDC_EDIT_SG,WM_GETTEXT,10,(LPARAM)tcHeight); SendDlgItemMessage(IDC_EDIT_TZ,WM_GETTEXT,10,(LPARAM)tcWeight); int nHeight = _ttoi(tcHeight); double dHeight = nHeight / 100.00; int nWeight = _ttoi(tcWeight); double bmi = nWeight/(dHeight * dHeight); char buf[28]; sprintf(buf, &quot;%.3f&quot;, bmi); SendDlgItemMessage(IDC_EDIT_BMI,WM_SETTEXT,10,(LPARAM)buf);&#125; 总结，以上七种方法虽然结果相同，但是其内部机制是有所区别的，在我们将来的编程中要根据实际情况来选择合适的方法，最后，我们列举一下这七种方法：| 方法名 | 简介 || ——– | —–: || GetDlgItem() | 获取控件对象 || GetDlgItemText() | 获取对象文本 || GetDlgItemInt() | 获取对象整型值 || DDX_Text(pDX,IDC_EDIT_SG, m_Height); | 把控件和整型变量相关联 || DDX_Control(pDX,IDC_EDIT_BMI,m_edit_bmi); | 把控件和控件变量相关联 || SendMessage | 发送WM_GETTEXT消息到控件所在窗口来获取控件文本值 || SendDlgItemMessage | 发送WM_GETTEXT消息来获取控件文本值 | 项目源码可以访问我的码云]]></content>
      <categories>
        <category>MFC从入门到放弃</category>
      </categories>
      <tags>
        <tag>MFC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第8节 MFC对话框控件访问的七种方法（上）]]></title>
    <url>%2F2017%2F10%2F28%2F%E7%AC%AC8%E8%8A%82-MFC%E5%AF%B9%E8%AF%9D%E6%A1%86%E6%8E%A7%E4%BB%B6%E8%AE%BF%E9%97%AE%E7%9A%84%E4%B8%83%E7%A7%8D%E6%96%B9%E6%B3%95%EF%BC%88%E4%B8%8A%EF%BC%89%2F</url>
    <content type="text"><![CDATA[Windows编程基础–第8节 MFC对话框控件访问的七种方法（上）MFC对话框控件具有以下三种访问方式(当然还有很多别的访问方式，今天时间紧急，先学这三种)，分别是： 第一种GetDlgItem()-&gt;GetWindowText()GetDlgItem()-&gt;SetWindowText() 第二种GetDlgItemText() 第三种GetDlgItemInt()SetDlgItemInt() 1.新建一个对话框项目参见上节，我们这节采用VS2010编写一个身高体重计算器（BMI），参见 第二节； 2.布局编辑布局如下： EDIT名称 ID 身高 IDC_EDIT_SG 体重 IDC_EDIT_TZ BMI IDC_EDIT_BMI 3.实现方法双击确认按钮，编辑其点击消息处理函数； 1234567891011void Cday08Dlg::OnBnClickedOk()&#123; // TODO: 在此添加控件通知处理程序代码 int nHeight= GetDlgItemInt(IDC_EDIT_SG,NULL,TRUE); double dHeight = nHeight / 100.00; int nWeight = GetDlgItemInt(IDC_EDIT_TZ,NULL,TRUE); double bmi = nWeight/(dHeight*dHeight); char buf[28]; sprintf(buf, &quot;%.3f&quot;, bmi); SetDlgItemText(IDC_EDIT_BMI,buf);&#125; 这里可以看见使用到了GetDlgItemInt，这就是直接获取文本框的值，并返回为整形，然后用sprintf(buf, “%.3f”, bmi);将double类型值转换成字符串，并通过SetDlgItemText将字符串的值设置到ID为IDC_EDIT_BMI的文本框上； 4.编译运行估计很多人会像我一样，VS2010会报这样的错误：这是因为我们创建的项目的字符集为Unicode，不允许这样转换，这时我们只要将解决方案中右击项目名“day09”-&gt;“属性”-&gt;“配置属性”-&gt;”常规”-&gt;”字符集”-&gt;选择“使用多字节字符集”就好了，如下:这时就可以通过编译，运行结果如下： 5.其他方法再次编辑“确认”按钮的点击消息处理函数；第二种12345678910111213141516void Cday08Dlg::OnBnClickedOk()&#123; // TODO: 在此添加控件通知处理程序代码 TCHAR tcHeight[10], tcWeight[10]; GetDlgItem(IDC_EDIT_SG)-&gt;GetWindowText(tcHeight,10); GetDlgItem(IDC_EDIT_TZ)-&gt;GetWindowText(tcWeight,10); int nHeight = _ttoi(tcHeight); double dHeight = nHeight / 100.00; int nWeight = _ttoi(tcWeight); double bmi = nWeight/(dHeight * dHeight); char buf[28]; sprintf(buf, &quot;%.3f&quot;, bmi); GetDlgItem(IDC_EDIT_BMI)-&gt;SetWindowText(buf);&#125; 可以看见，这里用到了GetDlgItem(IDC_EDIT_SG)-&gt;GetWindowText(tcHeight,10)方法，这个方法的过程就是先通过GetDlgItem(IDC_EDIT_SG)获取到控件对象，然后调用控件的GetWindowText(tcHeight,10)方法来获取控件的显示文本； 第三种123456789101112131415void Cday08Dlg::OnBnClickedOk()&#123; TCHAR tcHeight[10], tcWeight[10] , tcBMI[10]; GetDlgItemText(IDC_EDIT_SG,tcHeight,10); GetDlgItemText(IDC_EDIT_TZ,tcWeight,10); int nHeight = _ttoi(tcHeight); double dHeight = nHeight / 100.00; int nWeight = _ttoi(tcWeight); double bmi = nWeight/(dHeight * dHeight); char buf[28]; sprintf(buf, &quot;%.3f&quot;, bmi); SetDlgItemText(IDC_EDIT_BMI,buf);&#125; 可以看见，这里直接用到了GetDlgItemText(IDC_EDIT_SG,tcHeight,10)方法，这个方法的过程就是先通过GetDlgItem(IDC_EDIT_SG)获取到控件对象，然后调用控件的GetWindowText(tcHeight,10)方法来设置控件的显示文本； 虽然上面三种方法最终结果是一样的，但是其本质还是有所区别的 项目源码可以访问我的码云]]></content>
      <categories>
        <category>MFC从入门到放弃</category>
      </categories>
      <tags>
        <tag>MFC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第7节 来吧，VS 2010]]></title>
    <url>%2F2017%2F10%2F28%2F%E7%AC%AC7%E8%8A%82-%E6%9D%A5%E5%90%A7%EF%BC%8CVS-2010%2F</url>
    <content type="text"><![CDATA[Windows编程基础–第7节 来吧，VS 2010VS 2010开发第一步 前面几节我们都是采用VC++ 6.0 作为IDE（集成开发环境），但是由于VC++ 6.0 已经过于老旧，目前大多数企业和个人都已经不再使用，而采用vs2005， vs2008， vs2010，vs2015作为MFC程序的开发环境，vs相对vc++6.0具有更友好的界面，及更强大的功能，采用vs开发MFC应用程序更加得心应手。 1、开始使用VS 20101.1 安装VS 2010参见百度百科 1.2 创建一个基于对话框项目执行“文件”-&gt;“新建”-&gt;“项目”，选择基于对话框的MFC程序，其他默认就好，基本上和VC++ 6.0 创建项目一模一样，如图所示： 1.3 创建一个字符统计窗口现在我们通过一个小例子来看看VS2010创建MFC程序有什么不同，我们来创建一个字符统计窗口，输入各种字符，最后统计出所有字符个数；设计界面如下，一个文本输入框，一个“统计”按钮，一个文本显示“字符个数”，直接在工具箱中拖动进来就OK，然后拖动大小适中就好，方法同VC++ 6.0 没有区别，可以参考上几节内容。注意: 若是右边没有工具箱选项卡，可以通过“视图”-&gt;“工具箱”打开。编译运行，效果图： 1.3 创建一个字符统计窗口双击“统计”按钮，编辑按钮的点击处理函数，我们来分析一下： 获取输入框中文本 获取输入框中文本的字符个数 将字符个数显示到静态文本上所以处理函数如下： 12345678910void Cday07Dlg::OnBnClickedButtonCount()&#123; // TODO: 在此添加控件通知处理程序代码 CString strInput,strOutput; GetDlgItemText(IDC_EDIT_TEXT,strInput); int nCount = strInput.GetLength(); strOutput.Format(_T(&quot;字符个数：%d &quot;),nCount); SetDlgItemText(IDC_STATIC_COUNT,strOutput);&#125; 1.4 编译运行运行结果图：这是我们发现当我们输入完成是，输入“回车”时，程序就会直接结束，那么我们修改输入框的属性值“Want Return”来允许输入框来接收回车，如图其实这是我们可以发现现在文本框是只能输入一行，显然不够美观，那么我们再修改一下输入框属性： Multiline：允许多行 Horizontal Scroll：水平滚动条 Vertical Scroll:垂直滚动条 再次编译运行：现在文本框现在可以输入多行，并且可以任意回车了。有人可能和我一样，发现程序没有关闭按钮，那是因为我在创建的时候取消了系统菜单，我们可以选定对话框主界面，选择属性-&gt;system menu-&gt;TRUE:这是关闭按钮就出现了，可以正常关闭了。 2、初探VS中消息映射机制2.1 创建EDIT的消息处理函数单击选定输入框，右击选择“添加事件处理程序”，这是可以很直观的看见EDIT的消息列表和要添加到的类，以及添加的处理函数名，现在我们来添加一个EN_CHANGE的消息处理函数，如图所示：单击“添加编辑”来编辑消息处理函数，代码如下： 12345678910111213141516void Cday07Dlg::OnEnChangeEditText()&#123; // TODO: 如果该控件是 RICHEDIT 控件，它将不 // 发送此通知，除非重写 CDialogEx::OnInitDialog() // 函数并调用 CRichEditCtrl().SetEventMask()， // 同时将 ENM_CHANGE 标志“或”运算到掩码中。 // TODO: 在此添加控件通知处理程序代码 CString strInput,strOutput; GetDlgItemText(IDC_EDIT_TEXT,strInput); int nCount = strInput.GetLength(); strOutput.Format(_T(&quot;字符个数：%d &quot;),nCount); SetDlgItemText(IDC_STATIC_COUNT,strOutput);&#125; 2.2 编译运行这是我们可以发现我们在输入框中输入字符时，下方的字符统计数会实时显示，这就是输入文本时，EDIT的EN_CHANGE消息被触发，从而触发其消息处理函数OnEnChangeEditText，导致字符统计数实时更新，效果图如下： 2.3 MFC消息映射机制流程12345678st=&gt;start: Startop=&gt;operation: 输入框文本变化op2=&gt;operation: 触发EN_CHANGE消息op3=&gt;operation: 调用EN_CHANGE的处理函数OnEnChangeEditTextop4=&gt;operation: 将输入框字符数返回到界面e=&gt;endst-&gt;op-&gt;op2-&gt;op3-&gt;op4-&gt;e 项目源码可以访问我的码云]]></content>
      <categories>
        <category>MFC从入门到放弃</category>
      </categories>
      <tags>
        <tag>MFC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第6节 VC++6.0控件说明]]></title>
    <url>%2F2017%2F10%2F28%2F%E7%AC%AC6%E8%8A%82-VC-6-0%E6%8E%A7%E4%BB%B6%E8%AF%B4%E6%98%8E%2F</url>
    <content type="text"><![CDATA[Windows编程基础–第6节 VC++6.0控件说明VC++6.0控件工具箱 控件说明 2 图形控件（picture）：常用于显示位图（Bitmap）和图标（Icon） 3 静态文本（Static Text）：用来在指定的位置显示特定的字符串，一般用来标识附近另一个控件的内容。显示在静态文本控件中的字符串一般不再改变，但是在需要的时候，也可以通过调用相应的函数来进行设置。MFC提供了CStatic类支持静态控件。 4 编辑框（Edit Box）：用来接收用户输入的字符串。通过选择编辑框的选项，编辑框可以接收字符串、数字、密码等；编辑框还可以设置成接收多行字符串的模式；可以自动进行大小写转换。编辑框可能向其父窗口发送多种控件通知，如果用户需要，可以对这些控件通知进行处理。MFC提供了CEdit类支持编辑框控件。 5 组成框（Group Box）：用来包围具有逻辑关系的一组控件，在这些控件的周围加上边界和标题。需注意的是，组成框仅仅是在视觉效果上对控件进行“成组”，真正的“成组”工作还需要另外一些工作。 6 按钮（Button）：用来接收用户的命令，应用程序在接收到用户命令后，通常需要进行一些后台工作。按钮可以响应单击或双击动作，在按钮接收到鼠标动作后，向其父窗口发送相应的控件通知，用户可以对这些控件通知进行消息映射，从而进行相应的处理。在一个对话框中，可以定义一个默认按钮，这只要选中按钮属性中的“Default”选项。如果在对话框活动的时候按下了Enter键，则等同于单击了默认按钮。MFC提供了CButton类支持按钮控件。 7 复选框（Check Box）：用来显示某种可能的选择，该项选择是独立的，用户可以选中或取消该选项。在选项被选中的时候核选标记出现，选项被取消时核选标记消失。MFC中由CButton类对核选框进行支持，用户可以通过SetCheck()函数和GetCheck()函数设置或获取核选框当前的状态。 8 单选按钮（Radio Button）：用来选择某种可能的选择，与核选框不同，该选项不是独立的。一般是几个单选按钮组成一组，同组中的单选按钮可以有也只能有一个按钮被选中。MFC同样使用CButton类对单选按钮控件进行支持，SetCheck()函数和GetCheck()函数对单选按钮也是适用的。 9 组合框（Combo Box）：列表框和编辑框的组合，用户除了可以在列表中对已经存在的选项进行选择外，还可以输入新的选择。MFC提供了CComboBox类对组合框控件进行支持。 10 列表框（List Box）：用来选择一系列的可能选择，用户通过滚动条可以在这些选择中浏览。在列表框中，可以进行单项选择，也可以进行多项选择，这取决于用户在控件属性对话框中的设置。MFC提供了CListBox类对列表框控件进行支持。 11、12 滚动条（Scroll Bar）：这包括水平滚动条和垂直滚动条，除了在视觉效果上的方向不同外，水平滚动条在被滚动时发生WM_HSCROLL消息，而垂直滚动条在被滚动时发送WM_VSCROLL消息。MFC提供了CScrollBar进行支持。 13 微调按钮（Spin Button）：包括一对紧靠在一起的上下箭头，使用微调按钮可以增大或者缩小某个特定的数值。微调按钮往往都需要一个“伙伴”控件，这通常都是一个编辑框。当微调按钮的向上箭头被单击时，编辑框中的数字就增大；反之则减小。MFC提供了CPinButtonCtrl类进行支持。 14 进度条（Progress）：在进行一项需要占有较长时间的操作时来反应当前的进度。当操作的进度不断前进时，进度条就用特色颜色填充进度条框。用户可以设定进度条的范围和当前位置。MFC提供了CProgressCtrl类进行支持。 15 滑块控件（Slider）：通常用来在程序中接受一系列离散的数值。用户可以设置滑块控件的取值范围，并可以为控件加上刻度标记以显示特定位置的含义。MFC提供了CSliderCtrl类进行支持。 16 热键控制（Hot Key）：热键控件看起来就像一个编辑框，但是在热键控件中能够立刻反应用户刚刚按下的键组合，这在设置程序的热键时特别有用。热键控件只是在“视觉”上显示了按键组合，设置热键的工作还需要用户添加代码完成。MFC提供了CHotKey类进行支持。 17 列表控制（List Control）：按一定的排列顺序显示一系列带图标的字符串，列表控件提供了四种显示模式：大图标、小图标、列表和详细信息。用户可以向列表控件中添加新的项，也可以控制列表控件的显示模式。MFC提供了CListCtrl类进行支持。 18 树形控件（Tree Control）：用来显示一系列项目的层次关系，最典型的例子是显示磁盘上的文件与文件夹。如果有子项目的话，单击树形控件中的项目可以展开或者收缩其子项目。MFC提供了CTreeCtrl类进行支持。 19 属性表控件（Tab Control）：用来包含大量的控件，可以满足用户显示或者获取大量数据的要求。每个属性表又分为好几个属性页，这些属性页由各自的标签进行区分，这些属性页中都可以包容其他控件。在显示属性表的时候，一次只能够显示一个属性页的全部内容，同时显示其他属性页的标签，用户通过单击标签打开相应的属性页。MFC提供了CTabCtrl类进行支持。 20 动画控件（Animation）：用来播放一段AVI格式的视频剪辑。用户可以控制视频剪辑的播放、停止和定位，但也仅限于这些功能。动画控件设置不能播放音频剪辑，如果用户需要更高层次的视频或者音频的支持，请选用MCIWnd控件。MFC提供了CAnimateCtrl类对动画控件进行支持。 21 高级编辑框（Rich Edit）：编辑控件功能的扩展。在高级编辑框中，除了简单的输入和编辑字符串外，用户还可以为字符或段落指定特定的格式，用户甚至还可以向高级编辑框中插入OLE项。高级编辑框基本上实现了一个带格式的文本编辑器功能，而只需要用户添加少量的接口。MFC提供了CRichEditCtrl类进行支持。 22 日历控件（Month Calender）：看似与真正的日历类似，操作也类似，直观的为用户提供了观察和显示当前日期的途径。MFC提供了CMonthCalCtrl类进行支持。 23 日期/时间选择器（Date Time Picker）：向用户提供了一种直观的选择日期和时间的方法、日期/时间选择器在外观上类似于一个组合框，但是当用户单击下拉箭头时就会展开一个日历控件供用户选择，而一旦用户做出了选择，日期/时间选择器会自动显示新的日期/时间。MFC提供了CDateTimeCtrl类进行支持。 24 IP地址控件（IP Adress）:IP地址控件用来输入和编辑IP地址。该控件外观类似于一个编辑框，但是可以自动对输入的字符按3个一组进行区分和加间隔圆点。IP地址控件为开发支持Internet技术的程序提供了方便。MFC提供了CIPAddressCtrl类进行支持。 26 扩展组合框（Extended Combo Box）：在普通组合框的基础上还支持图像列表。即，可以在组合框中显示特定的图标表示相应的选择，而不仅仅是显示文本。MFC提供了CComboBoxEx类进行支持。 所有控件的公共属性 ID：控件的资源标识。Visiable：控件是否可见。Disabled：控件是否被禁止、被禁止的控件无法接受键盘和鼠标输入。Group：是否从这个空间开始一个新组。Tab stop：在程序中是否可以用【Tab】键切换到这个控件。Help ID：是否给控件分配一个帮助标识，帮助标识基于控件本身的资源标识。Client edge：给控件增加一个凹陷的边界，使整个控件看起来像是凹下去的一样。Static edge：给控件增加一个边界。Modal frame：给控件增加一个3维的框架，与Client edge相反，它是凸出来的。Transparent：拥有此属性的窗口是透明的，它下面的窗口不会被它遮掩住。Accept files：拥有此属性的窗口可以接收拖放文件，如果一个文件被拖动到这个控件上面，控件会收到WM_DROPFILES消息。No parent notify：表示控件不向其父窗口发送WM_PARENTNOTIFY消息。Right aligned text：表示文本右对齐。 以上属性可通过控件的属性对话框进行设置，在属性对话框中按【F1】键可以查看属性的帮助信息。每一种控件都由一个MFC控件类来管理，当通过资源编辑器在对话框上添加一个控件时 ，visualC++会自动为控件类生成一个实例，即对象，并调用构造函数，当对话框关闭时，其各个子控件对象被自动销毁。也可以不使用资源编辑器，自己在程序中写代码创建、显示控件并设置控件的属性。所有的控件类都继承自CWnd，控件的某些操作和属性设置需要用到CWnd本身的成员函数，CWnd某些函数经常用来操纵控件和设置控件属性。 SetWindowText：设置控件上要显示的标题文本，即用来设置控件的caption属性GetWindowText：得到控件的标题文本EnableWindow：设置控件的Disabled属性，即社会自控件是否可以接收键盘和鼠标的输入SetWindowPos：改变窗口的大小、位置和Z轴次序。 MoveWindow：改变窗口的大小和位置GetWindowRec：得到窗口的大小、位置（信息存放在一个矩形结构中）。GetClientRect：得到窗口客户区的大小（信息存放在一个矩形结构中 ） ShowWindow：设置窗口的可见性（即窗口是否可见）SetWindowText/GetWindowText还可以用来设置/得到对话框的标题文本。 转载Button 按钮窗口（控件）在MFC中使用CButton表示，CButton包含了三种样式的按钮，Push Button，Check Box，Radio Box。所以在利用CButton对象生成按钮窗口时需要指明按钮的风格。 创建按钮：BOOL CButton::Create( LPCTSTR lpszCaption, DWORD dwStyle, const RECT&amp; rect, CWnd* pParentWnd, UINT nID );其中lpszCaption是按钮上显示的文字，dwStyle为按钮风格，除了Windows风格可以使用外（如 WS_CHILD|WS_VISUBLE|WS_BORDER）还有按钮专用的一些风格。 · BS_AUTOCHECKBOX 检查框，按钮的状态会自动改变 Same as a check box, except that a check mark appears in the check box when the user selects the box; the check mark disappears the next time the user selects the box. · BS_AUTORADIOBUTTON 圆形选择按钮，按钮的状态会自动改变 Same as a radio button, except that when the user selects it, the button automatically highlights itself and removes the selection from any other radio buttons with the same style in the same group. · BS_AUTO3STATE 允许按钮有三种状态即：选中，未选中，未定 Same as a three-state check box, except that the box changes its state when the user selects it. · BS_CHECKBOX 检查框 Creates a small square that has text displayed to its right (unless this style is combined with the BS_LEFTTEXT style). · BS_DEFPUSHBUTTON 默认普通按钮 Creates a button that has a heavy black border. The user can select this button by pressing the ENTER key. This style enables the user to quickly select the most likely option (the default option). · BS_LEFTTEXT 左对齐文字 When combined with a radio-button or check-box style, the text appears on the left side of the radio button or check box. · BS_OWNERDRAW 自绘按钮 Creates an owner-drawn button. The framework calls the DrawItem member function when a visual aspect of the button has changed. This style must be set when using the CBitmapButton class. · BS_PUSHBUTTON 普通按钮 Creates a pushbutton that posts a WM_COMMAND message to the owner window when the user selects the button. · BS_RADIOBUTTON 圆形选择按钮 Creates a small circle that has text displayed to its right (unless this style is combined with the BS_LEFTTEXT style). Radio buttons are usually used in groups of related but mutually exclusive choices. · BS_3STATE 允许按钮有三种状态即：选中，未选中，未定 Same as a check box, except that the box can be dimmed as well as checked. The dimmed state typically is used to show that a check box has been disabled. rect为窗口所占据的矩形区域，pParentWnd为父窗口指针，nID为该窗口的ID值。 获取/改变按钮状态：对于检查按钮和圆形按钮可能有两种状态，选中和未选中，如果设置了BS_3STATE或BS_AUTO3STATE风格就可能出现第三种状态：未定，这时按钮显示灰色。通过调用int CButton::GetCheck( ) 得到当前是否被选中，返回0：未选中，1：选中，2：未定。调用void CButton::SetCheck( int nCheck );设置当前选中状态。 处理按钮消息：要处理按钮消息需要在父窗口中进行消息映射，映射宏为ON_BN_CLICKED( id, memberFxn )id为按钮的ID值，就是创建时指定的nID值。处理函数原型为afx_msg void memberFxn( ); Static Box 静态文本控件的功能比较简单，可作为显示字符串，图标，位图用。创建一个窗口可以使用成员函数： BOOL CStatic::Create( LPCTSTR lpszText, DWORD dwStyle, const RECT&amp; rect, CWnd* pParentWnd, UINT nID = 0xffff );其中dwStyle将指明该窗口的风格，除了子窗口常用的风格WS_CHILD,WS_VISIBLE外，你可以针对静态控件指明专门的风格。 · SS_CENTER,SS_LEFT,SS_RIGHT 指明字符显示的对齐方式。 · SS_GRAYRECT 显示一个灰色的矩形 · SS_NOPREFIX 如果指明该风格，对于字符&amp;将直接显示，否则&amp;将作为转义符，&amp;将不显示而在其后的字符将有下划线，如果需要直接显示&amp;必须使用&amp;&amp;表示。 · SS_BITMAP 显示位图 · SS_ICON 显示图标 · SS_CENTERIMAGE 图象居中显示 控制显示的文本利用成员函数SetWindowText/GetWindowText用于设置/得到当前显示的文本。 控制显示的图标利用成员函数SetIcon/GetIcon用于设置/得到当前显示的图标。 控制显示的位图利用成员函数SetBitmap/GetBitmap用于设置/得到当前显示的位图。下面一段代码演示如何创建一个显示位图的静态窗口并设置位图 1CStatic* pstaDis=new CStatic; pstaDis-&gt;Create(&quot;&quot;,WS_CHILD|WS_VISIBLE|SS_BITMAP|SSCENTERIMAGE, CRect(0,0,40,40),pWnd,1); CBitmap bmpLoad; bmpLoad.LoadBitmap(IDB_TEST); pstaDis-&gt;SetBitmap(bmpLoad.Detach()); Edit Box Edit窗口是用来接收用户输入最常用的一个控件。创建一个输入窗口可以使用成员函数：BOOL CEdit::Create( LPCTSTR lpszText, DWORD dwStyle, const RECT&amp; rect, CWnd* pParentWnd, UINT nID = 0xffff );其中dwStyle将指明该窗口的风格，除了子窗口常用的风格WS_CHILD,WS_VISIBLE外，你可以针对输入控件指明专门的风格。 · ES_AUTOHSCROLL,ES_AUTOVSCROLL 指明输入文字超出显示范围时自动滚动。 · ES_CENTER,ES_LEFT,ES_RIGHT 指定对齐方式 · ES_MULTILINE 是否允许多行输入 · ES_PASSWORD 是否为密码输入框，如果指明该风格则输入的文字显示为* · ES_READONLY 是否为只读 · ES_UPPERCASE,ES_LOWERCASE 显示大写/小写字符 控制显示的文本利用成员函数SetWindowText/GetWindowText用于设置/得到当前显示的文本。 通过GetLimitText/SetLimitText可以得到/设置在输入框中输入的字符数量。 由于在输入时用户可能选择某一段文本，所以通过void CEdit::GetSel( int&amp; nStartChar, int&amp; nEndChar )得到用户选择的字符范围，通过调用void CEdit::SetSel( int nStartChar, int nEndChar, BOOL bNoScroll = FALSE )可以设置当前选择的文本范围，如果指定nStartChar=0 nEndChar=-1则表示选中所有的文本。void ReplaceSel( LPCTSTR lpszNewText, BOOL bCanUndo = FALSE )可以将选中的文本替换为指定的文字。 此外输入框还有一些和剪贴板有关的功能，void Clear( );删除选中的文本，void Copy( );可将选中的文本送入剪贴板，void Paste( );将剪贴板中内容插入到当前输入框中光标位置，void Cut( );相当于Copy和Clear结合使用。 最后介绍一下输入框几种常用的消息映射宏： · ON_EN_CHANGE 输入框中文字更新后产生 · ON_EN_ERRSPACE 输入框无法分配内存时产生 · ON_EN_KILLFOCUS / ON_EN_SETFOCUS 在输入框失去/得到输入焦点时产生 使用以上几种消息映射的方法为定义原型如：afx_msg void memberFxn( );的函数，并且定义形式如ON_Notification( id, memberFxn )的消息映射。如果在对话框中使用输入框，Class Wizard会自动列出相关的消息，并能自动产生消息映射代码。 Scroll Bar Scroll Bar一般不会单独使用，因为SpinCtrl可以取代滚动条的一部分作用，但是如果你需要自己生成派生窗口，滚动条还是会派上一些用场。创建一个滚动条可以使用成员函数： ：BOOL CEdit::Create( LPCTSTR lpszText, DWORD dwStyle, const RECT&amp; rect, CWnd* pParentWnd, UINT nID = 0xffff );其中dwStyle将指明该窗口的风格，除了子窗口常用的风格WS_CHILD,WS_VISIBLE外，你可以针对滚动条指明专门的风格。 · SBS_VERT 风格将创建一个垂直的滚动条。 · SBS_HORZ 风格将创建一个水平的滚动条。 在创建滚动条后需要调用void SetScrollRange( int nMinPos, int nMaxPos, BOOL bRedraw = TRUE )设置滚动范围，int GetScrollPos( )/int SetScrollPos( )用来得到和设置当前滚动条的位置。 void ShowScrollBar( BOOL bShow = TRUE );用来显示/隐藏滚动条。 BOOL EnableScrollBar( UINT nArrowFlags = ESB_ENABLE_BOTH )用来设置滚动条上箭头是否为允许状态。nArrowFlags可取以下值： · ESB_ENABLE_BOTH 两个箭头都为允许状态 · ESB_DISABLE_LTUP 上/左箭头为禁止状态 · ESB_DISABLE_RTDN 下/右箭头为禁止状态 · ESB_DISABLE_BOTH 两个箭头都为禁止状态 如果需要在滚动条位置被改变时得到通知，需要在父窗口中定义对消息WM_VSCROLL/WM_HSCROLL的映射。方法为在父窗口类中重载afx_msg void OnVScroll( UINT nSBCode, UINT nPos, CScrollBar pScrollBar )/afx_msg void OnHScroll( UINT nSBCode, UINT nPos, CScrollBar pScrollBar )所使用的消息映射宏为：ON_WM_VSCROLL( ),ON_WM_HSCROLL( )，在映射宏中不需要指明滚动条的ID，因为所有滚动条的滚动消息都由同样的函数处理。在OnHScroll/OnVScroll的第三个参数会指明当前滚动条的指针。第一个参数表示滚动条上发生的动作，可取以下值： · SB_TOP/SB_BOTTOM 已滚动到顶/底部 · SB_LINEUP/SB_LINEDOWN 向上/下滚动一行 · SB_PAGEDOWN/SB_PAGEUP 向上/下滚动一页 · SB_THUMBPOSITION/SB_THUMBTRACK 滚动条拖动到某一位置，参数nPos指明当前位置（参数&gt;nPos在其它的情况下是无效的） · SB_ENDSCROLL 滚动条拖动完成（用户松开鼠标） List Box/Check List Box ListBox窗口用来列出一系列的文本，每条文本占一行。创建一个列表窗口可以使用成员函数：BOOL CListBox::Create( LPCTSTR lpszText, DWORD dwStyle, const RECT&amp; rect, CWnd* pParentWnd, UINT nID = 0xffff );其中dwStyle将指明该窗口的风格，除了子窗口常用的风格WS_CHILD,WS_VISIBLE外，你可以针对列表控件指明专门的风格。 · LBS_MULTIPLESEL 指明列表框可以同时选择多行 · LBS_EXTENDEDSEL 可以通过按下Shift/Ctrl键选择多行 · LBS_SORT 所有的行按照字母顺序进行排序 在列表框生成后需要向其中加入或是删除行，可以利用： int AddString( LPCTSTR lpszItem )添加行， intDeleteString( UINT nIndex )删除指定行， int InsertString( int nIndex,LPCTSTR lpszItem )将行插入到指定位置。 void ResetContent( )可以删除列表框中所有行。通过调用int GetCount( )得到当前列表框中行的数量。 如果需要得到/设置当前被选中的行，可以调用int GetCurSel( )/int SetCurSel(intiIndex)。如果你指明了选择多行的风格，你就需要先调用int GetSelCount( )得到被选中的行的数量，然后intGetSelItems( int nMaxItems, LPINT rgIndex)得到所有选中的行，参数rgIndex为存放被选中行的数组。通过调用int GetLBText( int nIndex, LPTSTRlpszText )得到列表框内指定行的字符串。 此外通过调用int FindString( int nStartAfter, LPCTSTR lpszItem)可以在当前所有行中查找指定的字符传的位置，nStartAfter指明从那一行开始进行查找。 int SelectString( intnStartAfter, LPCTSTR lpszItem )可以选中包含指定字符串的行。 在MFC4.2版本中添加了CCheckListBox类，该类是由CListBox派生并拥有CListBox的所有功能，不同的是可以在每行前加上一个检查框。必须注意的是在创建时必须指明LBS_OWNERDRAWFIXED或LBS_OWNERDRAWVARIABLE风格。 通过void SetCheckStyle( UINT nStyle )/UINT GetCheckStyle()可以设置/得到检查框的风格，关于检查框风格可以参考4.1 Button中介绍。通过void SetCheck( int nIndex,int nCheck )/int GetCheck( int nIndex )可以设置和得到某行的检查状态，关于检查框状态可以参考4.1Button中介绍。 最后介绍一下列表框几种常用的消息映射宏： · ON_LBN_DBLCLK 鼠标双击 · ON_EN_ERRSPACE 输入框无法分配内存时产生 · ON_EN_KILLFOCUS / ON_EN_SETFOCUS 在输入框失去/得到输入焦点时产生 · ON_LBN_SELCHANGE 选择的行发生改变 使用以上几种消息映射的方法为定义原型如：afx_msg void memberFxn();的函数，并且定义形式如ON_Notification( id, memberFxn )的消息映射。如果在对话框中使用列表框，ClassWizard会自动列出相关的消息，并能自动产生消息映射代码。 Combo Box/Combo Box Ex 组合窗口是由一个输入框和一个列表框组成。创建一个组合窗口可以使用成员函数： BOOL CListBox::Create( LPCTSTRlpszText, DWORD dwStyle, const RECT&amp; rect, CWnd* pParentWnd, UINT nID= 0xffff ); 其中dwStyle将指明该窗口的风格，除了子窗口常用的风格WS_CHILD,WS_VISIBLE外，你可以针对列表控件指明专门的风格。 · CBS_DROPDOWN 下拉式组合框 · CBS_DROPDOWNLIST 下拉式组合框，但是输入框内不能进行输入 · CBS_SIMPLE 输入框和列表框同时被显示 · LBS_SORT 所有的行按照字母顺序进行排序 由于组合框内包含了列表框，所以列表框的功能都能够使用，如可以利用： int AddString( LPCTSTR lpszItem)添加行， int DeleteString( UINT nIndex )删除指定行， int InsertString( intnIndex, LPCTSTR lpszItem )将行插入到指定位置。 void ResetContent( )可以删除列表框中所有行。通过调用int GetCount( )得到当前列表框中行的数量。 如果需要得到/设置当前被选中的行的位置，可以调用int GetCurSel( )/int SetCurSel(intiIndex)。通过调用int GetLBText( int nIndex, LPTSTR lpszText )得到列表框内指定行的字符串。 此外通过调用int FindString( int nStartAfter, LPCTSTR lpszItem)可以在当前所有行中查找指定的字符传的位置，nStartAfter指明从那一行开始进行查找。 int SelectString( intnStartAfter, LPCTSTR lpszItem )可以选中包含指定字符串的行。 此外输入框的功能都能够使用，如可以利用： DWORD GetEditSel( ) /BOOL SetEditSel( intnStartChar, int nEndChar )得到或设置输入框中被选中的字符位置。 BOOL LimitText( intnMaxChars )设置输入框中可输入的最大字符数。 输入框的剪贴板功能Copy,Clear,Cut,Paste动可以使用。 最后介绍一下列表框几种常用的消息映射宏： · ON_CBN_DBLCLK 鼠标双击 · ON_CBN_DROPDOWN 列表框被弹出 · ON_CBN_KILLFOCUS / ON_CBN_SETFOCUS 在输入框失去/得到输入焦点时产生 · ON_CBN_SELCHANGE 列表框中选择的行发生改变 · ON_CBN_EDITUPDATE 输入框中内容被更新 使用以上几种消息映射的方法为定义原型如：afx_msg void memberFxn();的函数，并且定义形式如ON_Notification( id, memberFxn )的消息映射。如果在对话框中使用组合框，ClassWizard会自动列出相关的消息，并能自动产生消息映射代码。 Tree Ctrl 树形控件TreeCtrl和下节要讲的列表控件 ListCtrl在系统中大量被使用，例如Windows资源管理器就是一个典型的例子。 树形控件可以用于树形的结构，其中有一个根接点(Root)然后下面有许多子结点，而每个子结点上有允许有一个或多个或没有子结点。MFC中使用CTreeCtrl类来封装树形控件的各种操作。通过调用BOOL Create( DWORD dwStyle, const RECT&amp; rect, CWnd* pParentWnd, UINTnID );创建一个窗口，dwStyle中可以使用以下一些树形控件的专用风格： · TVS_HASLINES 在父/子结点之间绘制连线 · TVS_LINESATROOT 在根/子结点之间绘制连线 · TVS_HASBUTTONS 在每一个结点前添加一个按钮，用于表示当前结点是否已被展开 · TVS_EDITLABELS 结点的显示字符可以被编辑 · TVS_SHOWSELALWAYS 在失去焦点时也显示当前选中的结点 · TVS_DISABLEDRAGDROP 不允许Drag/Drop · TVS_NOTOOLTIPS 不使用ToolTip显示结点的显示字符 在树形控件中每一个结点都有一个句柄（HTREEITEM），同时添加结点时必须提供的参数是该结点的父结点句柄，（其中根Root结点只有一个，既不可以添加也不可以删除）利用HTREEITEM InsertItem( LPCTSTR lpszItem, HTREEITEM hParent = TVI_ROOT,HTREEITEM hInsertAfter = TVI_LAST);可以添加一个结点，pszItem为显示的字符，hParent代表父结点的句柄，当前添加的结点会排在hInsertAfter表示的结点的后面，返回值为当前创建的结点的句柄。下面的代码会建立一个如下形式的树形结构： +— Parent1 +— Child1_1 +— Child1_2 +— Child1_3 +— Parent2 +— Parent3 /假设m_tree为一个CTreeCtrl对象，而且该窗口已经创建/ HTREEITEM hItem,hSubItem; hItem = m_tree.InsertItem(“Parent1”,TVI_ROOT);在根结点上添加Parent1 hSubItem = m_tree.InsertItem(“Child1_1”,hItem);//在Parent1上添加一个子结点 hSubItem =m_tree.InsertItem(“Child1_2”,hItem,hSubItem);//在Parent1上添加一个子结点，排在Child1_1后面 hSubItem =m_tree.InsertItem(“Child1_3”,hItem,hSubItem); hItem =m_tree.InsertItem(“Parent2”,TVI_ROOT,hItem); hItem =m_tree.InsertItem(“Parent3”,TVI_ROOT,hItem); 如果你希望在每个结点前添加一个小图标，就必需先调用CImageList SetImageList( CImageList pImageList, int nImageListType);指明当前所使用的ImageList，nImageListType为TVSIL_NORMAL。在调用完成后控件中使用图片以设置的ImageList中图片为准。然后调用 HTREEITEM InsertItem( LPCTSTR lpszItem, intnImage, int nSelectedImage, HTREEITEM hParent = TVI_ROOT, HTREEITEMhInsertAfter =TVI_LAST);添加结点，nImage为结点没被选中时所使用图片序号，nSelectedImage为结点被选中时所使用图片序号。下面的代码演示了ImageList的设置。 /m_list 为CImageList对象 IDB_TREE 为16(164)的位图，每个图片为1616共4个图标*/m_list.Create(IDB_TREE,16,4,RGB(0,0,0));m_tree.SetImageList(&amp;m_list,TVSIL_NORMAL);m_tree.InsertItem(“Parent1”,0,1); //添加，选中时显示图标1，未选中时显示图标0 此外CTreeCtrl还提供了一些函数用于得到/修改控件的状态。 HTREEITEM GetSelectedItem();将返回当前选中的结点的句柄。BOOL SelectItem( HTREEITEM hItem );将选中指明结点。 BOOLGetItemImage( HTREEITEM hItem, int&amp; nImage, int&amp; nSelectedImage ) /BOOL SetItemImage( HTREEITEM hItem, int nImage, int nSelectedImage)用于得到/修改某结点所使用图标索引。 CString GetItemText( HTREEITEM hItem ) /BOOLSetItemText( HTREEITEM hItem, LPCTSTR lpszItem );用于得到/修改某一结点的显示字符。BOOL DeleteItem( HTREEITEM hItem );用于删除某一结点，BOOL DeleteAllItems();将删除所有结点。 此外如果想遍历树可以使用下面的函数： HTREEITEM GetRootItem( );得到根结点。 HTREEITEMGetChildItem( HTREEITEM hItem );得到子结点。 HTREEITEMGetPrevSiblingItem/GetNextSiblingItem( HTREEITEM hItem);得到指明结点的上/下一个兄弟结点。 HTREEITEM GetParentItem( HTREEITEM hItem );得到父结点。 树形控件的消息映射使用ON_NOTIFY宏，形式如同：ON_NOTIFY( wNotifyCode, id, memberFxn)，wNotifyCode为通知代码，id为产生该消息的窗口ID，memberFxn为处理函数，函数的原型如同voidOnXXXTree(NMHDR pNMHDR, LRESULTpResult)，其中pNMHDR为一数据结构，在具体使用时需要转换成其他类型的结构。对于树形控件可能取值和对应的数据结构为： · TVN_SELCHANGED 在所选中的结点发生改变后发送，所用结构：NMTREEVIEW · TVN_ITEMEXPANDED 在某结点被展开后发送，所用结构：NMTREEVIEW · TVN_BEGINLABELEDIT 在开始编辑结点字符时发送，所用结构：NMTVDISPINFO · TVN_ENDLABELEDIT 在结束编辑结点字符时发送，所用结构：NMTVDISPINFO · TVN_GETDISPINFO 在需要得到某结点信息时发送，（如得到结点的显示字符）所用结构：NMTVDISPINFO 关于ON_NOTIFY有很多内容，将在以后的内容中进行详细讲解。 关于动态提供结点所显示的字符：首先你在添加结点时需要指明lpszItem参数为：LPSTR_TEXTCALLBACK。在控件显示该结点时会通过发送TVN_GETDISPINFO来取得所需要的字符，在处理该消息时先将参数pNMHDR转换为LPNMTVDISPINFO，然后填充其中item.pszText。但是我们通过什么来知道该结点所对应的信息呢，我的做法是在添加结点后设置其lParam参数，然后在提供信息时利用该参数来查找所对应的信息。下面的代码说明了这种方法： char szOut[8][3]={“No.1”,”No.2”,”No.3”}; //添加结点 HTREEITEM hItem =m_tree.InsertItem(LPSTR_TEXTCALLBACK,…) m_tree.SetItemData(hItem, 0); hItem = m_tree.InsertItem(LPSTR_TEXTCALLBACK,…)m_tree.SetItemData(hItem, 1 ); //处理消息 voidCParentWnd::OnGetDispInfoTree(NMHDR pNMHDR, LRESULT pResult) {TV_DISPINFO pTVDI = (TV_DISPINFO)pNMHDR;pTVDI-&gt;item.pszText=szOut[pTVDI-&gt;item.lParam];//通过lParam得到需要显示的字符在数组中的位置 *pResult = 0; } 关于编辑结点的显示字符：首先需要设置树形控件的TVS_EDITLABELS风格，在开始编辑时该控件将会发送TVN_BEGINLABELEDIT，你可以通过在处理函数中返回TRUE来取消接下来的编辑，在编辑完成后会发送TVN_ENDLABELEDIT，在处理该消息时需要将参数pNMHDR转换为LPNMTVDISPINFO，然后通过其中的item.pszText得到编辑后的字符，并重置显示字符。如果编辑在中途中取消该变量为NULL。下面的代码说明如何处理这些消息： //处理消息 TVN_BEGINLABELEDIT void CParentWnd::OnBeginEditTree(NMHDRpNMHDR, LRESULT pResult) { TV_DISPINFO pTVDI = (TV_DISPINFO)pNMHDR;if(pTVDI-&gt;item.lParam==0);//判断是否取消该操作 pResult = 1; else pResult = 0;} //处理消息 TVN_BEGINLABELEDIT void CParentWnd::OnBeginEditTree(NMHDRpNMHDR, LRESULT pResult) { TV_DISPINFO pTVDI = (TV_DISPINFO)pNMHDR;if(pTVDI-&gt;item.pszText==NULL);//判断是否已经取消取消编辑m_tree.SetItemText(pTVDI-&gt;item.hItem,pTVDI-&gt;pszText); //重置显示字符*pResult = 0; } 上面讲述的方法所进行的消息映射必须在父窗口中进行（同样WM_NOTIFY的所有消息都需要在父窗口中处理）。 List Ctrl 列表控件可以看作是功能增强的ListBox，它提供了四种风格，而且可以同时显示一列的多中属性值。MFC中使用CListCtrl类来封装列表控件的各种操作。通过调用BOOL Create( DWORD dwStyle, const RECT&amp; rect, CWnd* pParentWnd, UINTnID );创建一个窗口，dwStyle中可以使用以下一些列表控件的专用风格： · LVS_ICON LVS_SMALLICON LVS_LIST LVS_REPORT这四种风格决定控件的外观，同时只可以选择其中一种，分别对应：大图标显示，小图标显示，列表显示，详细报表显示 · LVS_EDITLABELS 结点的显示字符可以被编辑，对于报表风格来讲可编辑的只为第一列。 · LVS_SHOWSELALWAYS 在失去焦点时也显示当前选中的结点 · LVS_SINGLESEL 同时只能选中列表中一项 首先你需要设置列表控件所使用的ImageList，如果你使用大图标显示风格，你就需要以如下形式调用： CImageListSetImageList( CImageList pImageList, LVSIL_NORMAL);如果使用其它三种风格显示而不想显示图标你可以不进行任何设置，否则需要以如下形式调用： CImageList SetImageList(CImageList pImageList, LVSIL_SMALL); 通过调用 int InsertItem( int nItem, LPCTSTR lpszItem);可以在列表控件中nItem指明位置插入一项，lpszItem为显示字符。除LVS_REPORT风格外其他三种风格都只需要直接调用InsertItem就可以了，但如果使用报表风格就必须先设置列表控件中的列信息。 通过调用 int InsertColumn( int nCol, LPCTSTR lpszColumnHeading, intnFormat , int nWidth, intnSubItem);可以插入列。iCol为列的位置，从零开始，lpszColumnHeading为显示的列名，nFormat为显示对齐方式，nWidth为显示宽度，nSubItem为分配给该列的列索引。 在有多列的列表控件中就需要为每一项指明其在每一列中的显示字符，通过调用 BOOL SetItemText( int nItem, intnSubItem, LPTSTR lpszText);可以设置每列的显示字符。nItem为设置的项的位置，nSubItem为列位置，lpszText为显示字符。下面的代码演示了如何设置多列并插入数据： m_list.SetImageList(&amp;m_listSmall,LVSIL_SMALL);//设置ImageListm_list.InsertColumn(0,”Col 1”,LVCFMT_LEFT,300,0);//设置列m_list.InsertColumn(1,”Col 2”,LVCFMT_LEFT,300,1);m_list.InsertColumn(2,”Col 3”,LVCFMT_LEFT,300,2);m_list.InsertItem(0,”Item 1_1”);//插入行 m_list.SetItemText(0,1,”Item1_2”);//设置该行的不同列的显示字符 m_list.SetItemText(0,2,”Item 1_3”); 此外CListCtrl还提供了一些函数用于得到/修改控件的状态。 COLORREF GetTextColor( )/BOOLSetTextColor( COLORREF cr );用于得到/设置显示的字符颜色。 COLORREF GetTextBkColor()/BOOL SetTextBkColor( COLORREF cr );用于得到/设置显示的背景颜色。 voidSetItemCount( int iCount );用于得到添加进列表中项的数量。 BOOL DeleteItem(intnItem);用于删除某一项，BOOL DeleteAllItems( );将删除所有项。 BOOL SetBkImage(HBITMAPhbm, BOOL fTile , int xOffsetPercent, int yOffsetPercent);用于设置背景位图。CString GetItemText( int nItem, int nSubItem );用于得到某项的显示字符。 列表控件的消息映射同样使用ON_NOTIFY宏，形式如同：ON_NOTIFY( wNotifyCode, id, memberFxn)，wNotifyCode为通知代码，id为产生该消息的窗口ID，memberFxn为处理函数，函数的原型如同voidOnXXXList(NMHDR pNMHDR, LRESULTpResult)，其中pNMHDR为一数据结构，在具体使用时需要转换成其他类型的结构。对于列表控件可能取值和对应的数据结构为： · LVN_BEGINLABELEDIT 在开始某项编辑字符时发送，所用结构：NMLVDISPINFO · LVN_ENDLABELEDIT 在结束某项编辑字符时发送，所用结构：NMLVDISPINFO · LVN_GETDISPINFO 在需要得到某项信息时发送，（如得到某项的显示字符）所用结构：NMLVDISPINFO 关于ON_NOTIFY有很多内容，将在以后的内容中进行详细讲解。 关于动态提供结点所显示的字符：首先你在项时需要指明lpszItem参数为：LPSTR_TEXTCALLBACK。在控件显示该结点时会通过发送TVN_GETDISPINFO来取得所需要的字符，在处理该消息时先将参数pNMHDR转换为LPNMLVDISPINFO，然后填充其中item.pszText。通过item中的iItem,iSubItem可以知道当前显示的为那一项。下面的代码演示了这种方法： char szOut[8][3]={“No.1”,”No.2”,”No.3”}; //添加结点m_list.InsertItem(LPSTR_TEXTCALLBACK,…)m_list.InsertItem(LPSTR_TEXTCALLBACK,…) //处理消息 voidCParentWnd::OnGetDispInfoList(NMHDR pNMHDR, LRESULT pResult) {LV_DISPINFO pLVDI = (LV_DISPINFO)pNMHDR;pLVDI-&gt;item.pszText=szOut[pTVDI-&gt;item.iItem];//通过iItem得到需要显示的字符在数组中的位置 *pResult = 0; } 关于编辑某项的显示字符：（在报表风格中只对第一列有效）首先需要设置列表控件的LVS_EDITLABELS风格，在开始编辑时该控件将会发送LVN_BEGINLABELEDIT，你可以通过在处理函数中返回TRUE来取消接下来的编辑，在编辑完成后会发送LVN_ENDLABELEDIT，在处理该消息时需要将参数pNMHDR转换为LPNMLVDISPINFO，然后通过其中的item.pszText得到编辑后的字符，并重置显示字符。如果编辑在中途中取消该变量为NULL。下面的代码说明如何处理这些消息： //处理消息 LVN_BEGINLABELEDIT void CParentWnd::OnBeginEditList(NMHDRpNMHDR, LRESULT pResult) { LV_DISPINFO pLVDI = (LV_DISPINFO)pNMHDR;if(pLVDI-&gt;item.iItem==0);//判断是否取消该操作 pResult = 1; else pResult = 0;} //处理消息 LVN_BEGINLABELEDIT void CParentWnd::OnBeginEditList(NMHDRpNMHDR, LRESULT pResult) { LV_DISPINFO pLVDI = (LV_DISPINFO)pNMHDR;if(pLVDI-&gt;item.pszText==NULL);//判断是否已经取消取消编辑m_list.SetItemText(pLVDI-&gt;item.iItem,0,pLVDI-&gt;pszText); //重置显示字符*pResult = 0; } 上面讲述的方法所进行的消息映射必须在父窗口中进行（同样WM_NOTIFY的所有消息都需要在父窗口中处理）。 如何得到当前选中项位置：在列表控件中没有一个类似于ListBox中GetCurSel()的函数，但是可以通过调用GetNextItem(-1, LVNI_ALL | LVNI_SELECTED);得到选中项位置。 Tab Ctrl Tab属性页控件可以在一个窗口中添加不同的页面，然后在页选择发生改变时得到通知。MFC中使用CTabCtrl类来封装属性页控件的各种操作。通过调用BOOL Create( DWORD dwStyle, const RECT&amp; rect, CWnd* pParentWnd, UINTnID );创建一个窗口，dwStyle中可以使用以下一些属性页控件的专用风格： TCS_BUTTONS 使用按钮来表示页选择位置 TCS_MULTILINE 分行显示页选择位置 TCS_SINGLELINE只使用一行显示页选择位置 在控件创建后必需向其中添加页面才可以使用，添加页面的函数为： BOOL InsertItem( intnItem, LPCTSTR lpszItem);nItem为位置，从零开始，lpszItem为页选择位置上显示的文字。如果你希望在页选择位置处显示一个图标，你可以调用 BOOLInsertItem( int nItem, LPCTSTR lpszItem, int nImage);nImage指明所使用的图片位置。（在此之前必须调用CImageList SetImageList( CImageList pImageList );设置正确的ImageList） 此外CTabCtrl还提供了一些函数用于得到/修改控件的状态。 int GetCurSel( )/int SetCurSel( intnItem );用于得到/设置当前被选中的页位置。 BOOL DeleteItem( int nItem )/BOOLDeleteAllItems( );用于删除指定/所有页面。 void RemoveImage( int nImage);用于删除某页选择位置上的图标。 属性页控件的消息映射同样使用ON_NOTIFY宏，形式如同：ON_NOTIFY( wNotifyCode, id, memberFxn)，wNotifyCode为通知代码，id为产生该消息的窗口ID，memberFxn为处理函数，函数的原型如同voidOnXXXTab(NMHDR pNMHDR, LRESULTpResult)，其中pNMHDR为一数据结构，在具体使用时需要转换成其他类型的结构。对于列表控件可能取值和对应的数据结构为： TCN_SELCHANGE 在当前页改变后发送，所用结构：NMHDR TCN_SELCHANGING在当前页改变时发送可以通过返回TRUE来禁止页面的改变，所用结构：NMHDR 一般来讲在当前页发生改变时需要隐藏当前的一些子窗口，并显示其它的子窗口。下面的伪代码演示了如何使用属性页控件：CParentWnd::OnCreate(…){m_tab.Create(…);m_tab.InsertItem(0,”Option 1”);m_tab.InsertItem(1,”Option 2”);Create a edit box as the m_tab’s ChildCreate a static box as the m_tab’s Childedit_box.ShowWindow(SW_SHOW); // edit box在属性页的第一页static_box.ShowWindow(SW_HIDE); // static box在属性页的第二页}void CParentWnd::OnSelectChangeTab(NMHDR pNMHDR, LRESULT pResult){//处理页选择改变后的消息if(m_tab.GetCurSel()==0){//根据当前页显示/隐藏不同的子窗口edit_box.ShowWindow(SW_SHOW);static_box.ShowWindow(SW_HIDE);}else{//edit_box.ShowWindow(SW_HIDE);static_box.ShowWindow(SW_SHOW);}}]]></content>
      <categories>
        <category>MFC从入门到放弃</category>
      </categories>
      <tags>
        <tag>MFC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第5节 MFC对话框程序]]></title>
    <url>%2F2017%2F10%2F28%2F%E7%AC%AC5%E8%8A%82-MFC%E5%AF%B9%E8%AF%9D%E6%A1%86%E7%A8%8B%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[Windows编程基础–第5节 MFC对话框程序模式对话框 对话框程序是MFC最重要的组成部分，也是Visual C++中唯一可以可视化设计的窗口程序，对话框主要有两类： 模式对话框：必须关闭这个对话框才能继续操作父窗口或者上一级窗口 非模式对话框:不影响父窗口或者上一级窗口，可继续操作父窗口或者上一级窗口，对话框程序也可以一直保留，无需关闭才能执行下一步； 接来下我们先一起学习模式对话框； 1. 新建项目建立一个MFC的主对话框项目day04，参见上节，添加两个按钮，分别为“关于”，“聊天”，如图所示： 2. 添加关于对话框在资源视图（ResourceView）中Dialog上右击-&gt;Insert Diallog，插入对话框，如图所示： 3. 添加关于对话框类单击添加的关于对话框，执行View-&gt;Class Wizard，或者使用快捷键Ctrl + W打开类向导；由于新的对话框不存在关联类，此时会提示创建一个与它相关联的类，选择Create a new class,单击OK创建关联类，如下图所示：单击OK完成创建关联类； 3. 添加关于按钮消息事件切换回主对话框，单击主对话框，执行View-&gt;Class Wizard，或者使用快捷键Ctrl + W打开类向导；选择关于按钮，增加clicked方法，然后Edit Code编辑关于按钮的响应方法，或者可以直接双击“关于”按钮就可以直接进入按钮点击方法，在day04Dlg.h中添加“#include AboutDlg.h”来引入对话框类，然后我们来编辑关于按键方法，创建一个模式对话框； 123456void CDay04Dlg::OnButtonAbout() &#123; // TODO: Add your control notification handler code here CAboutDlg dlg; dlg.DoModal();&#125; 效果图：至此，一个模式对话框就创建成功了，我们可以看到，我们必须关闭关于对话框，才能单击主对话框。 非模式对话框现在我们来创建一个非模式对话框； 1. 添加聊天对话框在资源视图（ResourceView）中Dialog上右击-&gt;Insert Diallog，插入对话框，如图所示： 2. 添加聊天对话框类单击添加的关于对话框，执行View-&gt;Class Wizard，或者使用快捷键Ctrl + W打开类向导；由于新的对话框不存在关联类，此时会提示创建一个与它相关联的类，选择Create a new class,单击OK创建关联类，如上面步骤3 3. 添加聊天按钮消息事件切换回主对话框，单击主对话框，执行View-&gt;Class Wizard，或者使用快捷键Ctrl + W打开类向导；选择聊天按钮，增加clicked方法，然后Edit Code编辑关于按钮的响应方法，或者可以直接双击“聊天”按钮就可以直接进入按钮点击方法，在day04Dlg.h中添加“#include “Chat.h””来引入对话框类，然后我们来编辑聊天按键方法，创建一个非模式对话框； 1234567void CDay04Dlg::OnButtonChat() &#123; // TODO: Add your control notification handler code here CChat * pDlg = new CChat; pDlg-&gt;Create(IDD_DIALOG_CHAT); pDlg-&gt;ShowWindow(SW_SHOW);&#125; 效果图：至此，一个非模式对话框就创建成功了，我们可以看到，我们打开聊天界面后还可以继续操作父窗口中的关于对话框，甚至还可以单击聊天对话框创建多个聊天界面； 项目源码可以访问我的码云]]></content>
      <categories>
        <category>MFC从入门到放弃</category>
      </categories>
      <tags>
        <tag>MFC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第4节 MFC消息映射机制]]></title>
    <url>%2F2017%2F10%2F28%2F%E7%AC%AC4%E8%8A%82-MFC%E6%B6%88%E6%81%AF%E6%98%A0%E5%B0%84%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[Windows编程基础–第4节 MFC消息映射机制对于MFC程序最重要的响应机制就是消息映射机制，这节我们就来一起尝试一下MFC的消息映射机制。（操作系统：win10 64位 IDE：vc++ 6.0）1、新建一个MFC对话框项目，参见上节，2、编译代码运行，效果图如下：3、现在我们删除对话框上的《确定》和《取消》按钮，如图：4、现在我们添加自己的“OK”和“CANCEL”按钮，接下来我们就来看看“OK”按钮的按下消息是怎么进行处理的？4、执行View-&gt;Class Wizard,打开类向导；（或者直接用ctrl + W） 此时就能看到我们创建的对话框，OK按钮，CANCEL按钮对象，点击它们可以看见它们分别的拥有的消息，如图： 5、我们选择Cday03Dlg，MESSAGES选择WM_MOUSEMOVE消息，点击Add Function，下部Member function就会出现与WM_MOUSEMOVE对应的OnMouseMove函数，接下来点击Edit Code，编辑OnMouseMove函数的内容：6、我们来修改OnMouseMove(UINT nFlags, CPoint point) 函数，参数中point为鼠标的坐标位置，我们可以通过point.x, point.y来获取鼠标的位置，nFlags主要是标志一些控制键是否按下，然后MK_LBUTTON、MK_RBUTTON、MK_CONTROL、MK_SHIFT、MK_MBUTTON 分别对应鼠标左键，右键，CTRL ，SHIFT ，鼠标中间（转轮）：123456789101112131415161718192021222324252627282930void CDay03Dlg::OnMouseMove(UINT nFlags, CPoint point) &#123; // TODO: Add your message handler code here and/or call default CString strText; strText.Format(&quot;坐标 x = %d ,y = %d &quot;,point.x, point.y); if (nFlags &amp; MK_LBUTTON) &#123; strText += &quot; 鼠标左键DOWN&quot;; &#125; if (nFlags &amp; MK_RBUTTON) &#123; strText += &quot; 鼠标右键DOWN&quot;; &#125; if (nFlags &amp; MK_CONTROL) &#123; strText += &quot; CTRL DOWN&quot;; &#125; if (nFlags &amp; MK_SHIFT) &#123; strText += &quot; SHIFT DOWN&quot;; &#125; if (nFlags &amp; MK_MBUTTON) &#123; strText += &quot; MIDBUTTON DOWN&quot;; &#125; SetWindowText(strText); // 设置对话框标题文本 CDialog::OnMouseMove(nFlags, point);&#125; 效果图： 7、同样，我们可以通过类向导分别设置“OK”，“CANCEL”按钮的消息触发函数； 8、这是我们其实可以看到在day03Dlg.cpp中MESSAGE_MAP总下方就有我们新增的三个MFC消息，并且可以直观的看出是属于哪个控件ID的； 12345678910BEGIN_MESSAGE_MAP(CDay03Dlg, CDialog) //&#123;&#123;AFX_MSG_MAP(CDay03Dlg) ON_WM_SYSCOMMAND() ON_WM_PAINT() ON_WM_QUERYDRAGICON() ON_WM_MOUSEMOVE() ON_BN_CLICKED(IDC_BUTTON_OK, OnButtonOk) ON_BN_CLICKED(IDC_BUTTON_CACEL, OnButtonCacel) //&#125;&#125;AFX_MSG_MAPEND_MESSAGE_MAP() 9、接下来我们切换到day03Dlg.h头文件中，所有afx_msg 开头的都是消息对应的处理函数： 1234567891011// Generated message map functions//&#123;&#123;AFX_MSG(CDay03Dlg)afx_msg void OnSysCommand(UINT nID, LPARAM lParam);afx_msg void OnPaint();afx_msg HCURSOR OnQueryDragIcon();afx_msg void OnMouseMove(UINT nFlags, CPoint point);afx_msg void OnButtonOk();afx_msg void OnDoubleclickedButtonCacel();afx_msg void OnButtonCacel();//&#125;&#125;AFX_MSGDECLARE_MESSAGE_MAP() 10、由以上例子可以看出，MFC程序的消息映射机制是创建一个与窗口相关联的派生类，用于消息关联的成员函数来接收和处理窗口的消息。在类向导中选择对应的消息，添加与该消息关联的成员函数来处理该消息，这就是MFC的消息映射机制。具体控件或窗口支持哪些消息及消息对应的函数参数等，请参见MSDN；11、最终效果图： 项目源码可以访问我的码云来fork]]></content>
      <categories>
        <category>MFC从入门到放弃</category>
      </categories>
      <tags>
        <tag>MFC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第3节 初探MFC]]></title>
    <url>%2F2017%2F10%2F28%2F%E7%AC%AC3%E8%8A%82-%E5%88%9D%E6%8E%A2MFC%2F</url>
    <content type="text"><![CDATA[Windows编程基础–第3节 初探MFC 前言 win32程序属于早期windows软件，已经逐渐被淘汰，但它的设计模式和方法大部分都被MFC所继承，并且MFC开始使用C++语言进行开发，借助C++比C语言的强大特性，使得开发windws程序更加简便、高效，更加多元化。 创建第一个MFC程序（操作系统：win10 64位 IDE：vc++ 6.0）1) 执行File-&gt;new，选择Project选项卡，选择下面的MFC AppWizard，填写项目名称等，如图：2）点击 OK 按钮进入下一页，我们先选择简单的Dialog based，然后-&gt;NEXT ，第三页进行是否选择MFC静态库还是共享库等选择，这里我们不作修改，直接点击Finish，完成创建； 3）现在可以尝试编译，运行打开默认的Dialog界面4)现在我们往刚才创建的Dialog中添加一些资源控件，如下图：注意：ListCtrl属性中Stytle-&gt;View选择Report5）接下来我们来实现底部三个按钮的方法：添加按钮 12345678910111213 void CDay02Dlg::OnAdd() &#123; // TODO: Add your control notification handler code here CString szNumb,szName,szSala; GetDlgItemText(IDC_NUMB,szNumb); GetDlgItemText(IDC_NAME,szName); GetDlgItemText(IDC_SALA,szSala); CListCtrl *pList = (CListCtrl*)GetDlgItem(IDC_LIST); int nCount = pList-&gt;GetItemCount(); pList-&gt;InsertItem(nCount,szNumb); pList-&gt;SetItemText(nCount,1,szName); pList-&gt;SetItemText(nCount,2,szSala);&#125; 先通过GetDlgItemText方法获取顶部三个Edit输入的参数值，并分别赋值给szNumb,szName,szSala;接下来通过GetDlgItem取得ListCtrl的操作句柄，获取ListCtrl当前总数，在末尾添加一个Iten，并赋值； 删除按钮 123456789101112void CDay02Dlg::OnDel() &#123; // TODO: Add your control notification handler code here CListCtrl *pList = (CListCtrl*)GetDlgItem(IDC_LIST); int nSel = pList-&gt;GetSelectionMark(); if(nSel &lt; 0) &#123; AfxMessageBox(&quot;请先选择要删除的员工&quot;); return; &#125; pList-&gt;DeleteItem(nSel);&#125; 获取ListCtrl的操作句柄后获取到当前选的行数，最后删除改行； 修改按钮： 1234567891011121314151617181920void CDay02Dlg::OnMod() &#123; // TODO: Add your control notification handler code here CListCtrl *pList = (CListCtrl*)GetDlgItem(IDC_LIST); int nSel = pList-&gt;GetSelectionMark(); if(nSel &lt; 0) &#123; AfxMessageBox(&quot;请先选择要修改的员工&quot;); return; &#125; CString szNumb,szName,szSala; GetDlgItemText(IDC_NUMB,szNumb); GetDlgItemText(IDC_NAME,szName); GetDlgItemText(IDC_SALA,szSala); pList-&gt;SetItemText(nSel,0,szNumb); pList-&gt;SetItemText(nSel,1,szName); pList-&gt;SetItemText(nSel,2,szSala); &#125; 先通过GetDlgItemText方法获取顶部三个Edit输入的参数值，并分别赋值给szNumb,szName,szSala;接下来通过GetDlgItem取得ListCtrl的操作句柄，获取ListCtrl当前选择行数，将获取的szNumb,szName,szSala分别赋值给当前Item的对应位置； 函数原型如下：BOOL SetItemText( int nItem, int nSubItem, LPTSTR lpszText );用于MFC设置CListCtrl控件中的列表项内容。 int GetDlgItemText( int nID, CString&amp; rString) nID 指定了要获取其标题的控件的整数标识符。 lpStr 指向要接收控件的标题或文本的缓冲区。 nMaxCount 指定了要拷贝到lpStr的字符串的最大长度（以字节为单位）。如果字符串比nMaxCount要长，它将被截断。 rString 对一个CString对象的引用。 3.最终效果图 day02.cpp 源码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236 // day02Dlg.cpp : implementation file//#include &quot;stdafx.h&quot;#include &quot;day02.h&quot;#include &quot;day02Dlg.h&quot;#ifdef _DEBUG#define new DEBUG_NEW#undef THIS_FILEstatic char THIS_FILE[] = __FILE__;#endif/////////////////////////////////////////////////////////////////////////////// CAboutDlg dialog used for App Aboutclass CAboutDlg : public CDialog&#123;public: CAboutDlg();// Dialog Data //&#123;&#123;AFX_DATA(CAboutDlg) enum &#123; IDD = IDD_ABOUTBOX &#125;; //&#125;&#125;AFX_DATA // ClassWizard generated virtual function overrides //&#123;&#123;AFX_VIRTUAL(CAboutDlg) protected: virtual void DoDataExchange(CDataExchange* pDX); // DDX/DDV support //&#125;&#125;AFX_VIRTUAL// Implementationprotected: //&#123;&#123;AFX_MSG(CAboutDlg) //&#125;&#125;AFX_MSG DECLARE_MESSAGE_MAP()&#125;;CAboutDlg::CAboutDlg() : CDialog(CAboutDlg::IDD)&#123; //&#123;&#123;AFX_DATA_INIT(CAboutDlg) //&#125;&#125;AFX_DATA_INIT&#125;void CAboutDlg::DoDataExchange(CDataExchange* pDX)&#123; CDialog::DoDataExchange(pDX); //&#123;&#123;AFX_DATA_MAP(CAboutDlg) //&#125;&#125;AFX_DATA_MAP&#125;BEGIN_MESSAGE_MAP(CAboutDlg, CDialog) //&#123;&#123;AFX_MSG_MAP(CAboutDlg) // No message handlers //&#125;&#125;AFX_MSG_MAPEND_MESSAGE_MAP()/////////////////////////////////////////////////////////////////////////////// CDay02Dlg dialogCDay02Dlg::CDay02Dlg(CWnd* pParent /*=NULL*/) : CDialog(CDay02Dlg::IDD, pParent)&#123; //&#123;&#123;AFX_DATA_INIT(CDay02Dlg) // NOTE: the ClassWizard will add member initialization here //&#125;&#125;AFX_DATA_INIT // Note that LoadIcon does not require a subsequent DestroyIcon in Win32 m_hIcon = AfxGetApp()-&gt;LoadIcon(IDR_MAINFRAME);&#125;void CDay02Dlg::DoDataExchange(CDataExchange* pDX)&#123; CDialog::DoDataExchange(pDX); //&#123;&#123;AFX_DATA_MAP(CDay02Dlg) // NOTE: the ClassWizard will add DDX and DDV calls here //&#125;&#125;AFX_DATA_MAP&#125;BEGIN_MESSAGE_MAP(CDay02Dlg, CDialog) //&#123;&#123;AFX_MSG_MAP(CDay02Dlg) ON_WM_SYSCOMMAND() ON_WM_PAINT() ON_WM_QUERYDRAGICON() ON_BN_CLICKED(IDC_BUTTON4, OnButtonOK) ON_BN_CLICKED(IDC_ADD, OnAdd) ON_BN_CLICKED(IDC_DEL, OnDel) ON_BN_CLICKED(IDC_MOD, OnMod) //&#125;&#125;AFX_MSG_MAPEND_MESSAGE_MAP()/////////////////////////////////////////////////////////////////////////////// CDay02Dlg message handlersBOOL CDay02Dlg::OnInitDialog()&#123; CDialog::OnInitDialog(); CListCtrl *pList = (CListCtrl*)GetDlgItem(IDC_LIST); pList-&gt;InsertColumn(0,&quot;学号&quot;,0,100); pList-&gt;InsertColumn(1,&quot;姓名&quot;,0,100); pList-&gt;InsertColumn(2,&quot;工资&quot;,0,100); // Add &quot;About...&quot; menu item to system menu. // IDM_ABOUTBOX must be in the system command range. ASSERT((IDM_ABOUTBOX &amp; 0xFFF0) == IDM_ABOUTBOX); ASSERT(IDM_ABOUTBOX &lt; 0xF000); CMenu* pSysMenu = GetSystemMenu(FALSE); if (pSysMenu != NULL) &#123; CString strAboutMenu; strAboutMenu.LoadString(IDS_ABOUTBOX); if (!strAboutMenu.IsEmpty()) &#123; pSysMenu-&gt;AppendMenu(MF_SEPARATOR); pSysMenu-&gt;AppendMenu(MF_STRING, IDM_ABOUTBOX, strAboutMenu); &#125; &#125; // Set the icon for this dialog. The framework does this automatically // when the application&apos;s main window is not a dialog SetIcon(m_hIcon, TRUE); // Set big icon SetIcon(m_hIcon, FALSE); // Set small icon // TODO: Add extra initialization here return TRUE; // return TRUE unless you set the focus to a control&#125;void CDay02Dlg::OnSysCommand(UINT nID, LPARAM lParam)&#123; if ((nID &amp; 0xFFF0) == IDM_ABOUTBOX) &#123; CAboutDlg dlgAbout; dlgAbout.DoModal(); &#125; else &#123; CDialog::OnSysCommand(nID, lParam); &#125;&#125;// If you add a minimize button to your dialog, you will need the code below// to draw the icon. For MFC applications using the document/view model,// this is automatically done for you by the framework.void CDay02Dlg::OnPaint() &#123; if (IsIconic()) &#123; CPaintDC dc(this); // device context for painting SendMessage(WM_ICONERASEBKGND, (WPARAM) dc.GetSafeHdc(), 0); // Center icon in client rectangle int cxIcon = GetSystemMetrics(SM_CXICON); int cyIcon = GetSystemMetrics(SM_CYICON); CRect rect; GetClientRect(&amp;rect); int x = (rect.Width() - cxIcon + 1) / 2; int y = (rect.Height() - cyIcon + 1) / 2; // Draw the icon dc.DrawIcon(x, y, m_hIcon); &#125; else &#123; CDialog::OnPaint(); &#125;&#125;// The system calls this to obtain the cursor to display while the user drags// the minimized window.HCURSOR CDay02Dlg::OnQueryDragIcon()&#123; return (HCURSOR) m_hIcon;&#125;void CDay02Dlg::OnButtonOK() &#123; // TODO: Add your control notification handler code here &#125;void CDay02Dlg::OnAdd() &#123; // TODO: Add your control notification handler code here CString szNumb,szName,szSala; GetDlgItemText(IDC_NUMB,szNumb); GetDlgItemText(IDC_NAME,szName); GetDlgItemText(IDC_SALA,szSala); CListCtrl *pList = (CListCtrl*)GetDlgItem(IDC_LIST); int nCount = pList-&gt;GetItemCount(); pList-&gt;InsertItem(nCount,szNumb); pList-&gt;SetItemText(nCount,1,szName); pList-&gt;SetItemText(nCount,2,szSala);&#125;void CDay02Dlg::OnDel() &#123; // TODO: Add your control notification handler code here CListCtrl *pList = (CListCtrl*)GetDlgItem(IDC_LIST); int nSel = pList-&gt;GetSelectionMark(); if(nSel &lt; 0) &#123; AfxMessageBox(&quot;请先选择要删除的员工&quot;); return; &#125; pList-&gt;DeleteItem(nSel); &#125;void CDay02Dlg::OnMod() &#123; // TODO: Add your control notification handler code here CListCtrl *pList = (CListCtrl*)GetDlgItem(IDC_LIST); int nSel = pList-&gt;GetSelectionMark(); if(nSel &lt; 0) &#123; AfxMessageBox(&quot;请先选择要修改的员工&quot;); return; &#125; CString szNumb,szName,szSala; GetDlgItemText(IDC_NUMB,szNumb); GetDlgItemText(IDC_NAME,szName); GetDlgItemText(IDC_SALA,szSala); pList-&gt;SetItemText(nSel,0,szNumb); pList-&gt;SetItemText(nSel,1,szName); pList-&gt;SetItemText(nSel,2,szSala); &#125; 项目源码可以访问我的码云来fork： 1https://gitee.com/AmuUncle/MFC_CSDN.git]]></content>
      <categories>
        <category>MFC从入门到放弃</category>
      </categories>
      <tags>
        <tag>MFC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows编程基础--第2节 win32程序资源管理]]></title>
    <url>%2F2017%2F10%2F28%2FMFC02%2F</url>
    <content type="text"><![CDATA[Windows编程基础–第2节 win32程序资源管理（操作系统：win10 64位 IDE：vc++ 6.0）windows程序都有自己的资源，例如按钮，图标，对话框等等，这节介绍如何使用win32程序资源管理；1、继续使用上节的win32程序demo，执行File-&gt;new添加资源，选择Files选项卡中的Resource Script，填写资源名，如图所示：2、此时项目左侧会出现ResourceView视图，单击ResourceView中的根节点+号，会提示“This file is already open in an editor”，这时候关闭右边的day01.rc，再次打开就可以了；3、在ResourceView节点day01 Resources节点上右击-&gt;Insert,选中Dialog,单击“New”,创建一个对话框资源，创建成功之后如图：4、在新建的对话框上右击选择属性（Properties），会弹出dialog的属性窗口，可以设置一些对话框的相关属性，如图5、接下来我们做一个简单的BMI计算器(体重指数BMI=体重/身高的平方（国际单位kg/㎡）)，拖动三个Edit分别用来显示身高，体重，BMI值，并设置属性ID，分别为：IDC_EDIT_SG、IDC_EDIT_TZ,IDC_EDIT_BMI，如图所示：6、接下来切换到类视图（classView），双击WinMain入口函数，添加对话框语句： 1DialogBox(hInstance,(LPCTSTR)IDD_DIALOG_BMI,NULL,DlGFUNC); 其中IDD_DIALOG_BMI为刚才添加的对话框属性ID，DlGFUNC为对话框的消息处理函数，7、接下来我们添加DlGFUNC函数，如下： 1234567891011121314151617181920212223242526BOOL CALLBACK DlGFUNC(HWND hwnd_dlg,UINT uMsg,WPARAM wParam,LPARAM lParam)&#123; switch(uMsg) &#123; case WM_COMMAND: switch(wParam) &#123; case IDCANCEL: EndDialog(hwnd_dlg,IDCANCEL); break; case IDOK: &#123; int nHeight= GetDlgItemInt(hwnd_dlg,IDC_EDIT_SG,NULL,TRUE); double dHeight = nHeight / 100.00; int nWeight = GetDlgItemInt(hwnd_dlg,IDC_EDIT_TZ,NULL,TRUE); double bmi = nWeight/(dHeight*dHeight); char buf[28]; sprintf(buf, &quot;%.3f&quot;, bmi); SetDlgItemText(hwnd_dlg,IDC_EDIT_BMI,buf); &#125; break; &#125; break; &#125; return FALSE;&#125; 其中IDOK，和IDCANCEL为对话框确认按钮和取消按钮所触发消息，IDCANCEL关闭对话框，IDOK消息我们来获取身高和体重Edit中的值，并按照公式体重指数BMI=体重/身高的平方（国际单位kg/㎡）计算BMI,最后将BMI值设置到BMI Edit中： 1234567int nHeight= GetDlgItemInt(hwnd_dlg,IDC_EDIT_SG,NULL,TRUE);double dHeight = nHeight / 100.00;int nWeight = GetDlgItemInt(hwnd_dlg,IDC_EDIT_TZ,NULL,TRUE);double bmi = nWeight/(dHeight*dHeight);char buf[28];sprintf(buf, &quot;%.3f&quot;, bmi);SetDlgItemText(hwnd_dlg,IDC_EDIT_BMI,buf); 注意：要在文件头部引用资源头文件：#include “resource.h”最终效果如下：附day01.cpp源码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445// day01.cpp : Defines the entry point for the application.//#include &quot;stdafx.h&quot;#include &quot;resource.h&quot;#include &quot;stdio.h&quot;BOOL CALLBACK DlGFUNC(HWND hwnd_dlg,UINT uMsg,WPARAM wParam,LPARAM lParam)&#123; switch(uMsg) &#123; case WM_COMMAND: switch(wParam) &#123; case IDCANCEL: EndDialog(hwnd_dlg,IDCANCEL); break; case IDOK: &#123; int nHeight= GetDlgItemInt(hwnd_dlg,IDC_EDIT_SG,NULL,TRUE); double dHeight = nHeight / 100.00; int nWeight = GetDlgItemInt(hwnd_dlg,IDC_EDIT_TZ,NULL,TRUE); double bmi = nWeight/(dHeight*dHeight); char buf[28]; sprintf(buf, &quot;%.3f&quot;, bmi); SetDlgItemText(hwnd_dlg,IDC_EDIT_BMI,buf); &#125; break; &#125; break; &#125; return FALSE;&#125;int APIENTRY WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)&#123; // TODO: Place code here. DialogBox(hInstance,(LPCTSTR)IDD_DIALOG_BMI,NULL,DlGFUNC); return 0;&#125; 后记： DialogProc是一个窗口过程函数。该函数为一个应用程序定义可与DialogBox函数一起使用的回调函数。它处理发送到一个模态的或无模式对话框的消息。DLGPROC类型定义了一个指向此回调函数的指针。DialogProc函数是应用程序定义函数名的一个占位符。函数原型： 123456BOOL CALLBACK DialogProc(HWND hwndDlg,UINT UMsg,WPARAM wParam,LPARAM lParam); hwndDlg指定对话框。uMsg指定消息。wParam指定消息特定的其他信息。Iparam指定消息特定的其他信息。 项目源码可以访问我的码云来fork： 1https://gitee.com/AmuUncle/MFC_CSDN.git]]></content>
      <categories>
        <category>MFC从入门到放弃</category>
      </categories>
      <tags>
        <tag>MFC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows编程基础--第1节 第一个win32软件]]></title>
    <url>%2F2017%2F10%2F28%2FMFC01%2F</url>
    <content type="text"><![CDATA[Windows编程基础–第1节 第一个win32软件下面新建一个win32程序，来演示win32程序开发的原理（操作系统：win10 64位 IDE：vc++ 6.0） 1、执行File -&gt; new命令，来新建一个工程，如下图： 2、点击 OK按钮，然后选择A simple win32 application，单击Finish完成创建； 3、此时右边项目视图会显示我们刚才创建好的项目，双击Globals下面的WinMain函数 4、现在来新建一个简单的对话框 1MessageBox(NULL,&quot;Hello World!!&quot;,&quot;My First Win32 App&quot;,MB_OK); 5、单击状态栏上的 “build”，或者直接按键进行编译，然后单击状态栏的 ！ 来运行程序，或者ctrl+F5;以下是MessageBox的原型： 123456int WINAPI MessageBox( HWND hWnd, // handle of owner window LPCTSTR lpText, // address of text in message box LPCTSTR lpCaption, // address of title of message box UINT uType // style of message box); hWnd是消息框的拥有窗口。如果此参数为NULL，则消息框没有拥有窗口。lpText为消息框的内容。lpCaption为消息框的标题。uType指定一个决定对话框的内容和行为（按钮、图标、形态及其他）的位标志集。附其它常用属性 系统默认图标，可在消息框上显示X错误 MB_ICONHAND, MB_ICONSTOP, and MB_ICONERROR?询问 MB_ICONQUESTION!警告 MB_ICONEXCLAMATION and MB_ICONWARNINGi信息 MB_ICONASTERISK and MB_ICONINFORMATION 按钮的形式 MB_OK 默认MB_OKCANCEL 确定取消MB_YESNO 是否MB_YESNOCANCEL 是否取消 返回值 IDCANCEL 取消被选IDNO 否被选IDOK 确定被选IDYES 是被选6、对照函数说明，我们可以简单根据对话框返回值来执行不同的代码，如图： 12345678910111213141516171819#include &quot;stdafx.h&quot;int APIENTRY WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)&#123; // TODO: Place code here. int ret = MessageBox(NULL,&quot;Hello World!!&quot;,&quot;My First Win32 App&quot;,MB_OKCANCEL ); if(IDCANCEL == ret) &#123; MessageBox(NULL,&quot;CANCEL is clicked&quot;,&quot;My First Win32 App&quot;,MB_OK); &#125; else if(IDOK == ret) &#123; MessageBox(NULL,&quot;OK is clicked&quot;,&quot;My First Win32 App&quot;,MB_OK); &#125; return 0;&#125; 项目源码可以访问我的码云来fork： 1https://gitee.com/AmuUncle/MFC_CSDN.git]]></content>
      <categories>
        <category>MFC从入门到放弃</category>
      </categories>
      <tags>
        <tag>MFC</tag>
      </tags>
  </entry>
</search>
