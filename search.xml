<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[我是一只小小爬虫（Python编程）--第1节 什么是爬虫]]></title>
    <url>%2F2017%2F12%2F30%2F%E6%88%91%E6%98%AF%E4%B8%80%E5%8F%AA%E5%B0%8F%E5%B0%8F%E7%88%AC%E8%99%AB%EF%BC%88Python%E7%BC%96%E7%A8%8B%EF%BC%89-%E7%AC%AC1%E8%8A%82-%E4%BB%80%E4%B9%88%E6%98%AF%E7%88%AC%E8%99%AB%2F</url>
    <content type="text"><![CDATA[一、爬虫的基本概念爬虫：一只在网络上爬行的“蜘蛛”，这只蜘蛛用来在网络上爬取我们想获取的信息，所以爬虫的定义大概是： 请求网站并提取数据的自动化程序。 从定义中可以看出，我们首先要做的是向网站发送请求，模拟浏览器浏览网页的模式，从而获取数据，此时获取的数据其实是html代码文本以及图片等，接下来就是筛选我们需要的数据，梳理好我们需要的数据之后，就是要分类，按需存储我们的想要的数据，这就是一只爬虫的自我修养。 二、 网页的基本元素我们用随意打开一个网页，右击打开源代码，这就是网站的html文本，这就包含了该网页所有的信息，我们就需要在这些数据中筛选出我们需要的数据，如下： 三、爬虫的基本流程1、发起请求 通过HTTP库向目标站点发情请求，即发送一个Request，请求可以包含额外的header等，等待服务器响应； 2、获取响应内容 HTTP服务器会回应请求的结果，即页面内容，可能包含html文本，json，图片等； 3、解析内容 根据获取的内容不同进行响应解析； 4、保存内容将解析好的内容按需分类存储下来，比如图片视频，数据文本等； 四、Request &amp; Response Request Response 五、能够爬取的内容 1、网页文本: html，json文本等2、图片视频等二进制文件3、所有能请求到的数据按道理都能爬取到 六、解析方式 七、试着爬点什么？我们就把这个头像抓取下来吧。123456789101112import requestsresponse = requests.get(&quot;http://amuuncle.site/&quot;)print(response.text)print(response.headers)print(response.status_code)response = requests.get(&quot;http://amuuncle.site/images/touxiang.jpg&quot;)print(response.content)file_object = open(&apos;touxiang.jpg&apos;, &apos;wb&apos;)file_object.write(response.content)file_object.close() 上面代码，第一请求可以获取站点的应答信息，通过梳理我们可以筛选出我们要抓取的头像地址（该例子未做自动筛选数据，这些我们之后来学习，现在只是看看基本逻辑），第二个请求图片地址，并且将获取的图片二进制数据写入到路径中，最后头像就被保存在脚本的相同路径下了； 项目源码可以访问我的码云&gt;&gt;&gt;我的私人博客&lt;&lt;&lt;]]></content>
      <categories>
        <category>我是一只小小爬虫</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C/C++经典面试题（系列一）]]></title>
    <url>%2F2017%2F11%2F22%2FC-C-%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%88%E7%B3%BB%E5%88%97%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[1. 面向对象的程序设计思想是什么？ 答：把数据结构和对数据结构进行操作的方法封装形成一个个的对象。 2. 什么是类？ 答：把一些具有共性的对象归类后形成一个集合，也就是所谓的类。 3. 对象都具有的二方面特征是什么？分别是什么含义？ 答：对象都具有的特征是：静态特征和动态特征。静态特征是指能描述对象的一些属性，动态特征是指对象表现出来的行为。 4. 在头文件中进行类的声明，在对应的实现文件中进行类的定义有什么意义？ 答：这样可以提高编译效率，因为分开的话只需要编译一次生成对应的.obj文件后，再次应用该类的地方，这个类就不会被再次编译，从而大大提高了效率。 5. 在类的内部定义成员函数的函数体，这种函数会具备那种属性？ 答：这种函数会自动为内联函数，这种函数在函数调用的地方在编译阶段都会进行代码替换。 6. 成员函数通过什么来区分不同对象的成员数据？为什么它能够区分？ 答：通过this指针来区分的，因为它指向的是对象的首地址。 7. C++编译器自动为类产生的四个缺省函数是什么？ 答：默认构造函数，拷贝构造函数，析构函数，赋值函数。 8. 拷贝构造函数在哪几种情况下会被调用？ 1.当类的一个对象去初始化该类的另一个对象时；2.如果函数的形参是类的对象，调用函数进行形参和实参结合时；3.如果函数的返回值是类对象，函数调用完成返回时。 9. 构造函数与普通函数相比在形式上有什么不同？（构造函数的作用，它的声明形式来分析） 答：构造函数是类的一种特殊成员函数，一般情况下，它是专门用来初始化对象成员变量的。构造函数的名字必须与类名相同，它不具有任何类型，不返回任何值。 10. 什么时候必须重写拷贝构造函数？ 答：当构造函数涉及到动态存储分配空间时，要自己写拷贝构造函数，并且要深拷贝。 11. 构造函数的调用顺序是什么？ 答：1.先调用基类构造函数； 2.按声明顺序初始化数据成员； 3.最后调用自己的构造函数。 12. 哪几种情况必须用到初始化成员列表？ 答：类的成员是常量成员初始化； 类的成员是对象成员初始化，而该对象没有无参构造函数； 类的成员为引用时。 13. 什么是常对象？ 答：常对象是指在任何场合都不能对其成员的值进行修改的对象。 14. 静态函数存在的意义？ 答：静态私有成员在类外不能被访问，可通过类的静态成员函数来访问；当类的构造函数是私有的时，不像普通类那样实例化自己，只能通过静态成员函数来调用构造函数。 15. 在类外有什么办法可以访问类的非公有成员？ 答：友元，继承，公有成员函数。 16. 什么叫抽象类？ 答：不用来定义对象而只作为一种基本类型用作继承的类。 17. 运算符重载的意义？ 答：为了对用户自定义数据类型的数据的操作与内定义的数据类型的数据的操作形式一致。 18. 不允许重载的5个运算符是哪些？ 答：1. *（成员指针访问运算符号）； 2. ：：域运算符； 3. sizeof 长度运算符号； 4. ？：条件运算符号； 5..（成员访问符）。 19. 运算符重载的三种方式？ 答：普通函数，友元函数，类成员函数。 20. 流运算符为什么不能通过类的成员函数重载？一般怎么解决？ 答：因为通过类的成员函数重载必须是运算符的第一个是自己，而对流运算的重载要求第一个参数是流对象。一般通过友元来解决。 21. 赋值运算符和拷贝构造函数的区别与联系？ 答：相同点：都是将一个对象copy到另一个中去。 不同点：拷贝构造函数涉及到要新建立一个对象。 22. 在哪种情况下要调用该类的析构函数？ 答：对象生命周期结束时。 23. 对象间是怎样实现数据的共享的？ 答：通过类的静态成员变量来实现的。静态成员变量占有自己独立的空间不为某个对象所私有。 24. 友元关系有什么特性？ 答：单向的，非传递的，不能继承的。 25. 对对象成员进行初始化的次序是什么？ 答：它的次序完全不受它们在初始化表中次序的影响，只有成员对象在类中声明的次序来 决定的。 26. 类和对象之间的关系是什么？ 答：类是对象的抽象，对象是类的实例。 27. 对类的成员的访问属性有什么？ 答：public，protected，private。 28. const char p与char const p的区别？ 答：如果const位于星号的左侧，则const就是用来修饰指针所指向的变量，即指针指向为常量；如果const位于星号的右侧，const就是修饰指针本身，即指针本身是常量。 29. 是不是一个父类写了一个virtual 函数，如果子类覆盖它的函数不加virtual ,也能实现多态? virtual修饰符会被隐形继承的。 virtual可加可不加,子类覆盖它的函数不加virtual ,也能实现多态。 30. 函数重载是什么意思？它与虚函数的概念有什么区别？ 函数重载是一个同名函数完成不同的功能，编译系统在编译阶段通过函数参数个数、参数类型不同，函数的返回值来区分该调用哪一个函数，即实现的是静态的多态性。但是记住：不能仅仅通过函数返回值不同来实现函数重载。而虚函数实现的是在基类中通过使用关键字virtual来申明一个函数为虚函数，含义就是该函数的功能可能在将来的派生类中定义或者在基类的基础之上进行扩展，系统只能在运行阶段才能动态决定该调用哪一个函数，所以实现的是动态的多态性。 它体现的是一个纵向的概念，也即在基类和派生类间实现。 31. 构造函数和析构函数是否可以被重载,为什么? 答：构造函数可以被重载，析构函数不可以被重载。因为构造函数可以有多个且可以带参数，而析构函数只能有一个，且不能带参数。 32. 如何定义和实现一个类的成员函数为回调函数？ 答：所谓的回调函数，就是预先在系统的对函数进行注册，让系统知道这个函数的存在， 以后当某个事件发生时，再调用这个函数对事件进行响应。定义一个类的成员函数时在该函数前加CALLBACK即将其定义为回调函数，函数的实现和普通成员函数没有区别。 33. 虚函数是怎么实现的？ 答：简单说来使用了虚函数表。 34. 抽象类不会产生实例，所以不需要有构造函数。 答：错。 35. 从一个模板类可以派生新的模板类，也可以派生非模板类。 答：对。 36. main 函数执行以前，还会执行什么代码？ 答：全局对象的构造函数会在main 函数之前执行。 37. 当一个类A 中没有生成任何成员变量与成员函数,这时sizeof(A)的值是多少，如果不是零，请解释一下编译器为什么没有让它为零。（Autodesk） 答：肯定不是零。举个反例，如果是零的话，声明一个classA[10]对象数组，而每一个对象占用的空间是零，这时就没办法区分A[0],A[1]„了。 38. delete与 delete []区别： 答：delete只会调用一次析构函数，而delete[]会调用每一个成员的析构函数。 39. 子类析构时要调用父类的析构函数吗？ 答：会调用，析构函数调用的次序是先派生类的析构后基类的析构，也就是说在基类的的析构调用的时候,派生类的信息已经全部销毁了。 40. 继承优缺点。 优点：1、类继承是在编译时刻静态定义的，且可直接使用，2、类继承可以较方便地改变父类的实现。缺点：1、因为继承在编译时刻就定义了，所以无法在运行时刻改变从父类继承的实现2、父类通常至少定义了子类的部分行为，父类的任何改变都可能影响子类的行为3、如果继承下来的实现不适合解决新的问题，则父类必须重写或被其他更适合的类替换。这种依赖关系限制了灵活性并最终限制了复用性。 41. 解释堆和栈的区别。 答：栈区（stack）：由编译器自动分配释放，存放函数的参数值，局部变量的值等。堆:一般由程序员分配释放，若程序员不释放，程序结束时可能由OS回收。 42. 一个类的构造函数和析构函数什么时候被调用,是否需要手工调用? 答：构造函数在创建类对象的时候被自动调用，析构函数在类对象生命期结束时，由系统自动调用。43. 何时需要预编译：答：总是使用不经常改动的大型代码体。程序由多个模块组成，所有模块都使用一组标准的包含文件和相同的编译选项。在这种情况下，可以将所有包含文件预编译为一个预编译头。 44. 多态的作用？ 主要是两个： 隐藏实现细节，使得代码能够模块化；扩展代码模块，实现代码重用； 接口重用：为了类在继承和派生的时候，保证使用家族中任一类的实例的某一属性时的正确调用。 45. 虚拟函数与普通成员函数的区别？内联函数和构造函数能否为虚拟函数？ 答案：区别：虚拟函数有virtual关键字，有虚拟指针和虚函数表，虚拟指针就是虚拟函数的接口，而普通成员函数没有。内联函数和构造函数不能为虚拟函数。 46. 构造函数和析构函数的调用顺序? 析构函数为什么要虚拟? 答案：构造函数的调用顺序：基类构造函数—对象成员构造函数—派生类构造函数；析构函数的调用顺序与构造函数相反。析构函数虚拟是为了防止析构不彻底，造成内存的泄漏。 47. C++中类型为private的成员变量可以由哪些函数访问? 答：只可以由本类中的成员函数和友员函数访问。 48. 请说出类中private，protect，public三种访问限制类型的区别 答：private是私有类型，只有本类中的成员函数访问;protect是保护型的，本类和继承类可以访问;public是公有类型，任何类都可以访问。 49. 类中成员变量怎么进行初始化？ 答：可以通过构造函数的初始化列表或构造函数的函数体实现。 50. 在什么时候需要使用“常引用”？ 答：如果既要利用引用提高程序的效率，又要保护传递给函数的数据不在函数中被改变，就应使用常引用。 51.引用与指针有什么区别？ 答：1) 引用必须被初始化，指针不必。2) 引用初始化以后不能被改变，指针可以改变所指的对象。 3) 不存在指向空值的引用，但是存在指向空值的指针。 52. 描述实时系统的基本特性 答：在特定时间内完成特定的任务，实时性与可靠性。 54. 全局变量和局部变量在内存中是否有区别？如果有，是什么区别？ 答：全局变量储存在静态数据区，局部变量在堆栈中。 55. 堆栈溢出一般是由什么原因导致的？ 答：没有回收垃圾资源。 56. 什么函数不能声明为虚函数？ 答：构造函数（constructor）。 57.IP地址的编码分为哪俩部分？ 答：IP地址由两部分组成，网络号和主机号。 58.不能做switch()的参数类型是？ 答：switch的参数不能为实型。 59. 如何引用一个已经定义过的全局变量？ 答：可以用引用头文件的方式，也可以用extern关键字，如果用引用头文件方式来引用某个在头文件中声明的全局变量，假定你将那个变量写错了，那么在编译期间会报错，如果你用extern方式引用时，假定你犯了同样的错误，那么在编译期间不会报错，而在连接期间报错。 60. 对于一个频繁使用的短小函数,在C语言中应用什么实现,在C++中应用什么实现? 答：c用宏定义，c++用inline。 61. C++是不是类型安全的？ 答案：不是。两个不同类型的指针之间可以强制转换（用reinterpret cast)。 63. 简述数组与指针的区别？ 答：数组要么在静态存储区被创建（如全局数组），要么在栈上被创建。 指针可以随时指向任意类型的内存块。(1)修改内容上的区别char a[] = “hello”; a[0] = ‘X’; char *p = “world”; // 注意p 指向常量字符串 p[0] =‘X’; // 编译器不能发现该错误，运行时错误 (2) 用运算符sizeof 可以计算出数组的容量（字节数）。 sizeof(p), p为指针得到的是一个指针变量的字节数，而不是p 所指的内存容量。 64. C++函数中值的传递方式 答：有三种方式：值传递、指针传递、引用传递。 65. 内存的分配方式 答：分配方式有三种：1、静态存储区，是在程序编译时就已经分配好的，在整个运行期间都存在，如全局变量、常量。2、栈上分配，函数内的局部变量就是从这分配的，但分配的内存容易有限。3、堆上分配，也称动态分配，如我们用new,malloc分配内存，用delete,free来释放的内存。 66. extern“C”有什么作用？ 答：extern “C”是由Ｃ＋＋提供的一个连接交换指定符号，用于告诉Ｃ＋＋这段代码是Ｃ函数。这是因为C++编译后库中函数名会变得很长，与C生成的不一致，造成Ｃ＋＋不能直 接调用C函数，加上extren“c”后，C++就能直接调用C函数了。 67. 用什么函数开启新进程、线程。 答：线程：CreateThread/AfxBeginThread等； 进程：CreateProcess等。 68. SendMessage和PostMessage有什么区别 答：SendMessage是阻塞的，等消息被处理后，代码才能走到SendMessage的下一行。PostMessage是非阻塞的，不管消息是否已被处理，代码马上走到PostMessage的下一行。 69. CMemoryState主要功能是什么？ 答：查看内存使用情况，解决内存泄露问题。 70. #include&lt;filename.h&gt;和 #include “filename.h”有什么区别？ 答：对于#include &lt;filename.h&gt;，编译器从标准库路径开始搜索 filename.h 对于#include“filename.h”，编译器从用户的工作路径开始搜索 filename.h。 71. 处理器标识#error的目的是什么？ 答：编译时输出一条错误信息，并中止编译。 72. #if!defined(AFX_„_HADEH) #define(AFX„_HADE_H) „„ #endif作用？ 答：防止该头文件被重复引用。 73. 在定义一个宏的时候要注意什么？ 答：定义部分的每个形参和整个表达式都必须用括号括起来，以避免不可预料的错误发生。 74. 数组在做函数实参的时候会转变为什么类型？ 答：数组在做实参时会变成指针类型。 75. 系统会自动打开和关闭的3个标准的文件是？ (1) 标准输入—-键盘—stdin (2) 标准输出—-显示器—stdout (3)标准出错输出—-显示器—stderr 76. 在Win32下 char, int, float, double各占多少位？ (1) char 占用8位； (2) int 占用32位； (3) float 占用32位； (4) double 占用64位。 77. strcpy()和memcpy()的区别？ 答：strcpy()和memcpy()都可以用来拷贝字符串，strcpy()拷贝以‘\0’结束，但memcpy()必须指定拷贝的长度。 78. 说明define和const在语法和含义上有什么不同？ (1) #define是C语法中定义符号常量的方法，符号常量只是用来表达一个值，在编译阶段符号就被值替换了，它没有类型。 (2)const是C++语法中定义常变量的方法，常变量具有变量特性，它具有类型，内存中存在以它命名的存储单元，可以用sizeof测出长度。 79. 说出字符常量和字符串常量的区别，并使用运算符sizeof计算有什么不用？ 答：字符常量是指单个字符；而字符串常量以‘\0’结束，使用运算符sizeof计算多占一字节的存储空间。 80. 简述全局变量的优缺点？ 答：全局变量也称为外部变量，它是在函数外部定义的变量，它属于一个源程序文件，它保存上一次被修改后的值，便于数据共享，但不方便管理，易引起意想不到的错误。 81. 总结static的应用和作用？ （1）函数体内static变量的作用范围为该函数体，不同于auto变量，该变量的内存只被分配一次，因此其值在下次调用时仍维持上次的值；（2）在模块内的static全局变量可以被模块内所用函数访问，但不能被模块外其它函数访问；（3）在模块内的static函数只可被这一模块内的其它函数调用，这个函数的使用范围被限制在声明它的模块内；（4）在类中的static成员变量属于整个类所拥有，对类的所有对象只有一份拷贝；（5）在类中的static成员函数属于整个类所拥有，这个函数不接收this指针，因而只能访问类的static成员变量。 82. 总结const的应用和作用？ （1）欲阻止一个变量被改变，可以使用const关键字。在定义该const变量时，通常需要对它进行初始化，因为以后就没有机会再去改变它了；（2）对指针来说，可以指定指针本身为const，也可以指定指针所指的数据为const，或二者同时指定为const；（3）在一个函数声明中，const可以修饰形参，表明它是一个输入参数，在函数内部不能改变其值；（4）对于类的成员函数，若指定其为const类型，则表明其是一个常函数，不能修改类的成员变量；（5）对于类的成员函数，有时候必须指定其返回值为const类型，以使得其返回值不为“左值”。 83. 什么是指针？谈谈你对指针的理解？ 答：指针是一个变量，该变量专门存放内存地址；指针变量的类型取决于其指向的数据类型，在所指数据类型前加*；指针变量的特点是它可以访问所指向的内存。 84. 什么是常指针，什么是指向常变量的指针？ 答：常指针的含义是该指针所指向的地址不能变，但该地址所指向的内容可以变化，使用常指针可以保证我们的指针不能指向其它的变量。指向常变量的指针是指该指针的变量本身的地址可以变化，可以指向其它的变量，但是它所指的内容不可以被修改。 85. 函数指针和指针函数的区别？ 答：函数指针是指指向一个函数入口的指针；指针函数是指函数的返回值是一个指针类型。 87. 简述Debug版本和Release版本的区别？ 答：Debug版本是调试版本，Release版本是发布给用户的最终非调试的版本。 88. 指针的几种典型应用情况？ 答：int p[n];—–指针数组，每个元素均为指向整型数据的指针。int ()p[n];——p为指向一维数组的指针，这个一维数组有n个整型数据。int p();———-函数带回指针，指针指向返回的值。int ()p();——p为指向函数的指针。 89. static函数与普通函数有什么区别? 答：static函数在内存中只有一份，普通函数在每个被调用中维持一份拷贝。 90. struct(结构) 和 union(联合)的区别？ 答：1. 结构和联合都是由多个不同的数据类型成员组成, 但在任何同一时刻, 联合中只存放了一个被选中的成员（所有成员共用一块地址空间）, 而结构的所有成员都存在（不同成员的存放地址不同）。 对于联合的不同成员赋值, 将会对其它成员重写, 原来成员的值就不存在了, 而对于结构的不同成员赋值是互不影响的。 91. class 和 struct 的区别？ 答：struct 的成员默认是公有的，而类的成员默认是私有的。 92. 简述枚举类型？ 答：枚举方便一次定义一组常量，使用起来很方便。 93. assert()的作用？ 答：assert()是一个调试程序时经常使用的宏，在程序运行时它计算括号内的表达式，如果表达式为FALSE (0), 程序将报告错误，并终止执行。如果表达式不为0，则继续执行后面的语句。这个宏通常原来判断程序中是否出现了明显非法的数据，如果出现了终止程序以免导致严重后果，同时也便于查找错误。 94. 局部变量和全局变量是否可以同名？ 答：能。局部会屏蔽全局。要用全局变量，需要使用”::”(域运算符)。 95. 程序变量在内存中的分布？ 答：程序的局部变量存在于（堆栈）中，全局变量存在于（静态区）中，动态申请数据存在于（堆）中。 96. 在什么时候使用常引用？ 答：如果既要利用引用提高程序的效率，又要保护传递给函数的数据不在函数中被改变，就应使用常引用。 97. 类的声明和实现的分开的好处？ 起保护作用； 2. 提高编译的效率。 98. windows消息系统由哪几部分构成？ 答：由以下3部分组成： 消息队列：操作系统负责为进程维护一个消息队列，程序运行时不断从该消息队列中获取消息、处理消息； 消息循环：应用程序通过消息循环不断获取消息、处理消息。 消息处理：消息循环负责将消息派发到相关的窗口上使用关联的窗口过程函数进行处理。 99. 什么是消息映射？ 答：消息映射就是让程序员指定MFC类（有消息处理能力的类）处理某个消息。然后由程序员完成对该处理函数的编写，以实现消息处理功能。 100. 什么是UDP和TCP的区别是什么？ 答：TCP的全称为传输控制协议。这种协议可以提供面向连接的、可靠的、点到点的通信。UDP全称为用户报文协议，它可以提供非连接的不可靠的点到多点的通信。用TCP还是UDP，那要看你的程序注重哪一个方面？可靠还是快速？]]></content>
      <categories>
        <category>C/C++经典面试题</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[工具使用--第3节 HEXO美化之添加虾米音乐播放器]]></title>
    <url>%2F2017%2F11%2F08%2F%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8-%E7%AC%AC3%E8%8A%82-HEXO%E7%BE%8E%E5%8C%96%E4%B9%8B%E6%B7%BB%E5%8A%A0%E8%99%BE%E7%B1%B3%E9%9F%B3%E4%B9%90%E6%92%AD%E6%94%BE%E5%99%A8%2F</url>
    <content type="text"><![CDATA[先看看效果图： 1. 获取播放器链接我用浏览器打开虾米播播网址：[http://www.xiami.com/widget?widget_from=42036317]这里可以制作三款应用，分别是歌曲播放器列表，唱片墙，歌曲播放器（单曲）；这些都可以，这里只介绍第一种歌曲播放器列表。点击下方的立即制作，进入制作页面：自行添加音乐，然后下面就会出现播放器的代码：我们复制中间的HTML代码； 2. 添加到NEXT主题进入NEXT主题目录，如下图路径（\themes\next\layout_custom）：我们以记事本的方式打开该目录下的sidebar.swig文件，这就是NEXT主题的侧边栏文件，打开之后应该是空白文件，我们把上面复制的HTML代码粘贴到这里面就好了； 3. 生成部署在hexo的根目录下运行： hexo s -g 生成网站并运行网站，如图所示：接下来我们打开http://127.0.0.1:4000/就能看到我们添加的音乐播放器： 你也可以运行 hexo d -g 来将网站部署到github上，效果相同；具体效果可以打开我的个人博客来看看:http://amuuncle.site/ 项目源码可以访问我的码云&gt;&gt;&gt;我的私人博客&lt;&lt;&lt;]]></content>
      <categories>
        <category>GitHub</category>
      </categories>
      <tags>
        <tag>HEXO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第19节 MFC之自定义消息]]></title>
    <url>%2F2017%2F11%2F08%2F%E7%AC%AC19%E8%8A%82-MFC%E4%B9%8B%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B6%88%E6%81%AF%2F</url>
    <content type="text"><![CDATA[Windows编程基础–第19节 MFC之自定义消息windows程序中最重要的就是消息机制，前面几节我们都是使用Windows系统设定好的消息进行编程，今天我们来使用自定义的消息来看看MFC中消息的传递过程；MFC中自定义消息有两种方法： #define WM_MY_DEFINED_MSG (WM_USR+100) RegisterWindowMessage(WM_MY_REGISTER_MSG_SRR)下面我们来尝试一下这两种方法有什么不同； 1. 新建项目新建一个基于对话框项目“day21”，布局如下，自行处理： 2.第一种自定义消息2.1 定义消息ID我们来到day20Dlg.h 的头文件中，在上方创建一个宏定义如下： 1#define WM_MY_FRIST_MSG (WM_USER + 100) 这里我们定义了一个WM_MY_FRIST_MSG整型数值，它的值时WM_USER + 100，其中WM_USER 是微软定义好的宏，它的值是:#define WM_USER 0x0400 ，这说明在0x0400之前的消息(包含0x0400)都已经被windows系统使用，我们自定义消息只能在这之后，所以我们加上了100； 2.2 映射消息函数我们切换到day20Dlg.cpp中，找到下面这地方：12345BEGIN_MESSAGE_MAP(Cday21Dlg, CDialogEx) ON_WM_SYSCOMMAND() ON_WM_PAINT() ON_WM_QUERYDRAGICON()END_MESSAGE_MAP() 这就是消息的关系图，我们来添加一条映射，如下： 123456BEGIN_MESSAGE_MAP(Cday21Dlg, CDialogEx) ON_WM_SYSCOMMAND() ON_WM_PAINT() ON_WM_QUERYDRAGICON() ON_MESSAGE(WM_MY_FRIST_MSG, &amp;Cday21Dlg::OnMyFirstMsgTrigger)END_MESSAGE_MAP() ON_MESSAGE(WM_MY_FRIST_MSG, &amp;Cday21Dlg::OnMyFirstMsgTrigger)说明将WM_MY_FRIST_MSG消息ID与类Cday21Dlg的OnMyFirstMsgTrigger成员函数对应，当WM_MY_FRIST_MSG消息被触发时将调用OnMyFirstMsgTrigger方法； 2.3 实现消息函数我们先切换到Cday21Dlg类中，添加OnMyFirstMsgTrigger方法的声明： afx_msg LRESULT OnMyFirstMsgTrigger(WPARAM wParam, LPARAM lParam);这是消息映射函数的固定格式，参数类型也是固定的； 接下来我们实现OnMyFirstMsgTrigger的定义,如下： 1234567LRESULT Cday21Dlg::OnMyFirstMsgTrigger(WPARAM wParam, LPARAM lParam)&#123; TCHAR szBuf[128]; _stprintf(szBuf,_T(&quot;消息：%s 被触发，消息ID: 0x%x &quot;),_T(&quot;WM_MY_FRIST_MSG&quot;),WM_MY_FRIST_MSG); AfxMessageBox(szBuf); return 0;&#125; 代码解释： 只要执行这个函数就会弹窗显示消息名称和ID； 2.4 发送消息我们双击资源界面上的“自定义消息ID”按钮，编辑其点击事件处理函数： 123456void Cday21Dlg::OnBnClickedBtnDefined()&#123; // TODO: 在此添加控件通知处理程序代码 PostMessage(WM_MY_FRIST_MSG,0,0);&#125; 代码解释： 使用PostMessage发送WM_MY_FRIST_MSG消息； 2.5 运行结果 3.第二种自定义消息3.1 定义消息ID由于我们需要使用RegisterWindowMessage(LPCSTR lpString)来创造消息ID，所以我们需要先定义一个字符串： 1#define WM_MY_REGISTER_MSG_SRR _T(&quot;WM_MY_REGISTER_MSG_SRR&quot;) 接下来我们定义一个全局变量WM_MY_REGISTER_MSG来作为消息ID； 1UINT WM_MY_REGISTER_MSG; 接下来我们来初始化消息ID，我们到Cday21Dlg类的构造函数中来创建消息ID： 123456Cday21Dlg::Cday21Dlg(CWnd* pParent /*=NULL*/) : CDialogEx(Cday21Dlg::IDD, pParent)&#123; m_hIcon = AfxGetApp()-&gt;LoadIcon(IDR_MAINFRAME); WM_MY_REGISTER_MSG = RegisterWindowMessage(WM_MY_REGISTER_MSG_SRR);&#125; 这样我们就通过RegisterWindowMessage来创建了消息ID，但只有在程序运行时我们才会知道消息ID是多少，并且每次运行时都可能不同； 3.2 映射消息函数我们切换到day20Dlg.cpp中，我们再来添加一条映射，如下： 123456789BEGIN_MESSAGE_MAP(Cday21Dlg, CDialogEx) ON_WM_SYSCOMMAND() ON_WM_PAINT() ON_WM_QUERYDRAGICON() ON_BN_CLICKED(IDC_BTN_DEFINED, &amp;Cday21Dlg::OnBnClickedBtnDefined) ON_MESSAGE(WM_MY_FRIST_MSG, &amp;Cday21Dlg::OnMyFirstMsgTrigger) ON_REGISTERED_MESSAGE(WM_MY_REGISTER_MSG, &amp;Cday21Dlg::OnMyRegisterMsgTrigger) ON_BN_CLICKED(IDC_BTN_REG, &amp;Cday21Dlg::OnBnClickedBtnReg)END_MESSAGE_MAP() ON_REGISTERED_MESSAGE(WM_MY_REGISTER_MSG, &amp;Cday21Dlg::OnMyRegisterMsgTrigger)说明将WM_MY_REGISTER_MSG消息ID与类Cday21Dlg的OnMyRegisterMsgTrigger成员函数对应，当WM_MY_REGISTER_MSG消息被触发时将调用OnMyRegisterMsgTrigger方法；注意：RegisterWindowMessage方法获取的消息需要用ON_REGISTERED_MESSAGE映射消息 3.3 实现消息函数我们先切换到Cday21Dlg类中，添加OnMyRegisterMsgTrigger方法的声明： afx_msg LRESULT OnMyRegisterMsgTrigger(WPARAM wParam, LPARAM lParam);这是消息映射函数的固定格式，参数类型也是固定的； 接下来我们实现OnMyRegisterMsgTrigger的定义,如下： 1234567LRESULT Cday21Dlg::OnMyRegisterMsgTrigger(WPARAM wParam, LPARAM lParam)&#123; TCHAR szBuf[128]; _stprintf(szBuf,_T(&quot;消息：%s 被触发，消息ID: 0x%x &quot;),_T(&quot;WM_MY_REGISTER_MSG&quot;),WM_MY_REGISTER_MSG); AfxMessageBox(szBuf); return 0;&#125; 代码解释： 只要执行这个函数就会弹窗显示消息名称和ID； 2.4 发送消息我们双击资源界面上的“REGISTER消息ID”按钮，编辑其点击事件处理函数： 1234void Cday21Dlg::OnBnClickedBtnReg()&#123; PostMessage(WM_MY_REGISTER_MSG,0,0);&#125; 代码解释： 使用PostMessage发送WM_MY_REGISTER_MSG消息； 2.5 运行结果 4.对比两种方法从上面两种方法我们可以看出其优缺点： #define WM_MY_DEFINED_MSG (WM_USR+100)定义的消息ID唯一，但不确定消息ID是否被其它地方占用，可能造成隐患； RegisterWindowMessage(WM_MY_REGISTER_MSG_SRR)优点：定义的消息ID唯一，独立；缺点：在程序运行前不能确定消息ID，不方便在其它程序中指定触发此消息ID； 项目源码可以访问我的码云&gt;&gt;&gt;我的私人博客&lt;&lt;&lt;]]></content>
      <categories>
        <category>MFC从入门到放弃</category>
      </categories>
      <tags>
        <tag>MFC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第18节 MFC之窗体操作]]></title>
    <url>%2F2017%2F11%2F06%2F%E7%AC%AC18%E8%8A%82-MFC%E4%B9%8B%E7%AA%97%E4%BD%93%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[今天学习一下MFC窗体的基本操作： 最大化 最小化 还原 关闭窗口 设置窗口大小 设置窗口位置 居中显示窗口 顶层显示窗口 设置窗口图标 获取窗口标题 设置窗口标题 1. 最大化 SendMessage(WM_SYSCOMMAND,SC_MAXIMIZE,0) 2. 最小化 SendMessage(WM_SYSCOMMAND,SC_MINIMIZE,0) 3. 还原窗口 SendMessage(WM_SYSCOMMAND,SC_RESTORE,0) 4. 关闭窗口 SendMessage(WM_CLOSE,0,0) 5. 设置窗口大小及位置 MoveWindow(100,200,600,450);或SetWindowPos(NULL,500,100,700,500,SWP_NOZORDER); 6. 居中显示窗口 SendMessage(WM_CLOSE,0,0) 7.顶层显示窗口 设置顶层显示::SetWindowPos(m_hWnd,HWND_TOPMOST,0,0,0,0,SWP_NOMOVE|SWP_NOSIZE); 取消顶层显示::SetWindowPos(m_hWnd,HWND_NOTOPMOST,0,0,0,0,SWP_NOMOVE|SWP_NOSIZE); 8.设置窗口图标 HICON hIcon = AfxGetApp()-&gt;LoadIcon(IDI_ICON_LOL); SetIcon(hIcon, TRUE); // 设置大图标 SetIcon(hIcon, FALSE); // 设置小图标 9.获取窗口标题 GetWindowText(str); 10.设置窗口标题 SetWindowText(_T(“LOL”)); 附源码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264// day20Dlg.cpp : 实现文件//#include &quot;stdafx.h&quot;#include &quot;day20.h&quot;#include &quot;day20Dlg.h&quot;#include &quot;afxdialogex.h&quot;#ifdef _DEBUG#define new DEBUG_NEW#endif// 用于应用程序“关于”菜单项的 CAboutDlg 对话框class CAboutDlg : public CDialogEx&#123;public: CAboutDlg();// 对话框数据 enum &#123; IDD = IDD_ABOUTBOX &#125;; protected: virtual void DoDataExchange(CDataExchange* pDX); // DDX/DDV 支持// 实现protected: DECLARE_MESSAGE_MAP()&#125;;CAboutDlg::CAboutDlg() : CDialogEx(CAboutDlg::IDD)&#123;&#125;void CAboutDlg::DoDataExchange(CDataExchange* pDX)&#123; CDialogEx::DoDataExchange(pDX);&#125;BEGIN_MESSAGE_MAP(CAboutDlg, CDialogEx)END_MESSAGE_MAP()// Cday20Dlg 对话框Cday20Dlg::Cday20Dlg(CWnd* pParent /*=NULL*/) : CDialogEx(Cday20Dlg::IDD, pParent)&#123; m_hIcon = AfxGetApp()-&gt;LoadIcon(IDR_MAINFRAME);&#125;void Cday20Dlg::DoDataExchange(CDataExchange* pDX)&#123; CDialogEx::DoDataExchange(pDX);&#125;BEGIN_MESSAGE_MAP(Cday20Dlg, CDialogEx) ON_WM_SYSCOMMAND() ON_WM_PAINT() ON_WM_QUERYDRAGICON() ON_BN_CLICKED(IDC_BUTTON1, &amp;Cday20Dlg::OnBnClickedButton1) ON_BN_CLICKED(IDC_BUTTON2, &amp;Cday20Dlg::OnBnClickedButton2) ON_BN_CLICKED(IDC_BUTTON3, &amp;Cday20Dlg::OnBnClickedButton3) ON_BN_CLICKED(IDC_BUTTON4, &amp;Cday20Dlg::OnBnClickedButton4) ON_WM_CLOSE() ON_BN_CLICKED(IDC_BUTTON5, &amp;Cday20Dlg::OnBnClickedButton5) ON_BN_CLICKED(IDC_BUTTON6, &amp;Cday20Dlg::OnBnClickedButton6) ON_BN_CLICKED(IDC_BUTTON7, &amp;Cday20Dlg::OnBnClickedButton7) ON_BN_CLICKED(IDC_CHECK1, &amp;Cday20Dlg::OnBnClickedCheck1) ON_BN_CLICKED(IDC_BUTTON8, &amp;Cday20Dlg::OnBnClickedButton8) ON_BN_CLICKED(IDC_BUTTON9, &amp;Cday20Dlg::OnBnClickedButton9)END_MESSAGE_MAP()// Cday20Dlg 消息处理程序BOOL Cday20Dlg::OnInitDialog()&#123; CDialogEx::OnInitDialog(); // 将“关于...”菜单项添加到系统菜单中。 // IDM_ABOUTBOX 必须在系统命令范围内。 ASSERT((IDM_ABOUTBOX &amp; 0xFFF0) == IDM_ABOUTBOX); ASSERT(IDM_ABOUTBOX &lt; 0xF000); CMenu* pSysMenu = GetSystemMenu(FALSE); if (pSysMenu != NULL) &#123; BOOL bNameValid; CString strAboutMenu; bNameValid = strAboutMenu.LoadString(IDS_ABOUTBOX); ASSERT(bNameValid); if (!strAboutMenu.IsEmpty()) &#123; pSysMenu-&gt;AppendMenu(MF_SEPARATOR); pSysMenu-&gt;AppendMenu(MF_STRING, IDM_ABOUTBOX, strAboutMenu); &#125; &#125; // 设置此对话框的图标。当应用程序主窗口不是对话框时，框架将自动 // 执行此操作 SetIcon(m_hIcon, TRUE); // 设置大图标 SetIcon(m_hIcon, FALSE); // 设置小图标 HICON hIcon = AfxGetApp()-&gt;LoadIcon(IDI_ICON_LOL); SetIcon(hIcon, TRUE); // 设置大图标 SetIcon(hIcon, FALSE); // 设置小图标 SetWindowText(_T(&quot;LOL&quot;)); // TODO: 在此添加额外的初始化代码 return TRUE; // 除非将焦点设置到控件，否则返回 TRUE&#125;void Cday20Dlg::OnSysCommand(UINT nID, LPARAM lParam)&#123; if ((nID &amp; 0xFFF0) == IDM_ABOUTBOX) &#123; CAboutDlg dlgAbout; dlgAbout.DoModal(); &#125; else &#123; CDialogEx::OnSysCommand(nID, lParam); &#125;&#125;// 如果向对话框添加最小化按钮，则需要下面的代码// 来绘制该图标。对于使用文档/视图模型的 MFC 应用程序，// 这将由框架自动完成。void Cday20Dlg::OnPaint()&#123; if (IsIconic()) &#123; CPaintDC dc(this); // 用于绘制的设备上下文 SendMessage(WM_ICONERASEBKGND, reinterpret_cast&lt;WPARAM&gt;(dc.GetSafeHdc()), 0); // 使图标在工作区矩形中居中 int cxIcon = GetSystemMetrics(SM_CXICON); int cyIcon = GetSystemMetrics(SM_CYICON); CRect rect; GetClientRect(&amp;rect); int x = (rect.Width() - cxIcon + 1) / 2; int y = (rect.Height() - cyIcon + 1) / 2; // 绘制图标 dc.DrawIcon(x, y, m_hIcon); &#125; else &#123; CDialogEx::OnPaint(); &#125;&#125;//当用户拖动最小化窗口时系统调用此函数取得光标//显示。HCURSOR Cday20Dlg::OnQueryDragIcon()&#123; return static_cast&lt;HCURSOR&gt;(m_hIcon);&#125;void Cday20Dlg::OnBnClickedButton1()&#123; // TODO: 在此添加控件通知处理程序代码 SendMessage(WM_SYSCOMMAND,SC_MAXIMIZE,0);&#125;void Cday20Dlg::OnBnClickedButton2()&#123; // TODO: 在此添加控件通知处理程序代码 SendMessage(WM_SYSCOMMAND,SC_MINIMIZE,0);&#125;void Cday20Dlg::OnBnClickedButton3()&#123; // TODO: 在此添加控件通知处理程序代码 SendMessage(WM_SYSCOMMAND,SC_RESTORE,0);&#125;void Cday20Dlg::OnBnClickedButton4()&#123; // TODO: 在此添加控件通知处理程序代码 SendMessage(WM_CLOSE,0,0);&#125;void Cday20Dlg::OnClose()&#123; // TODO: 在此添加消息处理程序代码和/或调用默认值 if ( IDYES == MessageBox(_T(&quot;关闭窗口？&quot;),NULL,MB_YESNO)) &#123; CDialogEx::OnClose(); &#125; &#125;void Cday20Dlg::OnBnClickedButton5()&#123; // TODO: 在此添加控件通知处理程序代码 MoveWindow(100,200,600,450);&#125;void Cday20Dlg::OnBnClickedButton6()&#123; // TODO: 在此添加控件通知处理程序代码 SetWindowPos(NULL,500,100,700,500,SWP_NOZORDER);&#125;void Cday20Dlg::OnBnClickedButton7()&#123; // TODO: 在此添加控件通知处理程序代码 CenterWindow();&#125;void Cday20Dlg::OnBnClickedCheck1()&#123; // TODO: 在此添加控件通知处理程序代码 BOOL bTop = static_cast&lt;CButton*&gt;(GetDlgItem(IDC_CHECK1))-&gt;GetCheck(); if (bTop) &#123; ::SetWindowPos(m_hWnd,HWND_TOPMOST,0,0,0,0,SWP_NOMOVE|SWP_NOSIZE); &#125; else &#123; ::SetWindowPos(m_hWnd,HWND_NOTOPMOST,0,0,0,0,SWP_NOMOVE|SWP_NOSIZE); &#125;&#125;void Cday20Dlg::OnBnClickedButton8()&#123; // TODO: 在此添加控件通知处理程序代码 TCHAR tcText[20]; GetDlgItemText(IDC_EDIT_TEXT,tcText,20); SetWindowText(tcText);&#125;void Cday20Dlg::OnBnClickedButton9()&#123; // TODO: 在此添加控件通知处理程序代码 CString str; GetWindowText(str); AfxMessageBox(str);&#125; 项目源码可以访问我的码云&gt;&gt;&gt;我的私人博客&lt;&lt;&lt;]]></content>
      <categories>
        <category>MFC从入门到放弃</category>
      </categories>
      <tags>
        <tag>MFC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第17节 MFC之状态栏（CStatusBar）]]></title>
    <url>%2F2017%2F11%2F05%2F%E7%AC%AC17%E8%8A%82-MFC%E4%B9%8B%E7%8A%B6%E6%80%81%E6%A0%8F%EF%BC%88CStatusBar%EF%BC%89%2F</url>
    <content type="text"><![CDATA[Windows编程基础–第17节 MFC之状态栏（CStatusBar） 1、CStatusBar在MFC中类继承关系： CObject CCmdTarget CWnd CControlBar CStatusBar 2、CStatusBar成员函数介绍： 12345virtual BOOL Create( CWnd* pParentWnd, DWORD dwStyle = WS_CHILD | WS_VISIBLE | CBRS_BOTTOM, UINT nID = AFX_IDW_STATUS_BAR ); 函数用途：创建一个CStatusBar并将其与CStatusBar对象关联；参数说明：pParentWnd:指向CStatusBar的父窗口（Windows窗口）； dwStyle：CStatusBar的类型，CBRS_TOP:将Bar放在框架的顶部，CBRS_BOTTOM:将其放在框架的底部。CBRS_NOALIGN:当父窗口改变时，不重型调整Bar；nID：toolbar的子窗口ID； 返回值：成功返回非零，否则返回零； 1234BOOL SetIndicators( const UINT* lpIDArray, int nIDCount ); 函数用途：加载lpIDArray中的ID所对应的字符串资源，并将ID所对应的文本保存在字符串资源中；参数说明：lpIDArray：ID队列指针 nIDCount：队列中元素的个数； 返回值：成功返回非零，否则返回零； 12345BOOL SetPaneText( int nIndex, LPCTSTR lpszNewText, BOOL bUpdate = TRUE ); 函数用途：将CStatustBar中的长方块设置成lpszNewText所指向的内容；参数说明：nIndex：长方块的索引号（从零开始计，第零个固定用来状态指示）lpszNewText：需要加载的内容；（需要在第nIndex个长方块上显示的字符串）bUpdate：等于TRUE时，当加载了新的字符内容后，将长方块设置为无效。无效使得窗口自动刷行，那么新内容就被显示在界面上了。 1234void GetItemRect( int nIndex, LPRECT lpRect ) const; 函数用途：将nIndex所在的位置的矩形坐标拷贝到lpRect中。 参数说明：nIndex：长方块的标识；lpRect：指向Rect结构的指针，用来保存获得到的矩形坐标； 返回值：无 注意：坐标是以象素为单位的，原点在左上角。 123456void GetPaneInfo( int nIndex, UINT&amp; nID, UINT&amp; nStyle, int&amp; cxWidth ) const； 函数用途：获得Pane的相关信息：ID，Style，宽度。参数说明：nIndex：需要获得的Pane的索引nID：nIndex所对应Pane的IDnStyle：nIndex对应的Pane的类型；cxWidth：nIndex对应的Pane的宽度； 返回值：无 123456void SetPaneInfo( int nIndex, UINT nID, UINT nStyle, int cxWidth ); 函数说明：设置Pane的相关信息； 参数说明：nIndex：需要设置的Pane的索引； 其余和5相同； 返回值：无 1234void SetPaneStyle( int nIndex, UINT nStyle ); 函数说明：设置Pane的类型 参数说明：nIndex：需要设置的Pane的索引 nStyle：类型； 返回值：无nStyle的值可以为： CBRS_TOP Control bar is at top of frame window.CBRS_BOTTOM Control bar is at bottom of frame window.CBRS_NOALIGN Control bar is not repositioned when the parent is resized. 123 UINT GetPaneStyle( int nIndex ) const； 1234567891011121314151617函数说明：获得Pane的类型参数说明：nIndex：需要获得的Pane的索引返回值：无 举例：生成一个MFC应用程序，参照如下说明修改代码： static UINT indicators[] =&#123; ID_SEPARATOR, // 状态行指示器 ID_INDICATOR_CLOCK, ID_INDICATOR_CAPS, ID_INDICATOR_NUM, ID_INDICATOR_SCRL,&#125;;说明：indicator数组提供了状态栏窗格的分配信息，它的第一项一般为ID_SEPARATOR，该ID对应的窗格用来显示命令提示信息，后三项都是字符串ID，读者可以在String Table字符串资源中找到这三个字符串分别是CAP、NUM和SCRL。它们对应的三个窗格用来显示键盘的状态。 1. 新建项目新建一个基于对话框项目“day19”，布局如下，自行处理： 2.添加状态栏切换到解决方案视图，进入day19Dlg.h头文件，添加一个CStatusBar成员变量（CStatusBar m_statusBar;），如下图： 现在进入BOOL Cday19Dlg::OnInitDialog()初始化函数中创建状态栏,在return前添加如下代码： 12345678m_statusBar.Create(this);UINT nID[] = &#123;10000,10001&#125;;m_statusBar.SetIndicators(nID,2);m_statusBar.SetPaneInfo(0,10000,SBPS_NORMAL,100);m_statusBar.SetPaneInfo(1,10001,SBPS_STRETCH,0);RECT rect=&#123;0&#125;;GetClientRect(&amp;rect);m_statusBar.MoveWindow(0,rect.bottom - 30,rect.right,30,TRUE); 代码解释： 1.创建一个状态栏到当前窗体；2.创建两个状态栏Pane的ID；3.在状态栏上添加两个Pane，分别为正常模式，长度为100，另一个自动填充模式；4.获取窗口客户区的坐标。客户区坐标指定客户区的左上角和右下角。由于客户区坐标是相对窗口客户区的左上角而言的，因此左上角坐标为（0，0）。这里应该注意一下：坐标包含两种：屏幕坐标与客户区坐标。严格区分这两种坐标对于理解Windows编程是很重要的。5.将状态栏设置到窗口的距离底部30，长度为窗口长度，高度为30的位置； 运行结果：可以看到下方已经有了状态栏； 3.实现状态栏方法编辑EDIT控件的属性：| 属性名 | 值|| ——– | —–: || Multiline| true|| Horizontal Scroll |true|| Vertical Scroll |true|| Want Return |true|添加EDIT控件的变量，如图所示： 添加EDIT控件的OnEnChange消息处理方法：编辑EDIT控件的OnEnChange消息处理方法： 1234567891011121314void Cday19Dlg::OnEnChangeEdit1()&#123; // TODO: 如果该控件是 RICHEDIT 控件，它将不 // 发送此通知，除非重写 CDialogEx::OnInitDialog() // 函数并调用 CRichEditCtrl().SetEventMask()， // 同时将 ENM_CHANGE 标志“或”运算到掩码中。 // TODO: 在此添加控件通知处理程序代码 int nLen = m_edit.GetWindowTextLength(); int linecount=m_edit.GetLineCount(); CString strText; strText.Format(_T(&quot;字数: %d 行数: %d&quot;),nLen,linecount); m_statusBar.SetPaneText(1,strText,TRUE);&#125; 代码解释： 1.获取文本框中的文本长度；2.获取文本框中的文本行数；3.格式化文本后设置到状态栏第二个Pane中； 最终效果图： 项目源码可以访问我的码云&gt;&gt;&gt;我的私人博客&lt;&lt;&lt;]]></content>
      <categories>
        <category>MFC从入门到放弃</category>
      </categories>
      <tags>
        <tag>MFC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第16节 MFC之SendMessage和PostMessage]]></title>
    <url>%2F2017%2F11%2F04%2F%E7%AC%AC16%E8%8A%82-MFC%E4%B9%8BSendMessage%E5%92%8CPostMessage%2F</url>
    <content type="text"><![CDATA[1、PostMessage会将消息压入窗口所在线程的消息队列，然后返回；而SendMessage则不经过消息队列，SendMessage可认为是直接调用了该窗口的窗口过程，因此在我们需要获得消息处理后的返回值的时候，就要用到SendMessage。 例如：当在程序中指定如下使用：PostMessage（hWnd, WM_MSG,0,0），那么当程序执行到PostMessage的时候，仅将消息WM_MSG压入到创建hWnd所指窗口的那个线程的消息队列，然后程序将继续执行下去，而至于程序什么时候响应该消息，则要看那个线程什么时候得到控制权； 而指定如下使用：SendMessage（hWnd, WM_MSG,0,0），那么当程序执行到该处时，将发生一次跳转：从当前位置，跳转到hWnd的窗口过程中去响应WM_MSG消息，当消息处理结束，窗口过程返回，程序又将从SendMessage后面继续执行，当然，我们可以获得窗口过程对该消息的处理结果，也即取SendMessage的返回值。（这里只是针对单线程）。 2、在多线程应用中，PostMessage的用法还是一样，但SendMessage则不同了。如果在线程A中向线程B所创建的一个窗口hWndB发送消息SendMessage（hWndB，WM_MSG，0，0），那么系统将会立即将执行权从线程A切换到线程B，然后在线程B中调用hWndB的窗口过程来处理消息，并且在处理完该消息后，执行权仍然在B手中！这个时候，线程A则暂停在SendMessage处，等待下次线程A获得执行权后才继续执行，并且仍然可以获得消息处理的结果（返回值）。一般，为了避免死锁，在B中对WM_MSG做出处理之前，要加上：if(InSendMessage()) RelpyMessage(lResult)； 即判断：如果该消息是发自另外一个线程，则立即 RelpyMessage，回复消息，参数lResult即是返回值。而如果是在同一个线程内，则InSendMessage()将会返回FALSE。 —百度知道 总而言之，按我的理解，SendMessage和PostMessage都是向窗体发送消息的函数，但是PostMessage发送完消息立刻返回，不会等待消息结果，但SendMessage会等到消息返回结果再执行下一步； 今天我们通过各例子来试试这两种发送消息的方法； 创建一个界面图标，通过拖动图标到任意的windows窗口上，获取到窗口的句柄，标题，类名；并通过SendMessage或PostMessage发送消息到该窗口，修改窗口标题或关闭窗口； 1. 新建项目新建一个基于对话框项目“day18”，布局如下，自行处理： 2. 新建类Cday18Dlg成员变量1234HCURSOR m_hCursor; //定义一个鼠标的指针RECT m_rtCtrl; //图标的大小BOOL m_bCapturing; //鼠标捕获HWND m_hWndDest; //目标窗口的窗口句柄 3.加载鼠标指针及获取图标大小编辑Cday18Dlg::OnInitDialog()初始化函数，在return之前添加如下两行 12m_hCursor = LoadCursor(NULL, IDC_SIZEALL);GetDlgItem(IDC_PIC)-&gt;GetWindowRect(&amp;m_rtCtrl); 4.创建鼠标右键点击及释放消息如图，添加OnLButtonDown及OnLButtonUp消息处理函数：编辑OnLButtonDown及OnLButtonUp消息处理函数： 1234567891011121314void Cday18Dlg::OnLButtonDown(UINT nFlags, CPoint point)&#123; // TODO: 在此添加消息处理程序代码和/或调用默认值 if (point.x &gt;= m_rtCtrl.left &amp;&amp; point.x &lt;= m_rtCtrl.right || point.y &gt;= m_rtCtrl.top &amp;&amp; point.y &lt;= m_rtCtrl.bottom) &#123; m_bCapturing = TRUE; SetCapture(); // 开始捕获鼠标 SetCursor(m_hCursor); &#125; CDialogEx::OnLButtonDown(nFlags, point);&#125; 代码解释： 1.判断鼠标点击的位置是否在图标上；2.若是，则将开始捕获鼠标标志置位真，并且开始捕获鼠标位置；3.将捕获的鼠标位置设置到成员变量m_hCursor； 12345678910111213141516171819202122void Cday18Dlg::OnLButtonUp(UINT nFlags, CPoint point)&#123; // TODO: 在此添加消息处理程序代码和/或调用默认值 if (m_bCapturing) &#123; ReleaseCapture(); m_bCapturing = FALSE; POINT pt = point; ClientToScreen(&amp;pt); m_hWndDest = ::WindowFromPoint(pt); TCHAR szBuf[MAX_PATH] = &#123;0&#125;; _stprintf(szBuf,_T(&quot;0x%.8X&quot;),m_hWndDest); SetDlgItemText(IDC_EDIT_DESTHWND,szBuf); GetClassName(m_hWndDest,szBuf,MAX_PATH); SetDlgItemText(IDC_EDIT_DESTCLASS,szBuf); ::SendMessage(m_hWndDest,WM_GETTEXT,MAX_PATH,(LPARAM)szBuf); SetDlgItemText(IDC_EDIT_DESTTEXT,szBuf); &#125; CDialogEx::OnLButtonUp(nFlags, point);&#125; 代码解释： 1.判断是否在捕获鼠标；2.若是，释放鼠标捕获，获取当前鼠标的位置；3.通过当前鼠标的位置获取到当前位置的窗口句柄；4.分别获取该窗口的句柄，类名，标题； 效果图： 5.实现修改目标窗口标题双击“修改标题”按钮，编辑其clicked方法： 1234567void Cday18Dlg::OnBnClickedBtnSettext()&#123; // TODO: 在此添加控件通知处理程序代码 CString strText; GetDlgItemText(IDC_EDIT_DESTTEXT,strText); ::SendMessage(m_hWndDest,WM_SETTEXT,0,(LPARAM)(LPCTSTR)strText);&#125; 代码解释： 1.获取文本框中的标题值；2.通过SendMessage方法发送WM_SETTEXT消息修改目标窗口的标题 效果图： 6.实现关闭目标窗口双击“关闭标题”按钮，编辑其clicked方法： 123456void Cday18Dlg::OnBnClickedBtnSettext2()&#123; // TODO: 在此添加控件通知处理程序代码 ::SendMessage(m_hWndDest,WM_CLOSE,0,0); //::PostMessage(m_hWndDest,WM_CLOSE,0,0);&#125; 代码解释： 1.通过SendMessage方法发送WM_CLOSE消息来关闭目标窗口； 上面我们都是使用SendMessage方法来发送消息，其实我们也可以把SendMessage全部替换成PostMessage，我们来看看效果：我们可以看“窗口标题”获取的值是不对的，这是为什么？我们来看一下获取标题的这段代码： 123456789101112ReleaseCapture();m_bCapturing = FALSE;POINT pt = point;ClientToScreen(&amp;pt);m_hWndDest = ::WindowFromPoint(pt);TCHAR szBuf[MAX_PATH] = &#123;0&#125;;_stprintf(szBuf,_T(&quot;0x%.8X&quot;),m_hWndDest);SetDlgItemText(IDC_EDIT_DESTHWND,szBuf);GetClassName(m_hWndDest,szBuf,MAX_PATH);SetDlgItemText(IDC_EDIT_DESTCLASS,szBuf);::PostMessage(m_hWndDest,WM_GETTEXT,MAX_PATH,(LPARAM)szBuf);SetDlgItemText(IDC_EDIT_DESTTEXT,szBuf); 我们看到前面获取窗口句柄，类名都是没问题的，但是到了最后获取标题时出了问题；那是因为PostMessage是不会等待消息的返回结果，发送之后直接往下运行，这时szBuf的值还是前面获取的“窗口类名”，所以导致最后的“窗口标题”内容获取出错，这也很好的证明PostMessage和SendMessage的区别；还有“修改标题”及“关闭窗口”按钮不管是PostMessage和SendMessage方法都不会出错，那是因为我们在这两个按钮方法中都不需要消息的返回值，所以在我们以后的实际使用中一定要考虑清楚需要使用哪种发送消息方法； 动态效果图：附MFC消息分类及说明： 窗口消息 WM_CREATE 创建一个窗口 WM_DESTROY 当一个窗口被破坏时发送 WM_MOVE移动一个窗口 WM_SIZE 改变一个窗口的大小 WM_ACTIVATE一个窗口被激活或失去激活状态 WM_SETFOCUS 一个窗口获得焦点 WM_KILLFOCUS一个窗口失去焦点 WM_ENABLE 一个窗口改变成Enable状态 WM_SETREDRAW设置窗口是否能重画 WM_SETTEXT 应用程序发送此消息来设置一个窗口的文本 WM_GETTEXT应用程序发送此消息来复制对应窗口的文本到缓冲区 WM_GETTEXTLENGTH 得到与一个窗口有关的文本的长度（不包含空字符）WM_PAINT 要求一个窗口重画自己 WM_CLOSE当一个窗口或应用程序要关闭时发送一个信号 WM_QUERYENDSESSION当用户选择结束对话框或程序自己调用ExitWindows函数 WM_QUIT 用来结束程序运行WM_QUERYOPEN 当用户窗口恢复以前的大小位置时，把此消息发送给某个图标 WM_ERASEBKGND当窗口背景必须被擦除时（例在窗口改变大小时） WM_SYSCOLORCHANGE 当系统颜色改变时，发送此消息给所有顶级窗口WM_ENDSESSION 当系统进程发出WM_QUERYENDSESSION消息后，此消息发送给应用程序，通知它对话是否结束WM_SHOWWINDOW 当隐藏或显示窗口是发送此消息给这个窗口 WM_ACTIVATEAPP发此消息给应用程序哪个窗口是激活的，哪个是非激活的 WM_FONTCHANGE 当系统的字体资源库变化时发送此消息给所有顶级窗口WM_TIMECHANGE 当系统的时间变化时发送此消息给所有顶级窗口 WM_CANCELMODE发送此消息来取消某种正在进行的摸态（操作） WM_SETCURSOR如果鼠标引起光标在某个窗口中移动且鼠标输入没有被捕获时，就发消息给某个窗口 WM_MOUSEACTIVATE当光标在某个非激活的窗口中而用户正按着鼠标的某个键发送此消息给当前窗口 WM_CHILDACTIVATE发送此消息给MDI子窗口当用户点击此窗口的标题栏，或当窗口被激活，移动，改变大小 WM_QUEUESYNC此消息由基于计算机的训练程序发送，通过 WH_JOURNALPALYBACK 的 hook 程序分离出用户输入消息WM_GETMINMAXINFO 此消息发送给窗口当它将要改变大小或位置 WM_PAINTICON发送给最小化窗口当它图标将要被重画 WM_ICONERASEBKGND 此消息发送给某个最小化窗口，仅当它在画图标前它的背景必须被重画WM_NEXTDLGCTL 发送此消息给一个对话框程序去更改焦点位置 WM_SPOOLERSTATUS每当打印管理列队增加或减少一条作业时发出此消息 WM_DRAWITEM当button，combobox，listbox，menu的可视外观改变时发送 WM_MEASUREITEM 当button,combo box, list box, list view control, or menu item 被创建时WM_VKEYTOITEM此消息有一个LBS_WANTKEYBOARDINPUT风格的发出给它的所有者来响应WM_KEYDOWN消息 WM_CHARTOITEM此消息由一个LBS_WANTKEYBOARDINPUT风格的列表框发送给他的所有者来响应WM_CHAR消息 WM_SETFONT当绘制文本时程序发送此消息得到控件要用的颜色 WM_GETFONT 应用程序发送此消息得到当前控件绘制文本的字体WM_SETHOTKEY 应用程序发送此消息让一个窗口与一个热键相关连 WM_GETHOTKEY应用程序发送此消息来判断热键与某个窗口是否有关联 WM_QUERYDRAGICON此消息发送给最小化窗口，当此窗口将要被拖放而它的类中没有定义图标，应用程序能返回一个图标或光标的句柄，当用户拖放图标时系统显示这个图标或光标WM_COMPAREITEM 发送此消息来判定 combobox 或 listbox 新增加的项的相对位置WM_COMPACTING 显示内存已经很少了 WM_WINDOWPOSCHANGING发送此消息给那个窗口的大小和位置将要被改变时，来调用 setwindowpos 函数或其它窗口管理函数WM_WINDOWPOSCHANGED 发送此消息给那个窗口的大小和位置已经被改变时，来调用setwindowpos函数或其它窗口管理函数WM_POWER 当系统将要进入暂停状态时发送此消息 WM_COPYDATA当一个应用程序传递数据给另一个应用程序时发送此消息 WM_CANCELJOURNA 当某个用户取消程序日志激活状态，提交此消息给程序WM_NOTIFY 当某个控件的某个事件已经发生或这个控件需要得到一些信息时，发送此消息给它的父窗口WM_INPUTLANGCHANGEREQUEST 当用户选择某种输入语言，或输入语言的热键改变 WM_INPUTLANGCHANGE当平台现场已经被改变后发送此消息给受影响的最顶级窗口 WM_TCARD 当程序已经初始化 windows帮助例程时发送此消息给应用程序 WM_HELP此消息显示用户按下了F1，如果某个菜单是激活的，就发送此消息个此窗口关联的菜单，否则就发送给有焦点的窗口，如果当前都没有焦点，就把此消息发送给当前激活的窗口WM_USERCHANGED当用户已经登入或退出后发送此消息给所有的窗口，当用户登入或退出时系统更新用户的具体设置信息，在用户更新设置时系统马上发送此消息WM_NOTIFYFORMAT 公用控件，自定义控件和他们的父窗口通过此消息来判断控件是使用ANSI还是UNICODE结构WM_CONTEXTMENU 当用户某个窗口中点击了一下右键就发送此消息给这个窗口 WM_STYLECHANGING当调用SETWINDOWLONG函数将要改变一个或多个 窗口的风格时发送此消息给那个窗口 WM_STYLECHANGED 当调用SETWINDOWLONG 函数一个或多个 窗口的风格后发送此消息给那个窗口 WM_DISPLAYCHANGE当显示器的分辨率改变后发送此消息给所有的窗口 WM_GETICON此消息发送给某个窗口来返回与某个窗口有关连的大图标或小图标的句柄 WM_SETICON程序发送此消息让一个新的大图标或小图标与某个窗口关联 WM_NCCREATE当某个窗口第一次被创建时，此消息在WM_CREATE消息发送前发送 WM_NCDESTROY此消息通知某个窗口，非客户区正在销毁 WM_NCCALCSIZE 当某个窗口的客户区域必须被核算时发送此消息WM_NCHITTEST 移动鼠标，按住或释放鼠标时发生 WM_NCPAINT程序发送此消息给某个窗口当它（窗口）的框架必须被绘制时 WM_NCACTIVATE此消息发送给某个窗口仅当它的非客户区需要被改变来显示是激活还是非激活状态 WM_GETDLGCODE发送此消息给某个与对话框程序关联的控件。正常情况下，windows 处理所有输入到此控件的箭头键和 TAB 键。通常响应WM_GETDLGCODE 消息，应用程序可以控制一个特定类型的输入和处理这个输入 WM_NCMOUSEMOVE 当光标在一个窗口的非客户区内移动时发送此消息给这个窗口。非客户区为：窗体的标题栏及窗体的边框 WM_NCLBUTTONDOWN当光标在一个窗口的非客户区同时按下鼠标左键时提交此消息 WM_NCLBUTTONUP当用户释放鼠标左键同时光标某个窗口在非客户区十发送此消息 WM_NCLBUTTONDBLCLK当用户双击鼠标左键同时光标某个窗口在非客户区十发送此消息 WM_NCRBUTTONDOWN当用户按下鼠标右键同时光标又在窗口的非客户区时发送此消息 WM_NCRBUTTONUP当用户释放鼠标右键同时光标又在窗口的非客户区时发送此消息 WM_NCRBUTTONDBLCLK当用户双击鼠标右键同时光标某个窗口在非客户区十发送此消息 WM_NCMBUTTONDOWN当用户按下鼠标中键同时光标又在窗口的非客户区时发送此消息 WM_NCMBUTTONUP当用户释放鼠标中键同时光标又在窗口的非客户区时发送此消息 WM_NCMBUTTONDBLCLK当用户双击鼠标中键同时光标又在窗口的非客户区时发送此消息 WM_KEYFIRST WM_KEYDOWN 按下一个键WM_KEYUP 释放一个键 WM_CHAR 按下某键，并已发出WM_KEYDOWN，WM_KEYUP消息 WM_DEADCHAR 当用 translatemessage 函数翻译 WM_KEYUP消息时发送此消息给拥有焦点的窗口 WM_SYSKEYDOWN 当用户按住 ALT 键同时按下其它键时提交此消息给拥有焦点的窗口WM_SYSKEYUP 当用户释放一个键同时 ALT 键还按着时提交此消息给拥有焦点的窗口 WM_SYSCHAR当WM_SYSKEYDOWN消息被TRANSLATEMESSAGE函数翻译后提交此消息给拥有焦点的窗口 WM_SYSDEADCHAR当WM_SYSKEYDOWN消息被TRANSLATEMESSAGE函数翻译后发送此消息给拥有焦点的窗口 WM_INITDIALOG在一个对话框程序被显示前发送此消息给它，通常用此消息初始化控件和执行其它任务 WM_COMMAND当用户选择一条菜单命令项或当某个控件发送一条消息给它的父窗口，一个快捷键被翻译 WM_SYSCOMMAND当用户选择窗口菜单的一条命令或当用户选择最大化或最小化时那个窗口会收到此消息 WM_TIMER 发生了定时器事件WM_HSCROLL 当一个窗口标准水平滚动条产生一个滚动事件时发送此消息给那个窗口，也发送给拥有它的控件WM_VSCROLL 当一个窗口标准垂直滚动条产生一个滚动事件时发送此消息给那个窗口，也发送给拥有它的控件WM_INITMENU当一个菜单将要被激活时发送此消息，它发生在用户菜单条中的某项或按下某个菜单键，它允许程序在显示前更改菜单 WM_INITMENUPOPUP当一个下拉菜单或子菜单将要被激活时发送此消息，它允许程序在它显示前更改菜单，而不要改变全部 WM_MENUSELECT当用户选择一条菜单项时发送此消息给菜单的所有者（一般是窗口） WM_MENUCHAR当菜单已被激活用户按下了某个键（不同于加速键），发送此消息给菜单的所有者 WM_ENTERIDLE当一个模态对话框或菜单进入空载状态时发送此消息给它的所有者，一个模态对话框或菜单进入空载状态就是在处理完一条或几条先前的消息后没有消息它的列队中等待WM_CTLCOLORMSGBOX 在 windows绘制消息框前发送此消息给消息框的所有者窗口，通过响应这条消息，所有者窗口可以通过使用给定的相关显示设备的句柄来设置消息框的文本和背景颜色WM_CTLCOLOREDIT 当一个编辑型控件将要被绘制时发送此消息给它的父窗口通过响应这条消息，所有者窗口可以通过使用给定的相关显示设备的句柄来设置编辑框的文本和背景颜色 WM_CTLCOLORLISTBOX当一个列表框控件将要被绘制前发送此消息给它的父窗口通过响应这条消息，所有者窗口可以通过使用给定的相关显示设备的句柄来设置列表框的文本和背景颜色 WM_CTLCOLORBTN当一个按钮控件将要被绘制时发送此消息给它的父窗口 通过响应这条消息，所有者窗口可以通过使用给定的相关显示设备的句柄来设置按纽的文本和背景颜色WM_CTLCOLORDLG 当一个对话框控件将要被绘制前发送此消息给它的父窗口通过响应这条消息，所有者窗口可以通过使用给定的相关显示设备的句柄来设置对话框的文本背景颜色 WM_CTLCOLORSCROLLBAR当一个滚动条控件将要被绘制时发送此消息给它的父窗口 通过响应这条消息，所有者窗口可以通过使用给定的相关显示设备的句柄来设置滚动条的背景颜色WM_CTLCOLORSTATIC 当一个静态控件将要被绘制时发送此消息给它的父窗口 通过响应这条消息，所有者窗口可以通过使用给定的相关显示设备的句柄来设置静态控件的文本和背景颜色 WM_MOUSEFIRST 移动鼠标时发生WM_MOUSEMOVE 移动鼠标时发生，同WM_MOUSEFIRST WM_LBUTTONDOWN 按下鼠标左键WM_LBUTTONUP 释放鼠标左键 WM_LBUTTONDBLCLK 双击鼠标左键 WM_RBUTTONDOWN按下鼠标右键 WM_RBUTTONUP 释放鼠标右键 WM_RBUTTONDBLCLK 双击鼠标右键WM_MBUTTONDOWN 按下鼠标中键 WM_MBUTTONUP 释放鼠标中键 WM_MBUTTONDBLCLK双击鼠标中键 WM_MOUSEWHEEL 当鼠标轮子转动时发送此消息个当前有焦点的控件 按钮 BM_CLICK 按钮被点击消息 BM_GETCHECK 可用于复选框/单选框。查看是否被选择了 BM_GETSTATE发送此消息，可返回 button 的状态，如是否被选择；是否可用（不可用就变灰了） BM_SETCHECK如果已经选择了，发送此消息后，变为未选择，就是那个钩没被勾上 BM_SETSTATE 设置 button 被点击状态。 组合框 CB_ADDSTRING 添加字符串到组合框。 CB_DELETESTRING 删除组合框中的条目，即 item 。CB_GETCOUNT 得到组合框条目 item 的数目。 CB_GETCURSEL返回组合框中被选条目在组合框中的位置，第一条为 0。 如果没有条目或出错，则返回 -1 。 CB_GETDROPPEDSTATE 发送此消息，可判断组合框的下拉列表是否下拉。 如果是，返回非零值，不是，则返回 0 。 CB_GETLBTEXT 得到组合框的条目文本。返回值是这个文本的长度。 CB_GETLBTEXTLEN 返回值是条目的文本的长度。CB_INSERTSTRING 插入字符串条目到组合框中。 CB_RESETCONTENT 清空组合框所有条目。CB_SETCURSEL 设置组合框被选条目。 CB_SHOWDROPDOWN 让组合框的下拉列表下拉，即显出所有条目。 编辑框 EM_CANUNDO 决定上一次操作是否可以 undo（撤消操作）。如果可以，则可发送 EM_UNDO 消息EM_GETFIRSTVISIBLELINE 在多行控件中，找到最上层的可见的行号。此行号是相对于所有行的。EM_GETPASSWORDCHAR 返回密码框的字符集，即查看密码。 EM_GETSEL返回在可编辑控件中，被选择（高亮选择）的字符集的起点和终点的位置，用 SendMessage 的 wParam参数返回起点位置，lParam 返回终点位置 EM_REPLACESEL用不同的字符串替换可编辑控件中的字符串。如果可编辑控件中没有字符串，则此消息变为添加字符串。如果 wParam 为TRUE，则本次操作允许撤消，FALSE 禁止撤消。 EM_SETPASSWORDCHAR 在可编辑控件中设置密码字符集，即用 *代替 EM_UNDO 发送操作撤消消息。 EM_GETLINE获取编辑控件中输入的文字。 EM_LINEFROMCHAR 检索指定字符索引（索引编号从编辑框的第一个字符开始）所在的行索引EM_LINEINDEX 在多行编辑控件中，检索某行首字符在编辑控件中的索引 EM_ERRSPACE编辑控件不能分配足够的内存来满足特定的要求。 编辑控件的父窗口通过 WM_COMMAND 消息收到此消息。 EM_LIMITTEXT 设置编辑框用户可输入的最大字符数。wParam 为字符数，lParam 不使用(0L) IP 地址控件 IPM_CLEARADDRESS 清除 IP 地址控件（IP Address control）的内容IPM_GETADDRESS 从 IP 地址控件获得存储在它中的 IP 地址信息 IPM_ISBLANK决定 IP 地址控件是否可以为空值。即 127.0.0.1 之类的地址为空 IPM_SETADDRESS 在 IP地址控件中设置 IP 地址 IPM_SETFOCUS 在 IP 地址控件中，当需要输入 IP 地址时，使之获得键盘输入焦点 IPM_SETRANGE 设置输入 IP 地址的有效范围 MCI（Media Control Interface) MM_MCINOTIFY 该 MM_MCINOTIFY 消息通知应用程序，一个 MCI 设备已完成操作。只有设置了MCI_NOTIFY 标志时，MCI 设备才发送此消息。 菜单 WM_COMMAND 当用户选择菜单中的项目后,将向窗体发送此消息. 窗体收到此消息后,再决定下一个行为。 WM_INITMENU当菜单准备显示前,向窗体发送此消息, 窗体将初始化菜单项。 WM_SYSCOMMAND 向窗体发送用户点击系统菜单消息.窗体将响应这个消息 ,决定下个行为。 列表框 LB_ADDSTRING 在条目中添加字符串 LB_DELETESTRING 删除一个条目. 条目序号是从 0开始的. LB_GETCOUNT 得到条目总数. LB_GETCURSEL 得到单选的列表框选项条目的序号LB_GETSEL 判断列表框的条目是否被选上, 如果选上了,则返回 &gt;0 的值。否则返回 0 ,表示用户没选择条目LB_GETSELCOUNT 获得可多选的列表框中被选择的条目数 LB_GETSELITEMS返回可多选的列表框中被选条目的序号，可返回数组 LB_GETTEXT 得到列表框中的一个条目的文本LB_GETTEXTLEN 得到列表框中的一个条目的文本的长度 LB_INSERTSTRING在列表框中插入一个条目。如果成功，将返回插入后此条目的序号。 LB_SETCURSEL对单选的列表框，设定用户选择条目的具体值 LB_SETSEL 对多选的列表框，设定用户选择条目的具体值LB_RESETCONTENT 从列表框删除所有项目，wParam 和 lParam 参数均不使用（为 0）LB_SETHORIZONTALEXTENT设定列表框水平滚动范围。如果列表框宽度小于此值，则水平滚动条显现；如果列表框宽度大于等于此值，则水平滚动条是隐藏的。wParam为所设的水平滚动范围（像素），lParam 不使用，为 0。没有返回值 注意：LB_SETHORIZONTALEXTENT消息要起作用，列表框必须定义 WS_HSCROLL 样式 LB_SETTABSTOPS在列表框中设置制表位位置（即每列间距）为了应对 LB_SETTABSTOPS 消息，列表框必须已经拥有 LBS_USETABSTOPS样式。 wParam 指定制表位数量，lParam 为制表位整数数组（各列之间间隔，不必相等）如果 wParam 是 0，lParam 为NULL，默认制表位是 2 个对话框模板单位。如果 wParam 是 1，制表位为 lParam 指定的距离。如果超过 1，制表位将被设置为lParam 中的每个值（wParam 指定数量） 鼠标 WM_LBUTTONDBLCLK 当鼠标在一个窗体范围内时，告诉此窗体鼠标左键已双击，返回值 0 WM_LBUTTONDOWN当鼠标在一个窗体范围内时，告诉此窗体鼠标左键已点击，返回值 0 WM_LBUTTONUP当鼠标在一个窗体范围内时，告诉此窗体鼠标左键已释放，返回值 0 WM_MBUTTONDBLCLK当鼠标在一个窗体范围内时，告诉此窗体鼠标中键已双击，返回值 0 WM_MBUTTONDOWN当鼠标在一个窗体范围内时，告诉此窗体鼠标中键已点击，返回值 0 WM_MBUTTONUP当鼠标在一个窗体范围内时，告诉此窗体鼠标中键已释放，返回值 0 项目源码可以访问我的码云&gt;&gt;&gt;我的私人博客&lt;&lt;&lt;]]></content>
      <categories>
        <category>MFC从入门到放弃</category>
      </categories>
      <tags>
        <tag>MFC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第15节 MFC之复选框及单选按钮]]></title>
    <url>%2F2017%2F11%2F02%2F%E7%AC%AC15%E8%8A%82-MFC%E4%B9%8B%E5%A4%8D%E9%80%89%E6%A1%86%E5%8F%8A%E5%8D%95%E9%80%89%E6%8C%89%E9%92%AE%2F</url>
    <content type="text"><![CDATA[Windows编程基础–第15节 MFC之复选框及单选按钮1. 新建项目新建一个基于对话框项目“day17”，布局如下，自行处理： 拖动三个check box和两个radio button到界面上，设置其ID如下：| 控件名 | 控件ID|| ——– | —–: || 红色| IDC_CHECK_RED|| 绿色 | IDC_CHECK_GREEN|| 蓝色 | IDC_CHECK_BLUE|| 矩形 | IDC_RADIO_SQURAE|| 圆形| IDC_RADIO_CIRC|执行“工具”-&gt;“tab键位置”，确保两个radio button的顺序是连续的，如下图： 指定第一个radio button（矩形）的Group的值为true，如图: 2. 添加关联变量添加五个控件的变量，如图： 12345DDX_Control(pDX, IDC_CHECK_RED, m_chk_red);DDX_Control(pDX, IDC_CHECK_GREEN, m_chk_green);DDX_Control(pDX, IDC_CHECK_BLUE, m_chk_blue);DDX_Control(pDX, IDC_RADIO_SQURAE, m_rd_squ);DDX_Control(pDX, IDC_RADIO_CIRC, m_rd_circ); 分别添加如上变量； 3. 开始写代码吧现在我们来让程序运行起来时默认选中圆形；切换到解决方案视图，进入BOOL Cday17Dlg::OnInitDialog()方法：在末尾return前加入这一行： 1234// TODO: 在此添加额外的初始化代码CheckRadioButton(IDC_RADIO_SQURAE,IDC_RADIO_CIRC,IDC_RADIO_CIRC);return TRUE; // 除非将焦点设置到控件，否则返回 TRUE 代码解释： 在IDC_RADIO_SQURAE和IDC_RADIO_CIRC之间选中IDC_RADIO_CIRC 添加五个控件的事件处理方法如图所示：剩下四个都如上添加好；编辑“蓝色”按钮的点击方法： 12345void Cday17Dlg::OnBnClickedCheckBlue()&#123; // TODO: 在此添加控件通知处理程序代码 Invalidate();&#125; 代码解释： Invalidate()让对话框重汇对话框； 添加擦除背景消息（OnEraseBkgnd）事件如图添加OnEraseBkgnd消息处理函数：编辑OnEraseBkgnd函数： 12345678910111213141516171819202122232425BOOL Cday17Dlg::OnEraseBkgnd(CDC* pDC)&#123; // TODO: 在此添加消息处理程序代码和/或调用默认值 BOOL bRet = CDialogEx::OnEraseBkgnd(pDC); int nRed,nGreen,nBlue; nRed = m_chk_red.GetCheck() ? 255 : 0; nGreen = m_chk_green.GetCheck() ? 255 : 0; nBlue = m_chk_blue.GetCheck() ? 255 : 0; COLORREF crFore = RGB(nRed,nGreen,nBlue); CBrush brush; brush.CreateSolidBrush(crFore); CBrush *pOldBrush = pDC-&gt;SelectObject(&amp;brush); RECT rc = &#123;100, 40, 400, 340&#125;; if (m_rd_squ.GetCheck()) &#123; pDC-&gt;Rectangle(&amp;rc); &#125; else&#123; pDC-&gt;Ellipse(&amp;rc); &#125; pDC-&gt;SelectObject(pOldBrush); return bRet;&#125; 代码解释： 根据颜色按钮的选择状态来选择颜色为255还是0； 用三个的颜色来创建一个画刷； 保留旧的画刷； 创建RECT 对象，即圆形的大小； 根据形状的radio button来选择化圆形还是矩形； 还原旧的画刷； 实现其他按钮其他按钮就只用调用OnBnClickedCheckBlue()就可以了； 最终效果图： 项目源码可以访问我的码云&gt;&gt;&gt;我的私人博客&lt;&lt;&lt;]]></content>
      <categories>
        <category>MFC从入门到放弃</category>
      </categories>
      <tags>
        <tag>MFC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第14节 MFC之文件对话框CFileDialog]]></title>
    <url>%2F2017%2F11%2F01%2F%E7%AC%AC14%E8%8A%82-MFC%E4%B9%8B%E6%96%87%E4%BB%B6%E5%AF%B9%E8%AF%9D%E6%A1%86CFileDialog%2F</url>
    <content type="text"><![CDATA[第14节 MFC之文件对话框CFileDialog 今天我们学习两个打开文件对话框、保存文件对话框，应用程序难免需要加载文件，或者打开配置文件等，这就用到打开或者保存对话框，例如windows文本编辑器中保存对话框就属于其中一种： 1. 新建项目新建一个基于对话框项目“day16”，布局如下，自行处理：拖动一个EDIT到界面，并修改如下属性： 属性 修改值 解释 ID IDC_EDIT_TXT 控件ID Want Return TRUE 允许回车 Multiline TRUE 允许多行 Horizontal Scoll TRUE 水平滚动条 Vertical Scoll TRUE 垂直滚动条 2. 添加菜单资源切换到资源视图，添加菜单资源如下：若不知道怎么添加菜单请参考Windows编程基础–第10节 MFC菜单 注意：菜单选项最后加上&amp;符号可以设置快捷键，如“文件(&amp;F)”，当程序运行时可以通过ALT + F快捷打开文件菜单选项； 将菜单绑定到主界面： 3. 实现文件打开对话框右击菜单中“打开”选项，选择“添加事件处理处理程序”，添加处理程序，如图：其中行数处理程序名称：OnFileOpen，类列表选择：Cday16Dlg，添加编辑：函数代码如下： 12345678910111213141516171819202122232425262728void Cday16Dlg::OnFileOpen()&#123; // TODO: 在此添加命令处理程序代码 CFileDialog dlg(TRUE,NULL,NULL,OFN_FILEMUSTEXIST|OFN_PATHMUSTEXIST,_T(&quot;文本文件(*.txt)|*.txt|所有文件(*.*)|*.*||&quot;),this); dlg.m_ofn.lpstrInitialDir = _T(&quot;C:\\&quot;); if (dlg.DoModal() == IDOK) &#123; CStdioFile inFile; inFile.Open(dlg.GetPathName(),CFile::modeRead); CString text; CString temp; while(inFile.ReadString(text)) &#123; GetDlgItemText(IDC_EDIT_TXT,temp); if (temp.GetLength() &gt; 0) &#123; SetDlgItemText(IDC_EDIT_TXT,temp +&quot;\r\n&quot;+ text); &#125; else &#123; SetDlgItemText(IDC_EDIT_TXT,text); &#125; &#125; inFile.Close(); &#125;&#125; 代码解释： 创建一个txt文件对话框； 如文件对话框确定按钮被点击，则打开文件位置，文件全路径就是dlg.GetPathName()； 循环读取文件，知道文件读取结束；每读一行就先获取界面文本框的内容加上新读取的文本，重新设置到界面； 关闭文件 这样一个打开文件对话框就完成了，效果图如下： 3. 实现文件保存对话框右击菜单中“保存”选项，选择“添加事件处理处理程序”，添加处理程序，如图：名称：OnSaveFile，类列表选择：Cday16Dlg，添加编辑：函数代码如下12345678910111213141516171819202122void Cday16Dlg::OnSaveFile()&#123; // TODO: 在此添加命令处理程序代码 CFileDialog dlg(FALSE,NULL,NULL,OFN_HIDEREADONLY |OFN_OVERWRITEPROMPT | OFN_PATHMUSTEXIST,_T(&quot;文本文件(*.txt)|*.txt||&quot;),this); if (dlg.DoModal() == IDOK) &#123; CFile file; //建立一个CFile对象 //打开文件,如果不存在该文件就创建文件 if(!file.Open(dlg.GetPathName(),CFile::modeCreate|CFile::modeWrite)) &#123; AfxMessageBox( &quot;can not Create file! &quot;); return; &#125; CString output; GetDlgItemText(IDC_EDIT_TXT,output); file.Write(output,strlen(output)); file.Flush(); //将在缓冲区中的字符写入文件中 file.Close(); //关闭文件 AfxMessageBox( &quot;保存成功！&quot;); &#125;&#125; 代码解释： 创建一个txt文件保存对话框； 如文件对话框确定按钮被点击，则获取文件位置，文件全路径就是dlg.GetPathName()； 先获取界面文本框的内容，将内容写到文件中； 关闭文件效果图： 好了，这节我们演示了如何创建文件打开和保存对话框，希望对大家有作用，今天就到这了。项目源码可以访问我的码云&gt;&gt;&gt;我的私人博客&lt;&lt;&lt;]]></content>
      <categories>
        <category>MFC从入门到放弃</category>
      </categories>
      <tags>
        <tag>MFC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第13节 MFC之图片控件]]></title>
    <url>%2F2017%2F10%2F31%2F%E7%AC%AC13%E8%8A%82-MFC%E4%B9%8B%E5%9B%BE%E7%89%87%E6%8E%A7%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[第13节 MFC之图片控件这节学习两个控件： 图片控件： Picture Control 1. 新建项目新建一个基于对话框项目“day15”，布局如下，自行处理：拖动一个Picture Control控件到界面，其实Picture Control就是CStatic 类； 设置Picture Control的如下属性： 属性 修改值 解释 ID IDC_STATIC_IMG 控件ID Type Bitmap 设置类型为bitmap位图类型 如图： 2.添加Bitmap 位图资源自行下载几张.bmp位图，拷贝到项目的res文件下，然后切换到资源视图，添加Bitmap 资源，如图所示：上传完成之后可以看到已经有三个Bitmap 位图的ID； 3.显示出位图资源单击Picture Control控件，在属性中找到Image属性，在下拉框中选择我们刚才添加的位图ID就可以成功显示图片了，如图： 4.动态控制显示图片在界面上添加一个按钮，我么通过按钮来切换界面图片显示：接下来我们添加Picture Control控件的变量m_image，如图:我们来编辑“切换按钮”的点击方法： 123456void Cday15Dlg::OnBnClickedButtonChange()&#123; // TODO: 在此添加控件通知处理程序代码 HBITMAP phBmp = (HBITMAP)LoadImage(NULL,_T(&quot;.\\res\\20171031100114614.bmp&quot;),IMAGE_BITMAP,0,0,LR_LOADFROMFILE); m_image.SetBitmap(phBmp);&#125; 代码解释： 获取一个位图的句柄2.将其设置到Picture Control控件 效果图： 5.配合CFileDialog 类来选择显示图片我们来编辑“切换按钮”的点击方法： 12345678910void Cday15Dlg::OnBnClickedButtonChange()&#123; // TODO: 在此添加控件通知处理程序代码 CFileDialog dlg(TRUE,NULL,NULL,OFN_FILEMUSTEXIST,_T(&quot;*.bmp|*.bmp&quot;),this); if (dlg.DoModal() == IDOK) &#123; HBITMAP phBmp = (HBITMAP)LoadImage(NULL,dlg.GetPathName(),IMAGE_BITMAP,0,0,LR_LOADFROMFILE); m_image.SetBitmap(phBmp); &#125;&#125; 代码解释： 创建一个.bmp类型的文件打开对话框 若点击确定按钮，则将选择的.bmp文件显示出来； 效果图： 附Picture Control控件常见属性及方法： 一、图片控件属性 Picture Control 属性: Type:Frame //框架 Type:Etched Horz水平蚀刻线条 Type:EtchedVert垂真蚀刻线条 Type:Rectangle实心矩形 Type:Bitmap位图 Type:Icon 图标Type:Enhanced Metafile 增强图元 支持wmf格式图片 Type:Owner Draw 自绘图 Color:颜色 Black:黑 Gray:灰色 White:白色 Etched:蚀刻 二、Picture Control 控件类 CStatic:: SetBitmap Specifies a bitmap to be displayed in the staticcontrol. GetBitmap Retrieves the handle of the bitmap previously setwith SetBitmap. SetIcon Specifies an icon to be displayed in the static control.GetIcon Retrieves the handle of the icon previously set with SetIcon. SetCursor Specifies a cursor image to be displayed in the staticcontrol. GetCursor Retrieves the handle of the cursor image previouslyset with SetCursor. SetEnhMetaFile Specifies an enhanced metafile to be displayed in thestatic control. GetEnhMetaFile Retrieves the handle of the enhancedmetafile previously set with SetEnhMetaFile 项目源码可以访问我的码云&gt;&gt;&gt;我的私人博客&lt;&lt;&lt;]]></content>
      <categories>
        <category>MFC从入门到放弃</category>
      </categories>
      <tags>
        <tag>MFC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第12节 MFC之树控件CTreeCtrl]]></title>
    <url>%2F2017%2F10%2F30%2F%E7%AC%AC12%E8%8A%82-MFC%E4%B9%8B%E6%A0%91%E6%8E%A7%E4%BB%B6CTreeCtrl%2F</url>
    <content type="text"><![CDATA[树形控件（Tree Control）：用来显示一系列项目的层次关系，最典型的例子是显示磁盘上的文件与文件夹。如果有子项目的话，单击树形控件中的项目可以展开或者收缩其子项目。MFC提供了CTreeCtrl类进行支持。 树控件在windows程序中使用相对也是比较多的控件，例如windows资源管理器左边的浏览视图就是个树控件视图：今天我们学习一下使用树控件，实现“添加节点”、“删除节点”、“修改节点”； 1. 新建项目新建一个基于对话框项目“day14”，布局如下，自行处理： 控件名 控件ID Tree Control IDC_TREE_VIEW 编辑框 IDC_EDIT_ADD_MDY 添加节点 IDC_BUTTON_ADD 删除节点 IDC_BUTTON_DEL 修改节点 IDC_BUTTON_MDY 2. 设置树控件属性编辑树控件如下属性： 属性 修改值 解释 Has Buttons TRUE 在父节点旁边显示+或- Has Lines TRUE 在父节点和子节点之间划线 Line At root TRUE 在根节点上划线 3. 添加树控件变量给树控件添加一个变量“m_tree”，如图： 4. 实现添加节点按钮函数双击“添加节点”按钮，编辑按钮点击方法： 123456789101112131415161718192021222324void Cday14Dlg::OnBnClickedButtonAdd()&#123; // TODO: 在此添加控件通知处理程序代码 CString strText; GetDlgItemText(IDC_EDIT_ADD_MDY,strText); if (strText.GetLength() == 0) &#123; AfxMessageBox(_T(&quot;请输入节点名！&quot;)); return; &#125; HTREEITEM hItem = m_tree.GetSelectedItem(); if(hItem == NULL)&#123; hItem = TVI_ROOT; &#125; TVINSERTSTRUCT ts =&#123;0&#125;; ts.hParent = hItem; ts.hInsertAfter = TVI_LAST; ts.item.pszText = strText.GetBuffer(); ts.item.mask = TVIF_TEXT; HTREEITEM hNewItem = m_tree.InsertItem(&amp;ts); m_tree.SelectItem(hNewItem); m_tree.EnsureVisible(hNewItem);&#125; 代码解释： 先获取文本框中的值，如果值为空，则提示用户输入； 获取当前选中的节点，若不存在选中的节点，则获取根节点； 创建节点结构体，设置其父节点，插入方式，节点内容，内容可见等； 插入新的节点，并且设置节点保证可见；效果图：5. 实现删除节点按钮函数双击“删除节点”按钮，编辑按钮点击方法： 12345678910111213void Cday14Dlg::OnBnClickedButtonDel()&#123; // TODO: 在此添加控件通知处理程序代码 HTREEITEM hItem = m_tree.GetSelectedItem(); if(hItem == NULL)&#123; AfxMessageBox(_T(&quot;请选择要删除的节点！&quot;)); return; &#125; HTREEITEM hParentItem = m_tree.GetParentItem(hItem); m_tree.DeleteItem(hItem); m_tree.SelectItem(hParentItem);&#125; 代码解释： 获取选中的节点，若没有选中的节点，则提示用户； 获取选中节点的父节点 删除选中的节点 将其父节点设置为选中节点 删除前：删除后： 6. 实现修改节点按钮函数双击“修改节点”按钮，编辑按钮点击方法： 123456789101112131415161718void Cday14Dlg::OnBnClickedButtonMdy()&#123; // TODO: 在此添加控件通知处理程序代码 HTREEITEM hItem = m_tree.GetSelectedItem(); if(hItem == NULL)&#123; AfxMessageBox(_T(&quot;请选择要修改的节点！&quot;)); return; &#125; CString strText; GetDlgItemText(IDC_EDIT_ADD_MDY,strText); if (strText.GetLength() == 0) &#123; AfxMessageBox(_T(&quot;请输入新的节点名！&quot;)); return; &#125; m_tree.SetItemText(hItem,strText);&#125; 代码解释： 获取选中的节点，若没有选中的节点，则提示用户； 先获取文本框中的值，如果值为空，则提示用户输入；3.修改文本名7. 映射节点选择消息我们想实现在点击选择控件是，下方的文本框中自动出现选择节点的文本，那么就要映射节点的选择变化消息：TVN_SELCHANGE，如图添加事件处理函数：编辑事件处理函数： 123456789101112void Cday14Dlg::OnTvnSelchangedTreeView(NMHDR *pNMHDR, LRESULT *pResult)&#123; LPNMTREEVIEW pNMTreeView = reinterpret_cast&lt;LPNMTREEVIEW&gt;(pNMHDR); // TODO: 在此添加控件通知处理程序代码 HTREEITEM hItem = m_tree.GetSelectedItem(); if(hItem != NULL)&#123; CString strText = m_tree.GetItemText(hItem); SetDlgItemText(IDC_EDIT_ADD_MDY, strText); &#125; *pResult = 0;&#125; 代码解释： 获取选中的节点，若不存在，则略过，不处理； 获取选中的节点文本，将文本值设置到文本框中； 效果图： 至此，MFC树控件的简单使用已经结束，其实树控件还有很多属性，比如添加图标，这就到以后的实践中再来学习，附树控件常见属性及方法： 1、树形控件的属性 TVS_EDITLABELS:允许用户进行节点文本的编辑 TVS_HASBUTTONS:节点左侧添加一个按钮TVS_HASLINES:父节点与子结点出现连线 TVS_LINESATROOT:子节点与根节点之间出现连线TVS_NOTOOLTIPS:结点无动态提示 TVS_SINGLEEXPAND:节点的选中(未选中)t7展开(合拢)同步MFC中以两种形式封装树形控件，一种是树形控件CTreeCtrl，另一种是树形视图控件CTreeView。对于一般的要求，比如在对话框中，使用CTreeCtrl比较方便。在使用树形视图控件时，只需要利用成员函数取得其引用，就可以像树形控件一样方便的使用：CTreeCtrl&amp; GetTreeCtrl( ) const;调用InsertItem函数能够将节点插入树形控件中，并返回插入的项的HTREEITEM。树形控件的插入工作往往是在对话框的OnInitDialog函数中进行，而对于树形视图控件，则是在OnInitUpdate函数中进行。树形控件中的节点数据可以是文本，也可以是图像。节点中使用的图像是和树形控件的图像列表相对应的。在树形控件中使用图像列表是通过使用SetImageList函数来完成。树形控件能产生通告消息，如: TVN_BEGINDRAG开始拖拽 TVN_ITEMEXPANDED节点被展开或收缩其消息映射使用WM_NOTIFI,如： WM_NOTIFI(TVN_BEGINDRAG,IDC_TREECTRL,OnBeginDrag); 2、树形控件TVN_BEGINRDRAG消息的响应 与树形控件有关的、常用的结构是TVITEM、TVINSERTSTRUCT 、NMTREEVIEW(NM_TREEVIEW)。前两个是用于插入节点时使用，而NMTREEVIEW是与树形控件的通告消息相关的结构。当用鼠标左键拖拽树形控件时，控件会发出TVN_BEGINDRAG通告消息；当用鼠标右键拖拽时，则会发出TVN_BEGINRDRAG通告消息。拖拽树形控件时需要使用到IImageList::BeginDrag函数：IImageList::BeginDrag creates a temporary image list that is used fordragging. In response to subsequent WM_MOUSEMOVE messages, you canmove the drag image by using IImageList::DragMove. To end the dragoperation, you can use IImageList::EndDrag.通常使用CTreeCtrl::CreateDragImage函数创建一个被拖拽节点的图像并返回一个CImageList指针(注意被拖拽的数据节点必须包含图像，否则返回的CImageList指针为空)，然后利用该指针来调用CImageList::BeginDrag函数。除此之外还需要调用CImageList::DragEnter函数锁定、更新窗口，并在指定的位置显示被拖拽的图像：static BOOL PASCAL DragEnter( CWnd* pWndLock, CPoint point );If pWndLock is NULL, this function draws the image in the displaycontext associated with the desktop window, and coordinates arerelative to the upper left corner of the screen.注意BeginDrag函数只是在拖拽开始时创建要拖拽的图像，而DragEnter函数则显示该图像。最后调用CWnd::SetCapture函数使后续所有的鼠标输入都发送到当前的CWnd对象而不管鼠标的位置（因为CImageList::DragEnter函数的第一个参数为NULL时表示在与桌面窗口相关的窗口，可以说就是当前程序的框架窗口，但不包括其他应用程序的窗口上显示被拖拽的图像。因此要使得被拖拽的图像在所有的窗口上而不仅仅是应用程序的框架窗口上显示，就需要调用CWnd::SetCapture函数。一旦调用了SetCapture函数，则在当前应用程序的非框架窗口，包括系统菜单上的鼠标按键动作均被发送到当前CWnd对象，直到调用ReleaseCapture为止）。然后就是在鼠标移动的消息响应函数中调用CImageList::DragMove函数移动被拖拽的图像，使之与鼠标的移动位置同步。最后是调用CImageList::DragShowNolock函数隐藏或显示拖拽的图像，但它并不是必须的，也可以不调用，因此之前已经调用过CImageList::DragEnter函数显示拖拽的图像了。当传递true值显示拖拽的图像时，DragShowNolock在这个过程中不像DragEnter函数一样锁定窗口。值得注意的是，在拖拽节点过程中可以使用CTreeCtrl::HitTest函数判断鼠标滑动过程中所经过的点是否位于树形控件的某一个节点之上，如果是，则返回该树形节点的HTREEITEM。此时可以使用CTreeCtrl::SelectDropTarget函数或CTreeCtrl::SelectItem函数来高亮显示该节点。 3、树形控件的成员函数 InsertItem函数插入一个节点，并返回新插入的节点的HTREEITEM。ItemHasChildren函数根据给定的HTREEITEM判断该节点是否存在子节点。GetChildItem函数根据给定的HTREEITEM获取该节点下子节点的HTREEITEM，如果没有子节点，则返回NULL。GetNextSiblingItem函数根据给定的HTREEITEM获取该节点的下一个同级节点。EnsureVisible函数在必要的时候滚动视图列表控件使得其至少部分可见。需要注意的是，在使用TVE_COLLAPSE调用Expand收缩树形控件后不能再调用该函数，否则收缩操作将无效。 感伤：WE输了，RNG输了，心碎了。。。项目源码可以访问我的码云&gt;&gt;&gt;我的私人博客&lt;&lt;&lt;]]></content>
      <categories>
        <category>MFC从入门到放弃</category>
      </categories>
      <tags>
        <tag>MFC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第11节 MFC之列表控件CListCtrl]]></title>
    <url>%2F2017%2F10%2F29%2F%E7%AC%AC11%E8%8A%82-MFC%E4%B9%8B%E5%88%97%E8%A1%A8%E6%8E%A7%E4%BB%B6CListCtrl%2F</url>
    <content type="text"><![CDATA[Windows编程基础–第11节 MFC之列表控件CListCtrl在MFC程序中列表控件也是使用很频繁的控件，例如windows的资源管理器就可以用列表控件来实现，如下图：列表控件具有以下四种视图： 大图标 小图标 列表 详细信息1. 新建项目新建一个基于对话框项目“day13”，布置界面如下，从左侧“工具箱”拖动一个List control到界面，再加上两个按钮及Combo Box，如图： 控件名 控件ID List control IDC_LIST_VIEW Combo Box IDC_COMBO2 添加行 IDC_BUTTON_ADD 删除行 IDC_BUTTON_DEL 2. 添加列表控件变量单击选中列表控件，右击选择-&gt;“添加变量”，添加变量名为m_list,如下： 3. 初始化列表控件切换到对话框的初始化函数（OnInitDialog()），我们来给列表控件增加三列， 1234m_list.ModifyStyle(LVS_TYPEMASK, LVS_REPORT); //设置列表控件样式为详细信息m_list.InsertColumn(0,_T(&quot;第一列&quot;),LVCFMT_LEFT,120);m_list.InsertColumn(1,_T(&quot;第二列&quot;),LVCFMT_LEFT,120);m_list.InsertColumn(2,_T(&quot;第三列&quot;),LVCFMT_LEFT,120); 4. 添加列表图标自行下载或者制作两个bmp图标，分别为1616，和3232；将图标复制到项目的res资源目录中，切换到资源视图，右击添加资源，导入我们准备好的图标，如图所示：导入好之后我们可以更改位图ID，如图所示：接下来我们在day13.h的头文件中添加两个成员变量： 12CImageList m_ilLarge;CImageList m_ilSmall; 分别来对应3232，和1616；然后我们再切换到初始化函数中，添加如下四行代码： 12345m_ilLarge.Create(IDB_BITMAP_32, 32, 1,RGB(255,0,255));m_ilSmall.Create(IDB_BITMAP_16, 16, 1,RGB(255,0,255));m_list.SetImageList(&amp;m_ilLarge,LVSIL_NORMAL);m_list.SetImageList(&amp;m_ilSmall,LVSIL_SMALL); 5. 实现添加行按钮函数双击“添加行”按钮，编辑按钮点击方法： 123456789101112void Cday13Dlg::OnBnClickedButtonAdd()&#123; // TODO: 在此添加控件通知处理程序代码 int nCount = m_list.GetItemCount(); CString strText; strText.Format(_T(&quot;第%d行，第一列&quot;), nCount + 1); m_list.InsertItem(nCount,strText,0); strText.Format(_T(&quot;第%d行，第二列&quot;), nCount + 1); m_list.SetItemText(nCount,1,strText); strText.Format(_T(&quot;第%d行，第三列&quot;), nCount + 1); m_list.SetItemText(nCount,2,strText);&#125; 注意，只有添加第一行第一个元素是才是InsertItem，之后的添加都应该是SetItemText，防止出错； 5. 实现删除行按钮函数双击“删除行”按钮，编辑按钮点击方法： 123456789101112void Cday13Dlg::OnBnClickedButtonDel()&#123; // TODO: 在此添加控件通知处理程序代码 int nCount = m_list.GetItemCount(); for (int i = nCount; i&gt;=0 ; --i) &#123; if (m_list.GetItemState(i,LVIS_SELECTED) == LVIS_SELECTED) &#123; m_list.DeleteItem(i); &#125; &#125;&#125; 这样就实现了删除行的按钮，并且所有被选中的行都会被删除，按住Ctrl选中多行，点击删除，所有被选中的行都会被删除； 6. 实现列表控件的样式切换切换到资源视图，单击Combo Box，打开属性-&gt;data;输入： 大图标;小图标;详细信息;列表; 如图： 继续编辑Combo Box的属性，选择“控件事件”，添加CBN_Selchange事件，如图：编辑Combo Box的OnCbnSelchangeCombo2处理函数： 12345678910111213141516171819202122232425void Cday13Dlg::OnCbnSelchangeCombo2()&#123; // TODO: 在此添加控件通知处理程序代码 DWORD dwStyle; CComboBox *pView; pView = (CComboBox *)GetDlgItem(IDC_COMBO2); switch(pView-&gt;GetCurSel()) &#123; case 0: dwStyle = LVS_ICON; break; case 1: dwStyle = LVS_SMALLICON; break; case 2: dwStyle = LVS_LIST; break; case 3: dwStyle = LVS_REPORT; break; default: return; &#125; m_list.ModifyStyle(LVS_TYPEMASK,dwStyle);&#125; 很明显，先用GetDlgItem获取Combo Box的对象，然后判断Combo Box的选中的是哪一项，记录选中项的列表类型，最后设置列表属性； 最后效果图：大图标:小图标： 列表：详细信息： 项目源码可以访问我的码云&gt;&gt;&gt;我的私人博客&lt;&lt;&lt;]]></content>
      <categories>
        <category>MFC从入门到放弃</category>
      </categories>
      <tags>
        <tag>MFC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[工具使用--第2节 HEXO+GitHub 搭建个人博客]]></title>
    <url>%2F2017%2F10%2F29%2F%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8-%E7%AC%AC2%E8%8A%82-HEXO-GitHub-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[今天突然想搭建一个自己的私人博客，但是又不想为此买一台服务器，所以百度了一下，发现可以利用HEXO+码云 搭建私人博客，所以就写篇教程，记录一下吧。 1、环境安装配置1.1 安装node下载地址：https://nodejs.org/en/download/默认安装就好。 1.2 安装gitmsysgit是Windows版的Git，从https://git-for-windows.github.io下载（百度一下也有很多下载链接），然后按默认选项安装即可。msysgit的操作命令和Linux基本一致，很多命令是通用的，例如ls，mv，rm等；mygit安装完成后，在开始菜单里找到“Git”-&gt;“Git Bash”，蹦出一个类似命令行窗口的东西，就说明Git安装成功！（详情可参见 第1节 ） 1.3 申请GitHub账号 打开https://github.com/，自行申请账号； 1.4 安装HEXO 切换到命令行工具，CMD输入命令安装： npm install -g hexo 等待安装完成；不过国内NPM镜像速度极慢，可以安装淘宝的cnpm； npm install -g cnpm –registry=https://registry.npm.taobao.org 然后使用cnpm来下载HEXO，如下： cnpm install -g hexo 1.5 配置HEXO 切换CMD到你希望创建博客项目的目录，然后输入hexo init来初始化一个项目，如： cd c:/workspase/bloghexo init 继续输入命令： hexo generate 或者 hexo g 生成静态页面 1.6 启动本地服务 hexo server 可以看到提示Hexo已经运行在http://localhost:4000/上，我们用浏览器打开 http://localhost:4000/看看效果： 神奇的博客界面就出现了； 2、配合Github搭建个人博客2.1 登录Github创建一个项目 登录Github，点击上方的添加项目：我们来添加一个GIT版本仓，点击+号，选择“New repository”，如图： 打开创建对话框之后，输入repository名，*.github.io，星号代表你的用户名，记住结尾一定要用.github.io结尾，如果你输入的格式或者用户名不匹配，最后创建的网站可能加载不出css，js等资源，具体原因还没弄清，待以后验证，暂时就按照规范来，如图：其余的默认就好，点击“Create repository”来创建仓库；（我的由于已经创建同名的，所以弹出提示，请无视） 创建好之后进入创建好的界面，如下：由于我的已经上传过文件，所以你们是没有红框中的内容，不急，接下来我们来看怎么上传文件； 本地mygit还需要配置ssh秘钥，邮箱等才能和github进行上传，修改等操作；这一步如果没设置过，参见工具使用–第1节 git使用简记2.2 关联Github和HEXO 进入我们在 1.5 配置HEXO 创建的HEXO项目目录，打开根目录中的_config.yml文件（以记事本文件打开）；在文件最末尾添加如下三行：将其中的repo改为你自己repository地址，你的repository地址在github界面的这里获取，如图：点击“2”处就可以直接复制地址,最后添加的三条就是： 1234deploy: type: git repo: https://github.com/AmuUncle/AmuUncle.github.io.git branch: master 注意：每项的冒号后都要留一个英文的空格号； 在HEXO项目根目录中右击选择“Git Bash Here” 生成静态网站并同步到github执行下面两个命令： hexo g // 生成hexo d // 同步或者直接用：hexo d -g // 在同步前先生成网站 中间可能会让你输入github的账号密码，输入就好：运行结果如下：这样网站就同步到github中了；我们可以刷新github页面。可以看到已经有很多文件了： 2.3 让网站显示出来我们点击github界面上的Settings按钮，进入设置界面：往下拖动，找到“github pages”选项，点击“Launch Automatic page generator”按钮，开启github pages功能；这时我们就可已输入“https://AmuUncle.github.io”来打开我们创建的blog网站；如下：至此，我们已经成功将网站部署到GITHUB，并且是个人独立博客哦。。。 3、设置HEXO的主题这里网上很多教程，很简单，很多人推荐NEXT主题，我也用的是这款，功能很齐全，这里我就直接给教程链接了，很详细； NEXT主题官网，教程非常详细：http://theme-next.iissnan.com/getting-started.htmlHEXO主题类列表：https://hexo.io/themes/ 其他主题也差不多配置方法，自己研究吧。。 4、将域名和github博客地址关联（个人需求）4.1 购买域名我是在阿里云购买的.site域名,很便宜，一年才几块钱，有需要的可以去看看： https://wanwang.aliyun.com/domain/?spm=5176.8076989.763973.3.5a54fa45x7NU0Z 4.2 配置域名进入域名解析配置界面，添加一下三项：解析列表：| 方法记录类型 | 主机记录| 记录值 || ——– | ——– | —–: || CNAME | www | AmuUncle.github.io || A | @ | 192.30.252.154 || A | @ | 192.30.252.153 | 其中 192.30.252.153和 192.30.252.154 为github的IP地址；域名这边已经配置好，但还没结束，我们再来到HEXO博客的目录，进入source目录，新建一个CNAME文件，没有任何后缀名，编辑内容为：amuuncle.site 接下来输入： hexo d -g 重新生成同步网站到github，接下来就是见证奇迹的时候我们到浏览器输入我们的域名，就打开了我们的blog页面，如图（如果打不开，请等待10分钟，因为更改域名解析要十分钟后才能生效）最终效果图，完美，接下来我们就可以自由写个人微博，并且部署到github了，配置好域名之后，不注意根本发现不了你是在github上部署的网站哦。使用如下命令添加一篇博客，然后进入项目的source_posts目录找打创建的md文件，编辑此文件就是在写博客； hexo new post “工具使用–第2节 HEXO+GitHub 搭建个人博客” 对于md文件的编写，网上有很对教程，我使用的工具是：Haroopad，完全没费，可自行下载。记住写完之后还是要输入： hexo d -g 来重新生成同步网站到github； 最后，我的blog地址就是&gt;&gt;&gt;我的私人博客&lt;&lt;&lt;欢饮大家光临指教。]]></content>
      <categories>
        <category>GitHub</category>
      </categories>
      <tags>
        <tag>HEXO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python selenium 自动化查询上海公交卡余额，并邮件通知]]></title>
    <url>%2F2017%2F10%2F29%2Fpython-selenium-%E8%87%AA%E5%8A%A8%E5%8C%96%E6%9F%A5%E8%AF%A2%E4%B8%8A%E6%B5%B7%E5%85%AC%E4%BA%A4%E5%8D%A1%E4%BD%99%E9%A2%9D%EF%BC%8C%E5%B9%B6%E9%82%AE%E4%BB%B6%E9%80%9A%E7%9F%A5%2F</url>
    <content type="text"><![CDATA[python selenium 自动化查询上海公交卡余额，并邮件通知1、下载python安装。 https://www.python.org/downloads/release/python-351/2、安装selenium2.1、通过pip 安装 pip install selenium 2.2、通过下载包安装 ,直接下载selenium包： https://pypi.python.org/pypi/selenium 解压，cmd进入目录: python setup.py install 3 、 安装Chrome driver 下载地址：http://npm.taobao.org/mirrors/chromedriver 下载解压，将 chromedriver.exe 文件放到chrome的安装目录下…\Google\Chrome\Application\ ,然后设置path环境变量； 4、全部代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273 # coding = utf-8from selenium import webdriverfrom time import sleepimport smtplibimport tracebackfrom email.mime.text import MIMETextfrom email.mime.multipart import MIMEMultipartcardIDList = [u&quot;u54311******&quot;, u&quot;u728833******&quot;]def sendmail(subject,msg,toaddrs,fromaddr,smtpaddr,password): &apos;&apos;&apos; @subject:邮件主题 @msg:邮件内容 @toaddrs:收信人的邮箱地址 @fromaddr:发信人的邮箱地址 @smtpaddr:smtp服务地址，可以在邮箱看，比如163邮箱为smtp.163.com @password:发信人的邮箱密码 &apos;&apos;&apos; mail_msg = MIMEMultipart() mail_msg[&apos;Subject&apos;] = subject mail_msg[&apos;From&apos;] =fromaddr mail_msg[&apos;To&apos;] = &apos;,&apos;.join(toaddrs) mail_msg.attach(MIMEText(msg, &apos;html&apos;, &apos;utf-8&apos;)) try: s = smtplib.SMTP() s.connect(smtpaddr) #连接smtp服务器 s.login(fromaddr,password) #登录邮箱 s.sendmail(fromaddr, toaddrs, mail_msg.as_string()) #发送邮件 s.quit() except : print (&quot;Error: unable to send email&quot;) print (traceback.format_exc())def get_gj_info(cardID): for i in range(1, 10, 1): try: print(&quot;第%d次尝试。。。。&quot; % i) driver = webdriver.Chrome() print(&quot;###########&gt;&gt;&gt;&gt;&gt;&gt;&gt;开始打开上海交通网站&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;#########&quot;) driver.get(&apos;http://www.sptcc.com/&apos;) print(driver.title) print(&quot;网站打开成功&quot;) sleep(2) print(&quot;查询公交卡号:%s&quot; % cardID) driver.find_element_by_id(&quot;pL1i1&quot;).send_keys(cardID) driver.find_element_by_css_selector(&quot;a[class=\&quot;pL1b1\&quot;]&quot;).click() sleep(2) data = driver.find_element_by_css_selector(&quot;p[class=\&quot;amt\&quot;]&quot;).text print(&quot;公交卡 &#123;0&#125; &#123;1&#125; &quot;.format(cardID, data)) driver.quit() return &quot;公交卡 &#123;0&#125; &#123;1&#125; \n&quot;.format(cardID, data) break except: print(&quot;查询出错。。。，再次尝试。。。&quot;) print(&quot;##################&gt;&gt;&gt;&gt;&gt;&gt;&gt;退出查询&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;##############&quot;) return &quot;查询出错。。。&quot;if __name__ == &apos;__main__&apos;: fromaddr = &quot;*******@163.com&quot; smtpaddr = &quot;smtp.163.com&quot; # 163邮件smtp服务器地址 toaddrs = [&quot;*******@qq.com&quot;, &quot;*******@163.com&quot;] gj_info =&apos;&apos; for cardID in cardIDList: gj_info += get_gj_info(cardID) subject = gj_info password = &quot;*******&quot; msg = gj_info sendmail(subject,msg,toaddrs,fromaddr,smtpaddr,password)]]></content>
      <categories>
        <category>PYTHON实战</category>
      </categories>
      <tags>
        <tag>PYTHON</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[工具使用--第1节 git使用简记]]></title>
    <url>%2F2017%2F10%2F28%2F%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8-%E7%AC%AC1%E8%8A%82-git%E4%BD%BF%E7%94%A8%E7%AE%80%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[工具使用–第1节 git使用简记GIT （分布式版本控制系统） Git是一款免费、开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。 Git的读音为/gɪt/。 Git是一个开源的分布式版本控制系统，可以有效、高速的处理从很小到非常大的项目版本管理。 Git 是 Linus Torvalds 为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件。 Torvalds 开始着手开发 Git 是为了作为一种过渡方案来替代 BitKeeper，后者之前一直是 Linux 内核开发人员在全球使用的主要源代码工具。开放源码社区中的有些人觉得BitKeeper 的许可证并不适合开放源码社区的工作，因此 Torvalds 决定着手研究许可证更为灵活的版本控制系统。尽管最初 Git 的开发是为了辅助 Linux 内核开发的过程，但是我们已经发现在很多其他自由软件项目中也使用了 Git。例如 很多 Freedesktop 的项目迁移到了Git 上。 — 百度百科 1.安装git这里只说windows版本安装使用，Linux版本等以后再研究； 1.1 下载msysgitmsysgit是Windows版的Git，从https://git-for-windows.github.io下载（百度一下也有很多下载链接），然后按默认选项安装即可。**msysgit**的操作命令和Linux基本一致，很多命令是通用的，例如ls，mv，rm等；mygit安装完成后，在开始菜单里找到“Git”-&gt;“Git Bash”，蹦出一个类似命令行窗口的东西，就说明Git安装成功！ 2. 配置msysgit在桌面空白处右击，选择“Git Bash here”进入msysgit的控制台，输入一下两条命令，配置全局的用户名和邮箱：12$ git config --global user.name &quot;你的用户名&quot;$ git config --global user.email &quot;邮箱地址&quot; 你的用户名：可以随意设置，但要记住用户名邮箱地址：你的邮箱地址 3.创建代码仓3.1 进入你想建仓的目录在目录空白处右击选择“Git Bash here”进入msysgit的控制台，输入git init命令把这个目录变成Git可以管理的仓库： $ git init Initialized empty Git repository in C:/Users/Administrator/Desktop/usb_encryption_5.4.0/git_demo/.git/ git会在此目录创建.git目录，这是Git来跟踪管理版本库的，无需我们来改动， 4.版本控制我们现在在此目录下来创建一个readme.md文件，随意填写些内容，如下 4.1 查看版本状态 git status 4.2 添加到缓存区1git add readme.md 4.3 提交代码到版本仓1git commit -m &quot;Add readme&quot; -m 后面跟得是你提交的代码的描述，建议所有提交都应该添加描述。 暂时先记录这么多，下次再补充完整]]></content>
      <categories>
        <category>git教程</category>
      </categories>
      <tags>
        <tag>GIT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第10节 MFC菜单]]></title>
    <url>%2F2017%2F10%2F28%2F%E7%AC%AC10%E8%8A%82-MFC%E8%8F%9C%E5%8D%95%2F</url>
    <content type="text"><![CDATA[Windows编程基础–第10节 MFC菜单MFC菜单（CMenu）MFC菜单分为两类： 窗体菜单快捷菜单:又叫弹出菜单，或者上下文菜单 1、创建项目打开vs2010，创建一个基于对话框的项目，项目名“day10”,注意这次主框架中就不要勾选“系统菜单”和“关于框”了，如图：创建好后，删除自动生成的文本控件，如图： 2、创建系统菜单切换到资源视图，右击我们的项目“day10”，选择添加资源，出现如下界面： 选择“Menu”点击新建,然后就可以看到我们的项目中Menu目录，这里就存放菜单资源，展开后就可以看到，我们刚添加的菜单ID，双击打开；我们可以直接输入想要添加的菜单选项，如图：我们可以在资源视图右击菜单ID，然后选择属性，修改ID为IDR_MENU_SYSTEM; 3、显示系统菜单我们打开刚才创建的主窗口，右击打开属性，在属性列表找到MENU属性，下拉框选择刚才创建的IDR_MENU_SYSTEM菜单，如图所示：这时主窗口就和IDR_MENU_SYSTEM菜单关联起来了，运行看看效果： 4、创建菜单消息事件我们切换到我们创建的菜单界面，来实现菜单中保存选项的处理事件，在“保存”选项上右击，选择“添加事件处理函数”，如下：，出现如下添加事件界面：这里我们类列表中选择Cday10Dlg中创建操作函数，函数名修改为OnMenuSaveClick，点击“添加编辑”，添加处理函数； 12345void Cday10Dlg::OnMenuSaveClick()&#123; // TODO: 在此添加命令处理程序代码 AfxMessageBox(_T(&quot;文件已保存！&quot;)); &#125; 运行效果，点击“文件”-&gt;“保存”,此时就会弹窗提示“””文件已保存！”，如图所示： 5、创建快捷菜单切换资源视图，选择“Menu”点击“插入MENU”,自动打开；我们可以直接输入想要添加的菜单选项，如图：注意：快捷菜单中最上面的“快捷菜单”不会显示，名字可以随意。修改次menu的ID为IDR_MENU_QUICK； 6、显示快捷菜单我们打开刚才创建的主窗口，右击打开属性，在属性列表上方选择“消息”按钮，找到“WM_OnContextMenu”,选择add OnContextMenu方法，如图所示： 1234567891011void Cday10Dlg::OnContextMenu(CWnd* pWnd, CPoint point)&#123; // TODO: 在此处添加消息处理程序代码 CMenu menu; if(!menu.LoadMenu(IDR_MENU_QUICK)) &#123; return; &#125; CMenu* pMenu = menu.GetSubMenu(0); pMenu-&gt;TrackPopupMenu(TPM_LEFTALIGN|TPM_RIGHTBUTTON,point.x,point.y,pWnd);&#125; 这段代码的意思就是：先试图加载IDR_MENU_QUICK菜单，加载成功之后，将菜单显示在鼠标右击（TPM_RIGHTBUTTON），靠左方（TPM_LEFTALIGN）的位置；运行效果：可以看见，菜单已经显示出来； 7、创建菜单消息事件同步骤4，如图：编辑OnCopy函数，如下： 12345void Cday10Dlg::OnCopy()&#123; // TODO: 在此添加命令处理程序代码 AfxMessageBox(_T(&quot;文件已复制！&quot;)); &#125; 效果图： 项目源码可以访问我的码云]]></content>
      <categories>
        <category>MFC从入门到放弃</category>
      </categories>
      <tags>
        <tag>MFC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第9节 MFC对话框控件访问的七种方法（下）]]></title>
    <url>%2F2017%2F10%2F28%2F%E7%AC%AC9%E8%8A%82-MFC%E5%AF%B9%E8%AF%9D%E6%A1%86%E6%8E%A7%E4%BB%B6%E8%AE%BF%E9%97%AE%E7%9A%84%E4%B8%83%E7%A7%8D%E6%96%B9%E6%B3%95%EF%BC%88%E4%B8%8B%EF%BC%89%2F</url>
    <content type="text"><![CDATA[Windows编程基础–第9节 MFC对话框控件访问的七种方法（下）上节学习了MFC访问控件的三种方法，这节我们来学习剩下的四种方法，四种方法分别如下： 第四种把控件和整型变量相关联 第五种把控件和控件变量相关联 第六种 SendMessage方法 第七种SendDlgItemMessage方法 方法四 把控件和整型变量相关联1. 创建项目打开上节用到的day08项目，切换到资源视图，添加一个按钮“方法4”，我们在此按钮上实现方法四，如图所示： 2. 关联整型变量单击选择身高的输入框（IDC_EDIT_SG）,右击选择“添加变量”，打开如下界面：现在我们先选择类别为“value”，然后选择变量类型选择“int”，变量名“m_Height”，其余的默认就好，不过你也可以尝试修改一下最大值，最小值等。如图所示：现在我们切换到解决方案视图，可以看见，day08Dlg.h中已经增加了一个类变量，m_Height，day08Dlg.cpp中DoDataExchange也增加该变量的关联方法，将变量 m_Height和IDC_EDIT_SG的输入框关联起来，如下： 12345void Cday08Dlg::DoDataExchange(CDataExchange* pDX)&#123; CDialogEx::DoDataExchange(pDX); DDX_Text(pDX, IDC_EDIT_SG, m_Height);&#125; 还有day08Dlg的构造函数中也对m_Height进行了初始化，如下： 123456Cday08Dlg::Cday08Dlg(CWnd* pParent /*=NULL*/) : CDialogEx(Cday08Dlg::IDD, pParent) , m_Height(0)&#123; m_hIcon = AfxGetApp()-&gt;LoadIcon(IDR_MAINFRAME);&#125; 我们可以看到m_Height的初始化值为0，现在我们编译运行程序，可以看到身高输入框中的值就为0，如图：接下来我们分别关联IDC_EDIT_TZ和IDC_EDIT_BMI为变量int m_Weight,double m_BMI; 123int m_Height;int m_Weight;double m_BMI; 3.实现按钮事件现在m_Height ，m_Weight ，m_BMI 分别和界面上的三个输入框相关联，所以我们可以直接取它们的值就可以，也可以直接进行赋值，但这是会用下面这个方法: UpdateData(TRUE); //把控件的值关联到变量UpdateData(FALSE); //把变量的值关联到控件 12345678void Cday08Dlg::OnBnClickedButtonFunc4()&#123; // TODO: 在此添加控件通知处理程序代码 UpdateData(TRUE); //把控件的值关联到变量 double dHeight = m_Height / 100.00; m_BMI = m_Weight / (dHeight * dHeight ); UpdateData(FALSE); //把变量的值关联到控件&#125; 编译运行，这时就可以看到点击方法4之后，BMI值就计算出来了，如图： 方法五 把控件和控件变量相关联1. 添加“方法5”按钮如图： 1. 关联控件变量单击选择身高的输入框（IDC_EDIT_SG）,右击选择“添加变量”，打开如下界面： 现在我们先选择类别为“control”，变量名“m_edit_Height”，其余的默认就好，不过你也可以尝试修改一下最大值，最小值等。如图所示：接下来我们分别关联IDC_EDIT_TZ和IDC_EDIT_BMI为变量 CEdit m_edit_tz, CEdit m_edit_bmi;123CEdit m_edit_sg;CEdit m_edit_tz;CEdit m_edit_bmi; 3.实现按钮事件现在m_edit_sg，m_edit_tz，m_edit_bmi分别和界面上的三个输入框相关联，所以我们可以直接取它们的值就可以，也可以直接进行赋值，但这是会用下面这个方法: 12345678910111213141516void Cday08Dlg::OnBnClickedButtonFunc5()&#123; // TODO: 在此添加控件通知处理程序代码 TCHAR tcHeight[10], tcWeight[10] , tcBMI[10]; m_edit_sg.GetWindowText(tcHeight,10); m_edit_tz.GetWindowText(tcWeight,10); int nHeight = _ttoi(tcHeight); double dHeight = nHeight / 100.00; int nWeight = _ttoi(tcWeight); double bmi = nWeight/(dHeight * dHeight); char buf[28]; sprintf(buf, &quot;%.3f&quot;, bmi); m_edit_bmi.SetWindowText(buf);&#125; 方法六 SendMessage方法通过SendMessage方法发送WM_GETTEXT消息到控件所在窗口来获取控件文本值，同样发送WM_SETTEXT消息到控件所在窗口来设置控件文本值；12345678910111213141516void Cday08Dlg::OnBnClickedButtonFunc6()&#123; // TODO: 在此添加控件通知处理程序代码 TCHAR tcHeight[10], tcWeight[10] , tcBMI[10]; ::SendMessage(GetDlgItem(IDC_EDIT_SG)-&gt;m_hWnd,WM_GETTEXT,10,(LPARAM)tcHeight); ::SendMessage(GetDlgItem(IDC_EDIT_TZ)-&gt;m_hWnd,WM_GETTEXT,10,(LPARAM)tcWeight); int nHeight = _ttoi(tcHeight); double dHeight = nHeight / 100.00; int nWeight = _ttoi(tcWeight); double bmi = nWeight/(dHeight * dHeight); char buf[28]; sprintf(buf, &quot;%.3f&quot;, bmi); ::SendMessage(GetDlgItem(IDC_EDIT_BMI)-&gt;m_hWnd,WM_SETTEXT,10,(LPARAM)buf);&#125; 方法七 SendDlgItemMessage方法通过SendDlgItemMessage方法发送WM_GETTEXT消息到控件所在窗口来获取控件文本值，同样发送WM_SETTEXT消息到控件所在窗口来设置控件文本值；1234567891011121314151617void Cday08Dlg::OnBnClickedButtonFunc7()&#123; // TODO: 在此添加控件通知处理程序代码 TCHAR tcHeight[10], tcWeight[10] , tcBMI[10]; SendDlgItemMessage(IDC_EDIT_SG,WM_GETTEXT,10,(LPARAM)tcHeight); SendDlgItemMessage(IDC_EDIT_TZ,WM_GETTEXT,10,(LPARAM)tcWeight); int nHeight = _ttoi(tcHeight); double dHeight = nHeight / 100.00; int nWeight = _ttoi(tcWeight); double bmi = nWeight/(dHeight * dHeight); char buf[28]; sprintf(buf, &quot;%.3f&quot;, bmi); SendDlgItemMessage(IDC_EDIT_BMI,WM_SETTEXT,10,(LPARAM)buf);&#125; 总结，以上七种方法虽然结果相同，但是其内部机制是有所区别的，在我们将来的编程中要根据实际情况来选择合适的方法，最后，我们列举一下这七种方法：| 方法名 | 简介 || ——– | —–: || GetDlgItem() | 获取控件对象 || GetDlgItemText() | 获取对象文本 || GetDlgItemInt() | 获取对象整型值 || DDX_Text(pDX,IDC_EDIT_SG, m_Height); | 把控件和整型变量相关联 || DDX_Control(pDX,IDC_EDIT_BMI,m_edit_bmi); | 把控件和控件变量相关联 || SendMessage | 发送WM_GETTEXT消息到控件所在窗口来获取控件文本值 || SendDlgItemMessage | 发送WM_GETTEXT消息来获取控件文本值 | 项目源码可以访问我的码云]]></content>
      <categories>
        <category>MFC从入门到放弃</category>
      </categories>
      <tags>
        <tag>MFC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第8节 MFC对话框控件访问的七种方法（上）]]></title>
    <url>%2F2017%2F10%2F28%2F%E7%AC%AC8%E8%8A%82-MFC%E5%AF%B9%E8%AF%9D%E6%A1%86%E6%8E%A7%E4%BB%B6%E8%AE%BF%E9%97%AE%E7%9A%84%E4%B8%83%E7%A7%8D%E6%96%B9%E6%B3%95%EF%BC%88%E4%B8%8A%EF%BC%89%2F</url>
    <content type="text"><![CDATA[Windows编程基础–第8节 MFC对话框控件访问的七种方法（上）MFC对话框控件具有以下三种访问方式(当然还有很多别的访问方式，今天时间紧急，先学这三种)，分别是： 第一种GetDlgItem()-&gt;GetWindowText()GetDlgItem()-&gt;SetWindowText() 第二种GetDlgItemText() 第三种GetDlgItemInt()SetDlgItemInt() 1.新建一个对话框项目参见上节，我们这节采用VS2010编写一个身高体重计算器（BMI），参见 第二节； 2.布局编辑布局如下： EDIT名称 ID 身高 IDC_EDIT_SG 体重 IDC_EDIT_TZ BMI IDC_EDIT_BMI 3.实现方法双击确认按钮，编辑其点击消息处理函数； 1234567891011void Cday08Dlg::OnBnClickedOk()&#123; // TODO: 在此添加控件通知处理程序代码 int nHeight= GetDlgItemInt(IDC_EDIT_SG,NULL,TRUE); double dHeight = nHeight / 100.00; int nWeight = GetDlgItemInt(IDC_EDIT_TZ,NULL,TRUE); double bmi = nWeight/(dHeight*dHeight); char buf[28]; sprintf(buf, &quot;%.3f&quot;, bmi); SetDlgItemText(IDC_EDIT_BMI,buf);&#125; 这里可以看见使用到了GetDlgItemInt，这就是直接获取文本框的值，并返回为整形，然后用sprintf(buf, “%.3f”, bmi);将double类型值转换成字符串，并通过SetDlgItemText将字符串的值设置到ID为IDC_EDIT_BMI的文本框上； 4.编译运行估计很多人会像我一样，VS2010会报这样的错误：这是因为我们创建的项目的字符集为Unicode，不允许这样转换，这时我们只要将解决方案中右击项目名“day09”-&gt;“属性”-&gt;“配置属性”-&gt;”常规”-&gt;”字符集”-&gt;选择“使用多字节字符集”就好了，如下:这时就可以通过编译，运行结果如下： 5.其他方法再次编辑“确认”按钮的点击消息处理函数；第二种12345678910111213141516void Cday08Dlg::OnBnClickedOk()&#123; // TODO: 在此添加控件通知处理程序代码 TCHAR tcHeight[10], tcWeight[10]; GetDlgItem(IDC_EDIT_SG)-&gt;GetWindowText(tcHeight,10); GetDlgItem(IDC_EDIT_TZ)-&gt;GetWindowText(tcWeight,10); int nHeight = _ttoi(tcHeight); double dHeight = nHeight / 100.00; int nWeight = _ttoi(tcWeight); double bmi = nWeight/(dHeight * dHeight); char buf[28]; sprintf(buf, &quot;%.3f&quot;, bmi); GetDlgItem(IDC_EDIT_BMI)-&gt;SetWindowText(buf);&#125; 可以看见，这里用到了GetDlgItem(IDC_EDIT_SG)-&gt;GetWindowText(tcHeight,10)方法，这个方法的过程就是先通过GetDlgItem(IDC_EDIT_SG)获取到控件对象，然后调用控件的GetWindowText(tcHeight,10)方法来获取控件的显示文本； 第三种123456789101112131415void Cday08Dlg::OnBnClickedOk()&#123; TCHAR tcHeight[10], tcWeight[10] , tcBMI[10]; GetDlgItemText(IDC_EDIT_SG,tcHeight,10); GetDlgItemText(IDC_EDIT_TZ,tcWeight,10); int nHeight = _ttoi(tcHeight); double dHeight = nHeight / 100.00; int nWeight = _ttoi(tcWeight); double bmi = nWeight/(dHeight * dHeight); char buf[28]; sprintf(buf, &quot;%.3f&quot;, bmi); SetDlgItemText(IDC_EDIT_BMI,buf);&#125; 可以看见，这里直接用到了GetDlgItemText(IDC_EDIT_SG,tcHeight,10)方法，这个方法的过程就是先通过GetDlgItem(IDC_EDIT_SG)获取到控件对象，然后调用控件的GetWindowText(tcHeight,10)方法来设置控件的显示文本； 虽然上面三种方法最终结果是一样的，但是其本质还是有所区别的 项目源码可以访问我的码云]]></content>
      <categories>
        <category>MFC从入门到放弃</category>
      </categories>
      <tags>
        <tag>MFC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第7节 来吧，VS 2010]]></title>
    <url>%2F2017%2F10%2F28%2F%E7%AC%AC7%E8%8A%82-%E6%9D%A5%E5%90%A7%EF%BC%8CVS-2010%2F</url>
    <content type="text"><![CDATA[Windows编程基础–第7节 来吧，VS 2010VS 2010开发第一步 前面几节我们都是采用VC++ 6.0 作为IDE（集成开发环境），但是由于VC++ 6.0 已经过于老旧，目前大多数企业和个人都已经不再使用，而采用vs2005， vs2008， vs2010，vs2015作为MFC程序的开发环境，vs相对vc++6.0具有更友好的界面，及更强大的功能，采用vs开发MFC应用程序更加得心应手。 1、开始使用VS 20101.1 安装VS 2010参见百度百科 1.2 创建一个基于对话框项目执行“文件”-&gt;“新建”-&gt;“项目”，选择基于对话框的MFC程序，其他默认就好，基本上和VC++ 6.0 创建项目一模一样，如图所示： 1.3 创建一个字符统计窗口现在我们通过一个小例子来看看VS2010创建MFC程序有什么不同，我们来创建一个字符统计窗口，输入各种字符，最后统计出所有字符个数；设计界面如下，一个文本输入框，一个“统计”按钮，一个文本显示“字符个数”，直接在工具箱中拖动进来就OK，然后拖动大小适中就好，方法同VC++ 6.0 没有区别，可以参考上几节内容。注意: 若是右边没有工具箱选项卡，可以通过“视图”-&gt;“工具箱”打开。编译运行，效果图： 1.3 创建一个字符统计窗口双击“统计”按钮，编辑按钮的点击处理函数，我们来分析一下： 获取输入框中文本 获取输入框中文本的字符个数 将字符个数显示到静态文本上所以处理函数如下： 12345678910void Cday07Dlg::OnBnClickedButtonCount()&#123; // TODO: 在此添加控件通知处理程序代码 CString strInput,strOutput; GetDlgItemText(IDC_EDIT_TEXT,strInput); int nCount = strInput.GetLength(); strOutput.Format(_T(&quot;字符个数：%d &quot;),nCount); SetDlgItemText(IDC_STATIC_COUNT,strOutput);&#125; 1.4 编译运行运行结果图：这是我们发现当我们输入完成是，输入“回车”时，程序就会直接结束，那么我们修改输入框的属性值“Want Return”来允许输入框来接收回车，如图其实这是我们可以发现现在文本框是只能输入一行，显然不够美观，那么我们再修改一下输入框属性： Multiline：允许多行 Horizontal Scroll：水平滚动条 Vertical Scroll:垂直滚动条 再次编译运行：现在文本框现在可以输入多行，并且可以任意回车了。有人可能和我一样，发现程序没有关闭按钮，那是因为我在创建的时候取消了系统菜单，我们可以选定对话框主界面，选择属性-&gt;system menu-&gt;TRUE:这是关闭按钮就出现了，可以正常关闭了。 2、初探VS中消息映射机制2.1 创建EDIT的消息处理函数单击选定输入框，右击选择“添加事件处理程序”，这是可以很直观的看见EDIT的消息列表和要添加到的类，以及添加的处理函数名，现在我们来添加一个EN_CHANGE的消息处理函数，如图所示：单击“添加编辑”来编辑消息处理函数，代码如下： 12345678910111213141516void Cday07Dlg::OnEnChangeEditText()&#123; // TODO: 如果该控件是 RICHEDIT 控件，它将不 // 发送此通知，除非重写 CDialogEx::OnInitDialog() // 函数并调用 CRichEditCtrl().SetEventMask()， // 同时将 ENM_CHANGE 标志“或”运算到掩码中。 // TODO: 在此添加控件通知处理程序代码 CString strInput,strOutput; GetDlgItemText(IDC_EDIT_TEXT,strInput); int nCount = strInput.GetLength(); strOutput.Format(_T(&quot;字符个数：%d &quot;),nCount); SetDlgItemText(IDC_STATIC_COUNT,strOutput);&#125; 2.2 编译运行这是我们可以发现我们在输入框中输入字符时，下方的字符统计数会实时显示，这就是输入文本时，EDIT的EN_CHANGE消息被触发，从而触发其消息处理函数OnEnChangeEditText，导致字符统计数实时更新，效果图如下： 2.3 MFC消息映射机制流程12345678st=&gt;start: Startop=&gt;operation: 输入框文本变化op2=&gt;operation: 触发EN_CHANGE消息op3=&gt;operation: 调用EN_CHANGE的处理函数OnEnChangeEditTextop4=&gt;operation: 将输入框字符数返回到界面e=&gt;endst-&gt;op-&gt;op2-&gt;op3-&gt;op4-&gt;e 项目源码可以访问我的码云]]></content>
      <categories>
        <category>MFC从入门到放弃</category>
      </categories>
      <tags>
        <tag>MFC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第6节 VC++6.0控件说明]]></title>
    <url>%2F2017%2F10%2F28%2F%E7%AC%AC6%E8%8A%82-VC-6-0%E6%8E%A7%E4%BB%B6%E8%AF%B4%E6%98%8E%2F</url>
    <content type="text"><![CDATA[Windows编程基础–第6节 VC++6.0控件说明VC++6.0控件工具箱 控件说明 2 图形控件（picture）：常用于显示位图（Bitmap）和图标（Icon） 3 静态文本（Static Text）：用来在指定的位置显示特定的字符串，一般用来标识附近另一个控件的内容。显示在静态文本控件中的字符串一般不再改变，但是在需要的时候，也可以通过调用相应的函数来进行设置。MFC提供了CStatic类支持静态控件。 4 编辑框（Edit Box）：用来接收用户输入的字符串。通过选择编辑框的选项，编辑框可以接收字符串、数字、密码等；编辑框还可以设置成接收多行字符串的模式；可以自动进行大小写转换。编辑框可能向其父窗口发送多种控件通知，如果用户需要，可以对这些控件通知进行处理。MFC提供了CEdit类支持编辑框控件。 5 组成框（Group Box）：用来包围具有逻辑关系的一组控件，在这些控件的周围加上边界和标题。需注意的是，组成框仅仅是在视觉效果上对控件进行“成组”，真正的“成组”工作还需要另外一些工作。 6 按钮（Button）：用来接收用户的命令，应用程序在接收到用户命令后，通常需要进行一些后台工作。按钮可以响应单击或双击动作，在按钮接收到鼠标动作后，向其父窗口发送相应的控件通知，用户可以对这些控件通知进行消息映射，从而进行相应的处理。在一个对话框中，可以定义一个默认按钮，这只要选中按钮属性中的“Default”选项。如果在对话框活动的时候按下了Enter键，则等同于单击了默认按钮。MFC提供了CButton类支持按钮控件。 7 复选框（Check Box）：用来显示某种可能的选择，该项选择是独立的，用户可以选中或取消该选项。在选项被选中的时候核选标记出现，选项被取消时核选标记消失。MFC中由CButton类对核选框进行支持，用户可以通过SetCheck()函数和GetCheck()函数设置或获取核选框当前的状态。 8 单选按钮（Radio Button）：用来选择某种可能的选择，与核选框不同，该选项不是独立的。一般是几个单选按钮组成一组，同组中的单选按钮可以有也只能有一个按钮被选中。MFC同样使用CButton类对单选按钮控件进行支持，SetCheck()函数和GetCheck()函数对单选按钮也是适用的。 9 组合框（Combo Box）：列表框和编辑框的组合，用户除了可以在列表中对已经存在的选项进行选择外，还可以输入新的选择。MFC提供了CComboBox类对组合框控件进行支持。 10 列表框（List Box）：用来选择一系列的可能选择，用户通过滚动条可以在这些选择中浏览。在列表框中，可以进行单项选择，也可以进行多项选择，这取决于用户在控件属性对话框中的设置。MFC提供了CListBox类对列表框控件进行支持。 11、12 滚动条（Scroll Bar）：这包括水平滚动条和垂直滚动条，除了在视觉效果上的方向不同外，水平滚动条在被滚动时发生WM_HSCROLL消息，而垂直滚动条在被滚动时发送WM_VSCROLL消息。MFC提供了CScrollBar进行支持。 13 微调按钮（Spin Button）：包括一对紧靠在一起的上下箭头，使用微调按钮可以增大或者缩小某个特定的数值。微调按钮往往都需要一个“伙伴”控件，这通常都是一个编辑框。当微调按钮的向上箭头被单击时，编辑框中的数字就增大；反之则减小。MFC提供了CPinButtonCtrl类进行支持。 14 进度条（Progress）：在进行一项需要占有较长时间的操作时来反应当前的进度。当操作的进度不断前进时，进度条就用特色颜色填充进度条框。用户可以设定进度条的范围和当前位置。MFC提供了CProgressCtrl类进行支持。 15 滑块控件（Slider）：通常用来在程序中接受一系列离散的数值。用户可以设置滑块控件的取值范围，并可以为控件加上刻度标记以显示特定位置的含义。MFC提供了CSliderCtrl类进行支持。 16 热键控制（Hot Key）：热键控件看起来就像一个编辑框，但是在热键控件中能够立刻反应用户刚刚按下的键组合，这在设置程序的热键时特别有用。热键控件只是在“视觉”上显示了按键组合，设置热键的工作还需要用户添加代码完成。MFC提供了CHotKey类进行支持。 17 列表控制（List Control）：按一定的排列顺序显示一系列带图标的字符串，列表控件提供了四种显示模式：大图标、小图标、列表和详细信息。用户可以向列表控件中添加新的项，也可以控制列表控件的显示模式。MFC提供了CListCtrl类进行支持。 18 树形控件（Tree Control）：用来显示一系列项目的层次关系，最典型的例子是显示磁盘上的文件与文件夹。如果有子项目的话，单击树形控件中的项目可以展开或者收缩其子项目。MFC提供了CTreeCtrl类进行支持。 19 属性表控件（Tab Control）：用来包含大量的控件，可以满足用户显示或者获取大量数据的要求。每个属性表又分为好几个属性页，这些属性页由各自的标签进行区分，这些属性页中都可以包容其他控件。在显示属性表的时候，一次只能够显示一个属性页的全部内容，同时显示其他属性页的标签，用户通过单击标签打开相应的属性页。MFC提供了CTabCtrl类进行支持。 20 动画控件（Animation）：用来播放一段AVI格式的视频剪辑。用户可以控制视频剪辑的播放、停止和定位，但也仅限于这些功能。动画控件设置不能播放音频剪辑，如果用户需要更高层次的视频或者音频的支持，请选用MCIWnd控件。MFC提供了CAnimateCtrl类对动画控件进行支持。 21 高级编辑框（Rich Edit）：编辑控件功能的扩展。在高级编辑框中，除了简单的输入和编辑字符串外，用户还可以为字符或段落指定特定的格式，用户甚至还可以向高级编辑框中插入OLE项。高级编辑框基本上实现了一个带格式的文本编辑器功能，而只需要用户添加少量的接口。MFC提供了CRichEditCtrl类进行支持。 22 日历控件（Month Calender）：看似与真正的日历类似，操作也类似，直观的为用户提供了观察和显示当前日期的途径。MFC提供了CMonthCalCtrl类进行支持。 23 日期/时间选择器（Date Time Picker）：向用户提供了一种直观的选择日期和时间的方法、日期/时间选择器在外观上类似于一个组合框，但是当用户单击下拉箭头时就会展开一个日历控件供用户选择，而一旦用户做出了选择，日期/时间选择器会自动显示新的日期/时间。MFC提供了CDateTimeCtrl类进行支持。 24 IP地址控件（IP Adress）:IP地址控件用来输入和编辑IP地址。该控件外观类似于一个编辑框，但是可以自动对输入的字符按3个一组进行区分和加间隔圆点。IP地址控件为开发支持Internet技术的程序提供了方便。MFC提供了CIPAddressCtrl类进行支持。 26 扩展组合框（Extended Combo Box）：在普通组合框的基础上还支持图像列表。即，可以在组合框中显示特定的图标表示相应的选择，而不仅仅是显示文本。MFC提供了CComboBoxEx类进行支持。 所有控件的公共属性 ID：控件的资源标识。Visiable：控件是否可见。Disabled：控件是否被禁止、被禁止的控件无法接受键盘和鼠标输入。Group：是否从这个空间开始一个新组。Tab stop：在程序中是否可以用【Tab】键切换到这个控件。Help ID：是否给控件分配一个帮助标识，帮助标识基于控件本身的资源标识。Client edge：给控件增加一个凹陷的边界，使整个控件看起来像是凹下去的一样。Static edge：给控件增加一个边界。Modal frame：给控件增加一个3维的框架，与Client edge相反，它是凸出来的。Transparent：拥有此属性的窗口是透明的，它下面的窗口不会被它遮掩住。Accept files：拥有此属性的窗口可以接收拖放文件，如果一个文件被拖动到这个控件上面，控件会收到WM_DROPFILES消息。No parent notify：表示控件不向其父窗口发送WM_PARENTNOTIFY消息。Right aligned text：表示文本右对齐。 以上属性可通过控件的属性对话框进行设置，在属性对话框中按【F1】键可以查看属性的帮助信息。每一种控件都由一个MFC控件类来管理，当通过资源编辑器在对话框上添加一个控件时 ，visualC++会自动为控件类生成一个实例，即对象，并调用构造函数，当对话框关闭时，其各个子控件对象被自动销毁。也可以不使用资源编辑器，自己在程序中写代码创建、显示控件并设置控件的属性。所有的控件类都继承自CWnd，控件的某些操作和属性设置需要用到CWnd本身的成员函数，CWnd某些函数经常用来操纵控件和设置控件属性。 SetWindowText：设置控件上要显示的标题文本，即用来设置控件的caption属性GetWindowText：得到控件的标题文本EnableWindow：设置控件的Disabled属性，即社会自控件是否可以接收键盘和鼠标的输入SetWindowPos：改变窗口的大小、位置和Z轴次序。 MoveWindow：改变窗口的大小和位置GetWindowRec：得到窗口的大小、位置（信息存放在一个矩形结构中）。GetClientRect：得到窗口客户区的大小（信息存放在一个矩形结构中 ） ShowWindow：设置窗口的可见性（即窗口是否可见）SetWindowText/GetWindowText还可以用来设置/得到对话框的标题文本。 转载Button 按钮窗口（控件）在MFC中使用CButton表示，CButton包含了三种样式的按钮，Push Button，Check Box，Radio Box。所以在利用CButton对象生成按钮窗口时需要指明按钮的风格。 创建按钮：BOOL CButton::Create( LPCTSTR lpszCaption, DWORD dwStyle, const RECT&amp; rect, CWnd* pParentWnd, UINT nID );其中lpszCaption是按钮上显示的文字，dwStyle为按钮风格，除了Windows风格可以使用外（如 WS_CHILD|WS_VISUBLE|WS_BORDER）还有按钮专用的一些风格。 · BS_AUTOCHECKBOX 检查框，按钮的状态会自动改变 Same as a check box, except that a check mark appears in the check box when the user selects the box; the check mark disappears the next time the user selects the box. · BS_AUTORADIOBUTTON 圆形选择按钮，按钮的状态会自动改变 Same as a radio button, except that when the user selects it, the button automatically highlights itself and removes the selection from any other radio buttons with the same style in the same group. · BS_AUTO3STATE 允许按钮有三种状态即：选中，未选中，未定 Same as a three-state check box, except that the box changes its state when the user selects it. · BS_CHECKBOX 检查框 Creates a small square that has text displayed to its right (unless this style is combined with the BS_LEFTTEXT style). · BS_DEFPUSHBUTTON 默认普通按钮 Creates a button that has a heavy black border. The user can select this button by pressing the ENTER key. This style enables the user to quickly select the most likely option (the default option). · BS_LEFTTEXT 左对齐文字 When combined with a radio-button or check-box style, the text appears on the left side of the radio button or check box. · BS_OWNERDRAW 自绘按钮 Creates an owner-drawn button. The framework calls the DrawItem member function when a visual aspect of the button has changed. This style must be set when using the CBitmapButton class. · BS_PUSHBUTTON 普通按钮 Creates a pushbutton that posts a WM_COMMAND message to the owner window when the user selects the button. · BS_RADIOBUTTON 圆形选择按钮 Creates a small circle that has text displayed to its right (unless this style is combined with the BS_LEFTTEXT style). Radio buttons are usually used in groups of related but mutually exclusive choices. · BS_3STATE 允许按钮有三种状态即：选中，未选中，未定 Same as a check box, except that the box can be dimmed as well as checked. The dimmed state typically is used to show that a check box has been disabled. rect为窗口所占据的矩形区域，pParentWnd为父窗口指针，nID为该窗口的ID值。 获取/改变按钮状态：对于检查按钮和圆形按钮可能有两种状态，选中和未选中，如果设置了BS_3STATE或BS_AUTO3STATE风格就可能出现第三种状态：未定，这时按钮显示灰色。通过调用int CButton::GetCheck( ) 得到当前是否被选中，返回0：未选中，1：选中，2：未定。调用void CButton::SetCheck( int nCheck );设置当前选中状态。 处理按钮消息：要处理按钮消息需要在父窗口中进行消息映射，映射宏为ON_BN_CLICKED( id, memberFxn )id为按钮的ID值，就是创建时指定的nID值。处理函数原型为afx_msg void memberFxn( ); Static Box 静态文本控件的功能比较简单，可作为显示字符串，图标，位图用。创建一个窗口可以使用成员函数： BOOL CStatic::Create( LPCTSTR lpszText, DWORD dwStyle, const RECT&amp; rect, CWnd* pParentWnd, UINT nID = 0xffff );其中dwStyle将指明该窗口的风格，除了子窗口常用的风格WS_CHILD,WS_VISIBLE外，你可以针对静态控件指明专门的风格。 · SS_CENTER,SS_LEFT,SS_RIGHT 指明字符显示的对齐方式。 · SS_GRAYRECT 显示一个灰色的矩形 · SS_NOPREFIX 如果指明该风格，对于字符&amp;将直接显示，否则&amp;将作为转义符，&amp;将不显示而在其后的字符将有下划线，如果需要直接显示&amp;必须使用&amp;&amp;表示。 · SS_BITMAP 显示位图 · SS_ICON 显示图标 · SS_CENTERIMAGE 图象居中显示 控制显示的文本利用成员函数SetWindowText/GetWindowText用于设置/得到当前显示的文本。 控制显示的图标利用成员函数SetIcon/GetIcon用于设置/得到当前显示的图标。 控制显示的位图利用成员函数SetBitmap/GetBitmap用于设置/得到当前显示的位图。下面一段代码演示如何创建一个显示位图的静态窗口并设置位图 1CStatic* pstaDis=new CStatic; pstaDis-&gt;Create(&quot;&quot;,WS_CHILD|WS_VISIBLE|SS_BITMAP|SSCENTERIMAGE, CRect(0,0,40,40),pWnd,1); CBitmap bmpLoad; bmpLoad.LoadBitmap(IDB_TEST); pstaDis-&gt;SetBitmap(bmpLoad.Detach()); Edit Box Edit窗口是用来接收用户输入最常用的一个控件。创建一个输入窗口可以使用成员函数：BOOL CEdit::Create( LPCTSTR lpszText, DWORD dwStyle, const RECT&amp; rect, CWnd* pParentWnd, UINT nID = 0xffff );其中dwStyle将指明该窗口的风格，除了子窗口常用的风格WS_CHILD,WS_VISIBLE外，你可以针对输入控件指明专门的风格。 · ES_AUTOHSCROLL,ES_AUTOVSCROLL 指明输入文字超出显示范围时自动滚动。 · ES_CENTER,ES_LEFT,ES_RIGHT 指定对齐方式 · ES_MULTILINE 是否允许多行输入 · ES_PASSWORD 是否为密码输入框，如果指明该风格则输入的文字显示为* · ES_READONLY 是否为只读 · ES_UPPERCASE,ES_LOWERCASE 显示大写/小写字符 控制显示的文本利用成员函数SetWindowText/GetWindowText用于设置/得到当前显示的文本。 通过GetLimitText/SetLimitText可以得到/设置在输入框中输入的字符数量。 由于在输入时用户可能选择某一段文本，所以通过void CEdit::GetSel( int&amp; nStartChar, int&amp; nEndChar )得到用户选择的字符范围，通过调用void CEdit::SetSel( int nStartChar, int nEndChar, BOOL bNoScroll = FALSE )可以设置当前选择的文本范围，如果指定nStartChar=0 nEndChar=-1则表示选中所有的文本。void ReplaceSel( LPCTSTR lpszNewText, BOOL bCanUndo = FALSE )可以将选中的文本替换为指定的文字。 此外输入框还有一些和剪贴板有关的功能，void Clear( );删除选中的文本，void Copy( );可将选中的文本送入剪贴板，void Paste( );将剪贴板中内容插入到当前输入框中光标位置，void Cut( );相当于Copy和Clear结合使用。 最后介绍一下输入框几种常用的消息映射宏： · ON_EN_CHANGE 输入框中文字更新后产生 · ON_EN_ERRSPACE 输入框无法分配内存时产生 · ON_EN_KILLFOCUS / ON_EN_SETFOCUS 在输入框失去/得到输入焦点时产生 使用以上几种消息映射的方法为定义原型如：afx_msg void memberFxn( );的函数，并且定义形式如ON_Notification( id, memberFxn )的消息映射。如果在对话框中使用输入框，Class Wizard会自动列出相关的消息，并能自动产生消息映射代码。 Scroll Bar Scroll Bar一般不会单独使用，因为SpinCtrl可以取代滚动条的一部分作用，但是如果你需要自己生成派生窗口，滚动条还是会派上一些用场。创建一个滚动条可以使用成员函数： ：BOOL CEdit::Create( LPCTSTR lpszText, DWORD dwStyle, const RECT&amp; rect, CWnd* pParentWnd, UINT nID = 0xffff );其中dwStyle将指明该窗口的风格，除了子窗口常用的风格WS_CHILD,WS_VISIBLE外，你可以针对滚动条指明专门的风格。 · SBS_VERT 风格将创建一个垂直的滚动条。 · SBS_HORZ 风格将创建一个水平的滚动条。 在创建滚动条后需要调用void SetScrollRange( int nMinPos, int nMaxPos, BOOL bRedraw = TRUE )设置滚动范围，int GetScrollPos( )/int SetScrollPos( )用来得到和设置当前滚动条的位置。 void ShowScrollBar( BOOL bShow = TRUE );用来显示/隐藏滚动条。 BOOL EnableScrollBar( UINT nArrowFlags = ESB_ENABLE_BOTH )用来设置滚动条上箭头是否为允许状态。nArrowFlags可取以下值： · ESB_ENABLE_BOTH 两个箭头都为允许状态 · ESB_DISABLE_LTUP 上/左箭头为禁止状态 · ESB_DISABLE_RTDN 下/右箭头为禁止状态 · ESB_DISABLE_BOTH 两个箭头都为禁止状态 如果需要在滚动条位置被改变时得到通知，需要在父窗口中定义对消息WM_VSCROLL/WM_HSCROLL的映射。方法为在父窗口类中重载afx_msg void OnVScroll( UINT nSBCode, UINT nPos, CScrollBar pScrollBar )/afx_msg void OnHScroll( UINT nSBCode, UINT nPos, CScrollBar pScrollBar )所使用的消息映射宏为：ON_WM_VSCROLL( ),ON_WM_HSCROLL( )，在映射宏中不需要指明滚动条的ID，因为所有滚动条的滚动消息都由同样的函数处理。在OnHScroll/OnVScroll的第三个参数会指明当前滚动条的指针。第一个参数表示滚动条上发生的动作，可取以下值： · SB_TOP/SB_BOTTOM 已滚动到顶/底部 · SB_LINEUP/SB_LINEDOWN 向上/下滚动一行 · SB_PAGEDOWN/SB_PAGEUP 向上/下滚动一页 · SB_THUMBPOSITION/SB_THUMBTRACK 滚动条拖动到某一位置，参数nPos指明当前位置（参数&gt;nPos在其它的情况下是无效的） · SB_ENDSCROLL 滚动条拖动完成（用户松开鼠标） List Box/Check List Box ListBox窗口用来列出一系列的文本，每条文本占一行。创建一个列表窗口可以使用成员函数：BOOL CListBox::Create( LPCTSTR lpszText, DWORD dwStyle, const RECT&amp; rect, CWnd* pParentWnd, UINT nID = 0xffff );其中dwStyle将指明该窗口的风格，除了子窗口常用的风格WS_CHILD,WS_VISIBLE外，你可以针对列表控件指明专门的风格。 · LBS_MULTIPLESEL 指明列表框可以同时选择多行 · LBS_EXTENDEDSEL 可以通过按下Shift/Ctrl键选择多行 · LBS_SORT 所有的行按照字母顺序进行排序 在列表框生成后需要向其中加入或是删除行，可以利用： int AddString( LPCTSTR lpszItem )添加行， intDeleteString( UINT nIndex )删除指定行， int InsertString( int nIndex,LPCTSTR lpszItem )将行插入到指定位置。 void ResetContent( )可以删除列表框中所有行。通过调用int GetCount( )得到当前列表框中行的数量。 如果需要得到/设置当前被选中的行，可以调用int GetCurSel( )/int SetCurSel(intiIndex)。如果你指明了选择多行的风格，你就需要先调用int GetSelCount( )得到被选中的行的数量，然后intGetSelItems( int nMaxItems, LPINT rgIndex)得到所有选中的行，参数rgIndex为存放被选中行的数组。通过调用int GetLBText( int nIndex, LPTSTRlpszText )得到列表框内指定行的字符串。 此外通过调用int FindString( int nStartAfter, LPCTSTR lpszItem)可以在当前所有行中查找指定的字符传的位置，nStartAfter指明从那一行开始进行查找。 int SelectString( intnStartAfter, LPCTSTR lpszItem )可以选中包含指定字符串的行。 在MFC4.2版本中添加了CCheckListBox类，该类是由CListBox派生并拥有CListBox的所有功能，不同的是可以在每行前加上一个检查框。必须注意的是在创建时必须指明LBS_OWNERDRAWFIXED或LBS_OWNERDRAWVARIABLE风格。 通过void SetCheckStyle( UINT nStyle )/UINT GetCheckStyle()可以设置/得到检查框的风格，关于检查框风格可以参考4.1 Button中介绍。通过void SetCheck( int nIndex,int nCheck )/int GetCheck( int nIndex )可以设置和得到某行的检查状态，关于检查框状态可以参考4.1Button中介绍。 最后介绍一下列表框几种常用的消息映射宏： · ON_LBN_DBLCLK 鼠标双击 · ON_EN_ERRSPACE 输入框无法分配内存时产生 · ON_EN_KILLFOCUS / ON_EN_SETFOCUS 在输入框失去/得到输入焦点时产生 · ON_LBN_SELCHANGE 选择的行发生改变 使用以上几种消息映射的方法为定义原型如：afx_msg void memberFxn();的函数，并且定义形式如ON_Notification( id, memberFxn )的消息映射。如果在对话框中使用列表框，ClassWizard会自动列出相关的消息，并能自动产生消息映射代码。 Combo Box/Combo Box Ex 组合窗口是由一个输入框和一个列表框组成。创建一个组合窗口可以使用成员函数： BOOL CListBox::Create( LPCTSTRlpszText, DWORD dwStyle, const RECT&amp; rect, CWnd* pParentWnd, UINT nID= 0xffff ); 其中dwStyle将指明该窗口的风格，除了子窗口常用的风格WS_CHILD,WS_VISIBLE外，你可以针对列表控件指明专门的风格。 · CBS_DROPDOWN 下拉式组合框 · CBS_DROPDOWNLIST 下拉式组合框，但是输入框内不能进行输入 · CBS_SIMPLE 输入框和列表框同时被显示 · LBS_SORT 所有的行按照字母顺序进行排序 由于组合框内包含了列表框，所以列表框的功能都能够使用，如可以利用： int AddString( LPCTSTR lpszItem)添加行， int DeleteString( UINT nIndex )删除指定行， int InsertString( intnIndex, LPCTSTR lpszItem )将行插入到指定位置。 void ResetContent( )可以删除列表框中所有行。通过调用int GetCount( )得到当前列表框中行的数量。 如果需要得到/设置当前被选中的行的位置，可以调用int GetCurSel( )/int SetCurSel(intiIndex)。通过调用int GetLBText( int nIndex, LPTSTR lpszText )得到列表框内指定行的字符串。 此外通过调用int FindString( int nStartAfter, LPCTSTR lpszItem)可以在当前所有行中查找指定的字符传的位置，nStartAfter指明从那一行开始进行查找。 int SelectString( intnStartAfter, LPCTSTR lpszItem )可以选中包含指定字符串的行。 此外输入框的功能都能够使用，如可以利用： DWORD GetEditSel( ) /BOOL SetEditSel( intnStartChar, int nEndChar )得到或设置输入框中被选中的字符位置。 BOOL LimitText( intnMaxChars )设置输入框中可输入的最大字符数。 输入框的剪贴板功能Copy,Clear,Cut,Paste动可以使用。 最后介绍一下列表框几种常用的消息映射宏： · ON_CBN_DBLCLK 鼠标双击 · ON_CBN_DROPDOWN 列表框被弹出 · ON_CBN_KILLFOCUS / ON_CBN_SETFOCUS 在输入框失去/得到输入焦点时产生 · ON_CBN_SELCHANGE 列表框中选择的行发生改变 · ON_CBN_EDITUPDATE 输入框中内容被更新 使用以上几种消息映射的方法为定义原型如：afx_msg void memberFxn();的函数，并且定义形式如ON_Notification( id, memberFxn )的消息映射。如果在对话框中使用组合框，ClassWizard会自动列出相关的消息，并能自动产生消息映射代码。 Tree Ctrl 树形控件TreeCtrl和下节要讲的列表控件 ListCtrl在系统中大量被使用，例如Windows资源管理器就是一个典型的例子。 树形控件可以用于树形的结构，其中有一个根接点(Root)然后下面有许多子结点，而每个子结点上有允许有一个或多个或没有子结点。MFC中使用CTreeCtrl类来封装树形控件的各种操作。通过调用BOOL Create( DWORD dwStyle, const RECT&amp; rect, CWnd* pParentWnd, UINTnID );创建一个窗口，dwStyle中可以使用以下一些树形控件的专用风格： · TVS_HASLINES 在父/子结点之间绘制连线 · TVS_LINESATROOT 在根/子结点之间绘制连线 · TVS_HASBUTTONS 在每一个结点前添加一个按钮，用于表示当前结点是否已被展开 · TVS_EDITLABELS 结点的显示字符可以被编辑 · TVS_SHOWSELALWAYS 在失去焦点时也显示当前选中的结点 · TVS_DISABLEDRAGDROP 不允许Drag/Drop · TVS_NOTOOLTIPS 不使用ToolTip显示结点的显示字符 在树形控件中每一个结点都有一个句柄（HTREEITEM），同时添加结点时必须提供的参数是该结点的父结点句柄，（其中根Root结点只有一个，既不可以添加也不可以删除）利用HTREEITEM InsertItem( LPCTSTR lpszItem, HTREEITEM hParent = TVI_ROOT,HTREEITEM hInsertAfter = TVI_LAST);可以添加一个结点，pszItem为显示的字符，hParent代表父结点的句柄，当前添加的结点会排在hInsertAfter表示的结点的后面，返回值为当前创建的结点的句柄。下面的代码会建立一个如下形式的树形结构： +— Parent1 +— Child1_1 +— Child1_2 +— Child1_3 +— Parent2 +— Parent3 /假设m_tree为一个CTreeCtrl对象，而且该窗口已经创建/ HTREEITEM hItem,hSubItem; hItem = m_tree.InsertItem(“Parent1”,TVI_ROOT);在根结点上添加Parent1 hSubItem = m_tree.InsertItem(“Child1_1”,hItem);//在Parent1上添加一个子结点 hSubItem =m_tree.InsertItem(“Child1_2”,hItem,hSubItem);//在Parent1上添加一个子结点，排在Child1_1后面 hSubItem =m_tree.InsertItem(“Child1_3”,hItem,hSubItem); hItem =m_tree.InsertItem(“Parent2”,TVI_ROOT,hItem); hItem =m_tree.InsertItem(“Parent3”,TVI_ROOT,hItem); 如果你希望在每个结点前添加一个小图标，就必需先调用CImageList SetImageList( CImageList pImageList, int nImageListType);指明当前所使用的ImageList，nImageListType为TVSIL_NORMAL。在调用完成后控件中使用图片以设置的ImageList中图片为准。然后调用 HTREEITEM InsertItem( LPCTSTR lpszItem, intnImage, int nSelectedImage, HTREEITEM hParent = TVI_ROOT, HTREEITEMhInsertAfter =TVI_LAST);添加结点，nImage为结点没被选中时所使用图片序号，nSelectedImage为结点被选中时所使用图片序号。下面的代码演示了ImageList的设置。 /m_list 为CImageList对象 IDB_TREE 为16(164)的位图，每个图片为1616共4个图标*/m_list.Create(IDB_TREE,16,4,RGB(0,0,0));m_tree.SetImageList(&amp;m_list,TVSIL_NORMAL);m_tree.InsertItem(“Parent1”,0,1); //添加，选中时显示图标1，未选中时显示图标0 此外CTreeCtrl还提供了一些函数用于得到/修改控件的状态。 HTREEITEM GetSelectedItem();将返回当前选中的结点的句柄。BOOL SelectItem( HTREEITEM hItem );将选中指明结点。 BOOLGetItemImage( HTREEITEM hItem, int&amp; nImage, int&amp; nSelectedImage ) /BOOL SetItemImage( HTREEITEM hItem, int nImage, int nSelectedImage)用于得到/修改某结点所使用图标索引。 CString GetItemText( HTREEITEM hItem ) /BOOLSetItemText( HTREEITEM hItem, LPCTSTR lpszItem );用于得到/修改某一结点的显示字符。BOOL DeleteItem( HTREEITEM hItem );用于删除某一结点，BOOL DeleteAllItems();将删除所有结点。 此外如果想遍历树可以使用下面的函数： HTREEITEM GetRootItem( );得到根结点。 HTREEITEMGetChildItem( HTREEITEM hItem );得到子结点。 HTREEITEMGetPrevSiblingItem/GetNextSiblingItem( HTREEITEM hItem);得到指明结点的上/下一个兄弟结点。 HTREEITEM GetParentItem( HTREEITEM hItem );得到父结点。 树形控件的消息映射使用ON_NOTIFY宏，形式如同：ON_NOTIFY( wNotifyCode, id, memberFxn)，wNotifyCode为通知代码，id为产生该消息的窗口ID，memberFxn为处理函数，函数的原型如同voidOnXXXTree(NMHDR pNMHDR, LRESULTpResult)，其中pNMHDR为一数据结构，在具体使用时需要转换成其他类型的结构。对于树形控件可能取值和对应的数据结构为： · TVN_SELCHANGED 在所选中的结点发生改变后发送，所用结构：NMTREEVIEW · TVN_ITEMEXPANDED 在某结点被展开后发送，所用结构：NMTREEVIEW · TVN_BEGINLABELEDIT 在开始编辑结点字符时发送，所用结构：NMTVDISPINFO · TVN_ENDLABELEDIT 在结束编辑结点字符时发送，所用结构：NMTVDISPINFO · TVN_GETDISPINFO 在需要得到某结点信息时发送，（如得到结点的显示字符）所用结构：NMTVDISPINFO 关于ON_NOTIFY有很多内容，将在以后的内容中进行详细讲解。 关于动态提供结点所显示的字符：首先你在添加结点时需要指明lpszItem参数为：LPSTR_TEXTCALLBACK。在控件显示该结点时会通过发送TVN_GETDISPINFO来取得所需要的字符，在处理该消息时先将参数pNMHDR转换为LPNMTVDISPINFO，然后填充其中item.pszText。但是我们通过什么来知道该结点所对应的信息呢，我的做法是在添加结点后设置其lParam参数，然后在提供信息时利用该参数来查找所对应的信息。下面的代码说明了这种方法： char szOut[8][3]={“No.1”,”No.2”,”No.3”}; //添加结点 HTREEITEM hItem =m_tree.InsertItem(LPSTR_TEXTCALLBACK,…) m_tree.SetItemData(hItem, 0); hItem = m_tree.InsertItem(LPSTR_TEXTCALLBACK,…)m_tree.SetItemData(hItem, 1 ); //处理消息 voidCParentWnd::OnGetDispInfoTree(NMHDR pNMHDR, LRESULT pResult) {TV_DISPINFO pTVDI = (TV_DISPINFO)pNMHDR;pTVDI-&gt;item.pszText=szOut[pTVDI-&gt;item.lParam];//通过lParam得到需要显示的字符在数组中的位置 *pResult = 0; } 关于编辑结点的显示字符：首先需要设置树形控件的TVS_EDITLABELS风格，在开始编辑时该控件将会发送TVN_BEGINLABELEDIT，你可以通过在处理函数中返回TRUE来取消接下来的编辑，在编辑完成后会发送TVN_ENDLABELEDIT，在处理该消息时需要将参数pNMHDR转换为LPNMTVDISPINFO，然后通过其中的item.pszText得到编辑后的字符，并重置显示字符。如果编辑在中途中取消该变量为NULL。下面的代码说明如何处理这些消息： //处理消息 TVN_BEGINLABELEDIT void CParentWnd::OnBeginEditTree(NMHDRpNMHDR, LRESULT pResult) { TV_DISPINFO pTVDI = (TV_DISPINFO)pNMHDR;if(pTVDI-&gt;item.lParam==0);//判断是否取消该操作 pResult = 1; else pResult = 0;} //处理消息 TVN_BEGINLABELEDIT void CParentWnd::OnBeginEditTree(NMHDRpNMHDR, LRESULT pResult) { TV_DISPINFO pTVDI = (TV_DISPINFO)pNMHDR;if(pTVDI-&gt;item.pszText==NULL);//判断是否已经取消取消编辑m_tree.SetItemText(pTVDI-&gt;item.hItem,pTVDI-&gt;pszText); //重置显示字符*pResult = 0; } 上面讲述的方法所进行的消息映射必须在父窗口中进行（同样WM_NOTIFY的所有消息都需要在父窗口中处理）。 List Ctrl 列表控件可以看作是功能增强的ListBox，它提供了四种风格，而且可以同时显示一列的多中属性值。MFC中使用CListCtrl类来封装列表控件的各种操作。通过调用BOOL Create( DWORD dwStyle, const RECT&amp; rect, CWnd* pParentWnd, UINTnID );创建一个窗口，dwStyle中可以使用以下一些列表控件的专用风格： · LVS_ICON LVS_SMALLICON LVS_LIST LVS_REPORT这四种风格决定控件的外观，同时只可以选择其中一种，分别对应：大图标显示，小图标显示，列表显示，详细报表显示 · LVS_EDITLABELS 结点的显示字符可以被编辑，对于报表风格来讲可编辑的只为第一列。 · LVS_SHOWSELALWAYS 在失去焦点时也显示当前选中的结点 · LVS_SINGLESEL 同时只能选中列表中一项 首先你需要设置列表控件所使用的ImageList，如果你使用大图标显示风格，你就需要以如下形式调用： CImageListSetImageList( CImageList pImageList, LVSIL_NORMAL);如果使用其它三种风格显示而不想显示图标你可以不进行任何设置，否则需要以如下形式调用： CImageList SetImageList(CImageList pImageList, LVSIL_SMALL); 通过调用 int InsertItem( int nItem, LPCTSTR lpszItem);可以在列表控件中nItem指明位置插入一项，lpszItem为显示字符。除LVS_REPORT风格外其他三种风格都只需要直接调用InsertItem就可以了，但如果使用报表风格就必须先设置列表控件中的列信息。 通过调用 int InsertColumn( int nCol, LPCTSTR lpszColumnHeading, intnFormat , int nWidth, intnSubItem);可以插入列。iCol为列的位置，从零开始，lpszColumnHeading为显示的列名，nFormat为显示对齐方式，nWidth为显示宽度，nSubItem为分配给该列的列索引。 在有多列的列表控件中就需要为每一项指明其在每一列中的显示字符，通过调用 BOOL SetItemText( int nItem, intnSubItem, LPTSTR lpszText);可以设置每列的显示字符。nItem为设置的项的位置，nSubItem为列位置，lpszText为显示字符。下面的代码演示了如何设置多列并插入数据： m_list.SetImageList(&amp;m_listSmall,LVSIL_SMALL);//设置ImageListm_list.InsertColumn(0,”Col 1”,LVCFMT_LEFT,300,0);//设置列m_list.InsertColumn(1,”Col 2”,LVCFMT_LEFT,300,1);m_list.InsertColumn(2,”Col 3”,LVCFMT_LEFT,300,2);m_list.InsertItem(0,”Item 1_1”);//插入行 m_list.SetItemText(0,1,”Item1_2”);//设置该行的不同列的显示字符 m_list.SetItemText(0,2,”Item 1_3”); 此外CListCtrl还提供了一些函数用于得到/修改控件的状态。 COLORREF GetTextColor( )/BOOLSetTextColor( COLORREF cr );用于得到/设置显示的字符颜色。 COLORREF GetTextBkColor()/BOOL SetTextBkColor( COLORREF cr );用于得到/设置显示的背景颜色。 voidSetItemCount( int iCount );用于得到添加进列表中项的数量。 BOOL DeleteItem(intnItem);用于删除某一项，BOOL DeleteAllItems( );将删除所有项。 BOOL SetBkImage(HBITMAPhbm, BOOL fTile , int xOffsetPercent, int yOffsetPercent);用于设置背景位图。CString GetItemText( int nItem, int nSubItem );用于得到某项的显示字符。 列表控件的消息映射同样使用ON_NOTIFY宏，形式如同：ON_NOTIFY( wNotifyCode, id, memberFxn)，wNotifyCode为通知代码，id为产生该消息的窗口ID，memberFxn为处理函数，函数的原型如同voidOnXXXList(NMHDR pNMHDR, LRESULTpResult)，其中pNMHDR为一数据结构，在具体使用时需要转换成其他类型的结构。对于列表控件可能取值和对应的数据结构为： · LVN_BEGINLABELEDIT 在开始某项编辑字符时发送，所用结构：NMLVDISPINFO · LVN_ENDLABELEDIT 在结束某项编辑字符时发送，所用结构：NMLVDISPINFO · LVN_GETDISPINFO 在需要得到某项信息时发送，（如得到某项的显示字符）所用结构：NMLVDISPINFO 关于ON_NOTIFY有很多内容，将在以后的内容中进行详细讲解。 关于动态提供结点所显示的字符：首先你在项时需要指明lpszItem参数为：LPSTR_TEXTCALLBACK。在控件显示该结点时会通过发送TVN_GETDISPINFO来取得所需要的字符，在处理该消息时先将参数pNMHDR转换为LPNMLVDISPINFO，然后填充其中item.pszText。通过item中的iItem,iSubItem可以知道当前显示的为那一项。下面的代码演示了这种方法： char szOut[8][3]={“No.1”,”No.2”,”No.3”}; //添加结点m_list.InsertItem(LPSTR_TEXTCALLBACK,…)m_list.InsertItem(LPSTR_TEXTCALLBACK,…) //处理消息 voidCParentWnd::OnGetDispInfoList(NMHDR pNMHDR, LRESULT pResult) {LV_DISPINFO pLVDI = (LV_DISPINFO)pNMHDR;pLVDI-&gt;item.pszText=szOut[pTVDI-&gt;item.iItem];//通过iItem得到需要显示的字符在数组中的位置 *pResult = 0; } 关于编辑某项的显示字符：（在报表风格中只对第一列有效）首先需要设置列表控件的LVS_EDITLABELS风格，在开始编辑时该控件将会发送LVN_BEGINLABELEDIT，你可以通过在处理函数中返回TRUE来取消接下来的编辑，在编辑完成后会发送LVN_ENDLABELEDIT，在处理该消息时需要将参数pNMHDR转换为LPNMLVDISPINFO，然后通过其中的item.pszText得到编辑后的字符，并重置显示字符。如果编辑在中途中取消该变量为NULL。下面的代码说明如何处理这些消息： //处理消息 LVN_BEGINLABELEDIT void CParentWnd::OnBeginEditList(NMHDRpNMHDR, LRESULT pResult) { LV_DISPINFO pLVDI = (LV_DISPINFO)pNMHDR;if(pLVDI-&gt;item.iItem==0);//判断是否取消该操作 pResult = 1; else pResult = 0;} //处理消息 LVN_BEGINLABELEDIT void CParentWnd::OnBeginEditList(NMHDRpNMHDR, LRESULT pResult) { LV_DISPINFO pLVDI = (LV_DISPINFO)pNMHDR;if(pLVDI-&gt;item.pszText==NULL);//判断是否已经取消取消编辑m_list.SetItemText(pLVDI-&gt;item.iItem,0,pLVDI-&gt;pszText); //重置显示字符*pResult = 0; } 上面讲述的方法所进行的消息映射必须在父窗口中进行（同样WM_NOTIFY的所有消息都需要在父窗口中处理）。 如何得到当前选中项位置：在列表控件中没有一个类似于ListBox中GetCurSel()的函数，但是可以通过调用GetNextItem(-1, LVNI_ALL | LVNI_SELECTED);得到选中项位置。 Tab Ctrl Tab属性页控件可以在一个窗口中添加不同的页面，然后在页选择发生改变时得到通知。MFC中使用CTabCtrl类来封装属性页控件的各种操作。通过调用BOOL Create( DWORD dwStyle, const RECT&amp; rect, CWnd* pParentWnd, UINTnID );创建一个窗口，dwStyle中可以使用以下一些属性页控件的专用风格： TCS_BUTTONS 使用按钮来表示页选择位置 TCS_MULTILINE 分行显示页选择位置 TCS_SINGLELINE只使用一行显示页选择位置 在控件创建后必需向其中添加页面才可以使用，添加页面的函数为： BOOL InsertItem( intnItem, LPCTSTR lpszItem);nItem为位置，从零开始，lpszItem为页选择位置上显示的文字。如果你希望在页选择位置处显示一个图标，你可以调用 BOOLInsertItem( int nItem, LPCTSTR lpszItem, int nImage);nImage指明所使用的图片位置。（在此之前必须调用CImageList SetImageList( CImageList pImageList );设置正确的ImageList） 此外CTabCtrl还提供了一些函数用于得到/修改控件的状态。 int GetCurSel( )/int SetCurSel( intnItem );用于得到/设置当前被选中的页位置。 BOOL DeleteItem( int nItem )/BOOLDeleteAllItems( );用于删除指定/所有页面。 void RemoveImage( int nImage);用于删除某页选择位置上的图标。 属性页控件的消息映射同样使用ON_NOTIFY宏，形式如同：ON_NOTIFY( wNotifyCode, id, memberFxn)，wNotifyCode为通知代码，id为产生该消息的窗口ID，memberFxn为处理函数，函数的原型如同voidOnXXXTab(NMHDR pNMHDR, LRESULTpResult)，其中pNMHDR为一数据结构，在具体使用时需要转换成其他类型的结构。对于列表控件可能取值和对应的数据结构为： TCN_SELCHANGE 在当前页改变后发送，所用结构：NMHDR TCN_SELCHANGING在当前页改变时发送可以通过返回TRUE来禁止页面的改变，所用结构：NMHDR 一般来讲在当前页发生改变时需要隐藏当前的一些子窗口，并显示其它的子窗口。下面的伪代码演示了如何使用属性页控件：CParentWnd::OnCreate(…){m_tab.Create(…);m_tab.InsertItem(0,”Option 1”);m_tab.InsertItem(1,”Option 2”);Create a edit box as the m_tab’s ChildCreate a static box as the m_tab’s Childedit_box.ShowWindow(SW_SHOW); // edit box在属性页的第一页static_box.ShowWindow(SW_HIDE); // static box在属性页的第二页}void CParentWnd::OnSelectChangeTab(NMHDR pNMHDR, LRESULT pResult){//处理页选择改变后的消息if(m_tab.GetCurSel()==0){//根据当前页显示/隐藏不同的子窗口edit_box.ShowWindow(SW_SHOW);static_box.ShowWindow(SW_HIDE);}else{//edit_box.ShowWindow(SW_HIDE);static_box.ShowWindow(SW_SHOW);}}]]></content>
      <categories>
        <category>MFC从入门到放弃</category>
      </categories>
      <tags>
        <tag>MFC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第5节 MFC对话框程序]]></title>
    <url>%2F2017%2F10%2F28%2F%E7%AC%AC5%E8%8A%82-MFC%E5%AF%B9%E8%AF%9D%E6%A1%86%E7%A8%8B%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[Windows编程基础–第5节 MFC对话框程序模式对话框 对话框程序是MFC最重要的组成部分，也是Visual C++中唯一可以可视化设计的窗口程序，对话框主要有两类： 模式对话框：必须关闭这个对话框才能继续操作父窗口或者上一级窗口 非模式对话框:不影响父窗口或者上一级窗口，可继续操作父窗口或者上一级窗口，对话框程序也可以一直保留，无需关闭才能执行下一步； 接来下我们先一起学习模式对话框； 1. 新建项目建立一个MFC的主对话框项目day04，参见上节，添加两个按钮，分别为“关于”，“聊天”，如图所示： 2. 添加关于对话框在资源视图（ResourceView）中Dialog上右击-&gt;Insert Diallog，插入对话框，如图所示： 3. 添加关于对话框类单击添加的关于对话框，执行View-&gt;Class Wizard，或者使用快捷键Ctrl + W打开类向导；由于新的对话框不存在关联类，此时会提示创建一个与它相关联的类，选择Create a new class,单击OK创建关联类，如下图所示：单击OK完成创建关联类； 3. 添加关于按钮消息事件切换回主对话框，单击主对话框，执行View-&gt;Class Wizard，或者使用快捷键Ctrl + W打开类向导；选择关于按钮，增加clicked方法，然后Edit Code编辑关于按钮的响应方法，或者可以直接双击“关于”按钮就可以直接进入按钮点击方法，在day04Dlg.h中添加“#include AboutDlg.h”来引入对话框类，然后我们来编辑关于按键方法，创建一个模式对话框； 123456void CDay04Dlg::OnButtonAbout() &#123; // TODO: Add your control notification handler code here CAboutDlg dlg; dlg.DoModal();&#125; 效果图：至此，一个模式对话框就创建成功了，我们可以看到，我们必须关闭关于对话框，才能单击主对话框。 非模式对话框现在我们来创建一个非模式对话框； 1. 添加聊天对话框在资源视图（ResourceView）中Dialog上右击-&gt;Insert Diallog，插入对话框，如图所示： 2. 添加聊天对话框类单击添加的关于对话框，执行View-&gt;Class Wizard，或者使用快捷键Ctrl + W打开类向导；由于新的对话框不存在关联类，此时会提示创建一个与它相关联的类，选择Create a new class,单击OK创建关联类，如上面步骤3 3. 添加聊天按钮消息事件切换回主对话框，单击主对话框，执行View-&gt;Class Wizard，或者使用快捷键Ctrl + W打开类向导；选择聊天按钮，增加clicked方法，然后Edit Code编辑关于按钮的响应方法，或者可以直接双击“聊天”按钮就可以直接进入按钮点击方法，在day04Dlg.h中添加“#include “Chat.h””来引入对话框类，然后我们来编辑聊天按键方法，创建一个非模式对话框； 1234567void CDay04Dlg::OnButtonChat() &#123; // TODO: Add your control notification handler code here CChat * pDlg = new CChat; pDlg-&gt;Create(IDD_DIALOG_CHAT); pDlg-&gt;ShowWindow(SW_SHOW);&#125; 效果图：至此，一个非模式对话框就创建成功了，我们可以看到，我们打开聊天界面后还可以继续操作父窗口中的关于对话框，甚至还可以单击聊天对话框创建多个聊天界面； 项目源码可以访问我的码云]]></content>
      <categories>
        <category>MFC从入门到放弃</category>
      </categories>
      <tags>
        <tag>MFC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第4节 MFC消息映射机制]]></title>
    <url>%2F2017%2F10%2F28%2F%E7%AC%AC4%E8%8A%82-MFC%E6%B6%88%E6%81%AF%E6%98%A0%E5%B0%84%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[Windows编程基础–第4节 MFC消息映射机制对于MFC程序最重要的响应机制就是消息映射机制，这节我们就来一起尝试一下MFC的消息映射机制。（操作系统：win10 64位 IDE：vc++ 6.0）1、新建一个MFC对话框项目，参见上节，2、编译代码运行，效果图如下：3、现在我们删除对话框上的《确定》和《取消》按钮，如图：4、现在我们添加自己的“OK”和“CANCEL”按钮，接下来我们就来看看“OK”按钮的按下消息是怎么进行处理的？4、执行View-&gt;Class Wizard,打开类向导；（或者直接用ctrl + W） 此时就能看到我们创建的对话框，OK按钮，CANCEL按钮对象，点击它们可以看见它们分别的拥有的消息，如图： 5、我们选择Cday03Dlg，MESSAGES选择WM_MOUSEMOVE消息，点击Add Function，下部Member function就会出现与WM_MOUSEMOVE对应的OnMouseMove函数，接下来点击Edit Code，编辑OnMouseMove函数的内容：6、我们来修改OnMouseMove(UINT nFlags, CPoint point) 函数，参数中point为鼠标的坐标位置，我们可以通过point.x, point.y来获取鼠标的位置，nFlags主要是标志一些控制键是否按下，然后MK_LBUTTON、MK_RBUTTON、MK_CONTROL、MK_SHIFT、MK_MBUTTON 分别对应鼠标左键，右键，CTRL ，SHIFT ，鼠标中间（转轮）：123456789101112131415161718192021222324252627282930void CDay03Dlg::OnMouseMove(UINT nFlags, CPoint point) &#123; // TODO: Add your message handler code here and/or call default CString strText; strText.Format(&quot;坐标 x = %d ,y = %d &quot;,point.x, point.y); if (nFlags &amp; MK_LBUTTON) &#123; strText += &quot; 鼠标左键DOWN&quot;; &#125; if (nFlags &amp; MK_RBUTTON) &#123; strText += &quot; 鼠标右键DOWN&quot;; &#125; if (nFlags &amp; MK_CONTROL) &#123; strText += &quot; CTRL DOWN&quot;; &#125; if (nFlags &amp; MK_SHIFT) &#123; strText += &quot; SHIFT DOWN&quot;; &#125; if (nFlags &amp; MK_MBUTTON) &#123; strText += &quot; MIDBUTTON DOWN&quot;; &#125; SetWindowText(strText); // 设置对话框标题文本 CDialog::OnMouseMove(nFlags, point);&#125; 效果图： 7、同样，我们可以通过类向导分别设置“OK”，“CANCEL”按钮的消息触发函数； 8、这是我们其实可以看到在day03Dlg.cpp中MESSAGE_MAP总下方就有我们新增的三个MFC消息，并且可以直观的看出是属于哪个控件ID的； 12345678910BEGIN_MESSAGE_MAP(CDay03Dlg, CDialog) //&#123;&#123;AFX_MSG_MAP(CDay03Dlg) ON_WM_SYSCOMMAND() ON_WM_PAINT() ON_WM_QUERYDRAGICON() ON_WM_MOUSEMOVE() ON_BN_CLICKED(IDC_BUTTON_OK, OnButtonOk) ON_BN_CLICKED(IDC_BUTTON_CACEL, OnButtonCacel) //&#125;&#125;AFX_MSG_MAPEND_MESSAGE_MAP() 9、接下来我们切换到day03Dlg.h头文件中，所有afx_msg 开头的都是消息对应的处理函数： 1234567891011// Generated message map functions//&#123;&#123;AFX_MSG(CDay03Dlg)afx_msg void OnSysCommand(UINT nID, LPARAM lParam);afx_msg void OnPaint();afx_msg HCURSOR OnQueryDragIcon();afx_msg void OnMouseMove(UINT nFlags, CPoint point);afx_msg void OnButtonOk();afx_msg void OnDoubleclickedButtonCacel();afx_msg void OnButtonCacel();//&#125;&#125;AFX_MSGDECLARE_MESSAGE_MAP() 10、由以上例子可以看出，MFC程序的消息映射机制是创建一个与窗口相关联的派生类，用于消息关联的成员函数来接收和处理窗口的消息。在类向导中选择对应的消息，添加与该消息关联的成员函数来处理该消息，这就是MFC的消息映射机制。具体控件或窗口支持哪些消息及消息对应的函数参数等，请参见MSDN；11、最终效果图： 项目源码可以访问我的码云来fork]]></content>
      <categories>
        <category>MFC从入门到放弃</category>
      </categories>
      <tags>
        <tag>MFC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第3节 初探MFC]]></title>
    <url>%2F2017%2F10%2F28%2F%E7%AC%AC3%E8%8A%82-%E5%88%9D%E6%8E%A2MFC%2F</url>
    <content type="text"><![CDATA[Windows编程基础–第3节 初探MFC 前言 win32程序属于早期windows软件，已经逐渐被淘汰，但它的设计模式和方法大部分都被MFC所继承，并且MFC开始使用C++语言进行开发，借助C++比C语言的强大特性，使得开发windws程序更加简便、高效，更加多元化。 创建第一个MFC程序（操作系统：win10 64位 IDE：vc++ 6.0）1) 执行File-&gt;new，选择Project选项卡，选择下面的MFC AppWizard，填写项目名称等，如图：2）点击 OK 按钮进入下一页，我们先选择简单的Dialog based，然后-&gt;NEXT ，第三页进行是否选择MFC静态库还是共享库等选择，这里我们不作修改，直接点击Finish，完成创建； 3）现在可以尝试编译，运行打开默认的Dialog界面4)现在我们往刚才创建的Dialog中添加一些资源控件，如下图：注意：ListCtrl属性中Stytle-&gt;View选择Report5）接下来我们来实现底部三个按钮的方法：添加按钮 12345678910111213 void CDay02Dlg::OnAdd() &#123; // TODO: Add your control notification handler code here CString szNumb,szName,szSala; GetDlgItemText(IDC_NUMB,szNumb); GetDlgItemText(IDC_NAME,szName); GetDlgItemText(IDC_SALA,szSala); CListCtrl *pList = (CListCtrl*)GetDlgItem(IDC_LIST); int nCount = pList-&gt;GetItemCount(); pList-&gt;InsertItem(nCount,szNumb); pList-&gt;SetItemText(nCount,1,szName); pList-&gt;SetItemText(nCount,2,szSala);&#125; 先通过GetDlgItemText方法获取顶部三个Edit输入的参数值，并分别赋值给szNumb,szName,szSala;接下来通过GetDlgItem取得ListCtrl的操作句柄，获取ListCtrl当前总数，在末尾添加一个Iten，并赋值； 删除按钮 123456789101112void CDay02Dlg::OnDel() &#123; // TODO: Add your control notification handler code here CListCtrl *pList = (CListCtrl*)GetDlgItem(IDC_LIST); int nSel = pList-&gt;GetSelectionMark(); if(nSel &lt; 0) &#123; AfxMessageBox(&quot;请先选择要删除的员工&quot;); return; &#125; pList-&gt;DeleteItem(nSel);&#125; 获取ListCtrl的操作句柄后获取到当前选的行数，最后删除改行； 修改按钮： 1234567891011121314151617181920void CDay02Dlg::OnMod() &#123; // TODO: Add your control notification handler code here CListCtrl *pList = (CListCtrl*)GetDlgItem(IDC_LIST); int nSel = pList-&gt;GetSelectionMark(); if(nSel &lt; 0) &#123; AfxMessageBox(&quot;请先选择要修改的员工&quot;); return; &#125; CString szNumb,szName,szSala; GetDlgItemText(IDC_NUMB,szNumb); GetDlgItemText(IDC_NAME,szName); GetDlgItemText(IDC_SALA,szSala); pList-&gt;SetItemText(nSel,0,szNumb); pList-&gt;SetItemText(nSel,1,szName); pList-&gt;SetItemText(nSel,2,szSala); &#125; 先通过GetDlgItemText方法获取顶部三个Edit输入的参数值，并分别赋值给szNumb,szName,szSala;接下来通过GetDlgItem取得ListCtrl的操作句柄，获取ListCtrl当前选择行数，将获取的szNumb,szName,szSala分别赋值给当前Item的对应位置； 函数原型如下：BOOL SetItemText( int nItem, int nSubItem, LPTSTR lpszText );用于MFC设置CListCtrl控件中的列表项内容。 int GetDlgItemText( int nID, CString&amp; rString) nID 指定了要获取其标题的控件的整数标识符。 lpStr 指向要接收控件的标题或文本的缓冲区。 nMaxCount 指定了要拷贝到lpStr的字符串的最大长度（以字节为单位）。如果字符串比nMaxCount要长，它将被截断。 rString 对一个CString对象的引用。 3.最终效果图 day02.cpp 源码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236 // day02Dlg.cpp : implementation file//#include &quot;stdafx.h&quot;#include &quot;day02.h&quot;#include &quot;day02Dlg.h&quot;#ifdef _DEBUG#define new DEBUG_NEW#undef THIS_FILEstatic char THIS_FILE[] = __FILE__;#endif/////////////////////////////////////////////////////////////////////////////// CAboutDlg dialog used for App Aboutclass CAboutDlg : public CDialog&#123;public: CAboutDlg();// Dialog Data //&#123;&#123;AFX_DATA(CAboutDlg) enum &#123; IDD = IDD_ABOUTBOX &#125;; //&#125;&#125;AFX_DATA // ClassWizard generated virtual function overrides //&#123;&#123;AFX_VIRTUAL(CAboutDlg) protected: virtual void DoDataExchange(CDataExchange* pDX); // DDX/DDV support //&#125;&#125;AFX_VIRTUAL// Implementationprotected: //&#123;&#123;AFX_MSG(CAboutDlg) //&#125;&#125;AFX_MSG DECLARE_MESSAGE_MAP()&#125;;CAboutDlg::CAboutDlg() : CDialog(CAboutDlg::IDD)&#123; //&#123;&#123;AFX_DATA_INIT(CAboutDlg) //&#125;&#125;AFX_DATA_INIT&#125;void CAboutDlg::DoDataExchange(CDataExchange* pDX)&#123; CDialog::DoDataExchange(pDX); //&#123;&#123;AFX_DATA_MAP(CAboutDlg) //&#125;&#125;AFX_DATA_MAP&#125;BEGIN_MESSAGE_MAP(CAboutDlg, CDialog) //&#123;&#123;AFX_MSG_MAP(CAboutDlg) // No message handlers //&#125;&#125;AFX_MSG_MAPEND_MESSAGE_MAP()/////////////////////////////////////////////////////////////////////////////// CDay02Dlg dialogCDay02Dlg::CDay02Dlg(CWnd* pParent /*=NULL*/) : CDialog(CDay02Dlg::IDD, pParent)&#123; //&#123;&#123;AFX_DATA_INIT(CDay02Dlg) // NOTE: the ClassWizard will add member initialization here //&#125;&#125;AFX_DATA_INIT // Note that LoadIcon does not require a subsequent DestroyIcon in Win32 m_hIcon = AfxGetApp()-&gt;LoadIcon(IDR_MAINFRAME);&#125;void CDay02Dlg::DoDataExchange(CDataExchange* pDX)&#123; CDialog::DoDataExchange(pDX); //&#123;&#123;AFX_DATA_MAP(CDay02Dlg) // NOTE: the ClassWizard will add DDX and DDV calls here //&#125;&#125;AFX_DATA_MAP&#125;BEGIN_MESSAGE_MAP(CDay02Dlg, CDialog) //&#123;&#123;AFX_MSG_MAP(CDay02Dlg) ON_WM_SYSCOMMAND() ON_WM_PAINT() ON_WM_QUERYDRAGICON() ON_BN_CLICKED(IDC_BUTTON4, OnButtonOK) ON_BN_CLICKED(IDC_ADD, OnAdd) ON_BN_CLICKED(IDC_DEL, OnDel) ON_BN_CLICKED(IDC_MOD, OnMod) //&#125;&#125;AFX_MSG_MAPEND_MESSAGE_MAP()/////////////////////////////////////////////////////////////////////////////// CDay02Dlg message handlersBOOL CDay02Dlg::OnInitDialog()&#123; CDialog::OnInitDialog(); CListCtrl *pList = (CListCtrl*)GetDlgItem(IDC_LIST); pList-&gt;InsertColumn(0,&quot;学号&quot;,0,100); pList-&gt;InsertColumn(1,&quot;姓名&quot;,0,100); pList-&gt;InsertColumn(2,&quot;工资&quot;,0,100); // Add &quot;About...&quot; menu item to system menu. // IDM_ABOUTBOX must be in the system command range. ASSERT((IDM_ABOUTBOX &amp; 0xFFF0) == IDM_ABOUTBOX); ASSERT(IDM_ABOUTBOX &lt; 0xF000); CMenu* pSysMenu = GetSystemMenu(FALSE); if (pSysMenu != NULL) &#123; CString strAboutMenu; strAboutMenu.LoadString(IDS_ABOUTBOX); if (!strAboutMenu.IsEmpty()) &#123; pSysMenu-&gt;AppendMenu(MF_SEPARATOR); pSysMenu-&gt;AppendMenu(MF_STRING, IDM_ABOUTBOX, strAboutMenu); &#125; &#125; // Set the icon for this dialog. The framework does this automatically // when the application&apos;s main window is not a dialog SetIcon(m_hIcon, TRUE); // Set big icon SetIcon(m_hIcon, FALSE); // Set small icon // TODO: Add extra initialization here return TRUE; // return TRUE unless you set the focus to a control&#125;void CDay02Dlg::OnSysCommand(UINT nID, LPARAM lParam)&#123; if ((nID &amp; 0xFFF0) == IDM_ABOUTBOX) &#123; CAboutDlg dlgAbout; dlgAbout.DoModal(); &#125; else &#123; CDialog::OnSysCommand(nID, lParam); &#125;&#125;// If you add a minimize button to your dialog, you will need the code below// to draw the icon. For MFC applications using the document/view model,// this is automatically done for you by the framework.void CDay02Dlg::OnPaint() &#123; if (IsIconic()) &#123; CPaintDC dc(this); // device context for painting SendMessage(WM_ICONERASEBKGND, (WPARAM) dc.GetSafeHdc(), 0); // Center icon in client rectangle int cxIcon = GetSystemMetrics(SM_CXICON); int cyIcon = GetSystemMetrics(SM_CYICON); CRect rect; GetClientRect(&amp;rect); int x = (rect.Width() - cxIcon + 1) / 2; int y = (rect.Height() - cyIcon + 1) / 2; // Draw the icon dc.DrawIcon(x, y, m_hIcon); &#125; else &#123; CDialog::OnPaint(); &#125;&#125;// The system calls this to obtain the cursor to display while the user drags// the minimized window.HCURSOR CDay02Dlg::OnQueryDragIcon()&#123; return (HCURSOR) m_hIcon;&#125;void CDay02Dlg::OnButtonOK() &#123; // TODO: Add your control notification handler code here &#125;void CDay02Dlg::OnAdd() &#123; // TODO: Add your control notification handler code here CString szNumb,szName,szSala; GetDlgItemText(IDC_NUMB,szNumb); GetDlgItemText(IDC_NAME,szName); GetDlgItemText(IDC_SALA,szSala); CListCtrl *pList = (CListCtrl*)GetDlgItem(IDC_LIST); int nCount = pList-&gt;GetItemCount(); pList-&gt;InsertItem(nCount,szNumb); pList-&gt;SetItemText(nCount,1,szName); pList-&gt;SetItemText(nCount,2,szSala);&#125;void CDay02Dlg::OnDel() &#123; // TODO: Add your control notification handler code here CListCtrl *pList = (CListCtrl*)GetDlgItem(IDC_LIST); int nSel = pList-&gt;GetSelectionMark(); if(nSel &lt; 0) &#123; AfxMessageBox(&quot;请先选择要删除的员工&quot;); return; &#125; pList-&gt;DeleteItem(nSel); &#125;void CDay02Dlg::OnMod() &#123; // TODO: Add your control notification handler code here CListCtrl *pList = (CListCtrl*)GetDlgItem(IDC_LIST); int nSel = pList-&gt;GetSelectionMark(); if(nSel &lt; 0) &#123; AfxMessageBox(&quot;请先选择要修改的员工&quot;); return; &#125; CString szNumb,szName,szSala; GetDlgItemText(IDC_NUMB,szNumb); GetDlgItemText(IDC_NAME,szName); GetDlgItemText(IDC_SALA,szSala); pList-&gt;SetItemText(nSel,0,szNumb); pList-&gt;SetItemText(nSel,1,szName); pList-&gt;SetItemText(nSel,2,szSala); &#125; 项目源码可以访问我的码云来fork： 1https://gitee.com/AmuUncle/MFC_CSDN.git]]></content>
      <categories>
        <category>MFC从入门到放弃</category>
      </categories>
      <tags>
        <tag>MFC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows编程基础--第2节 win32程序资源管理]]></title>
    <url>%2F2017%2F10%2F28%2FMFC02%2F</url>
    <content type="text"><![CDATA[Windows编程基础–第2节 win32程序资源管理（操作系统：win10 64位 IDE：vc++ 6.0）windows程序都有自己的资源，例如按钮，图标，对话框等等，这节介绍如何使用win32程序资源管理；1、继续使用上节的win32程序demo，执行File-&gt;new添加资源，选择Files选项卡中的Resource Script，填写资源名，如图所示：2、此时项目左侧会出现ResourceView视图，单击ResourceView中的根节点+号，会提示“This file is already open in an editor”，这时候关闭右边的day01.rc，再次打开就可以了；3、在ResourceView节点day01 Resources节点上右击-&gt;Insert,选中Dialog,单击“New”,创建一个对话框资源，创建成功之后如图：4、在新建的对话框上右击选择属性（Properties），会弹出dialog的属性窗口，可以设置一些对话框的相关属性，如图5、接下来我们做一个简单的BMI计算器(体重指数BMI=体重/身高的平方（国际单位kg/㎡）)，拖动三个Edit分别用来显示身高，体重，BMI值，并设置属性ID，分别为：IDC_EDIT_SG、IDC_EDIT_TZ,IDC_EDIT_BMI，如图所示：6、接下来切换到类视图（classView），双击WinMain入口函数，添加对话框语句： 1DialogBox(hInstance,(LPCTSTR)IDD_DIALOG_BMI,NULL,DlGFUNC); 其中IDD_DIALOG_BMI为刚才添加的对话框属性ID，DlGFUNC为对话框的消息处理函数，7、接下来我们添加DlGFUNC函数，如下： 1234567891011121314151617181920212223242526BOOL CALLBACK DlGFUNC(HWND hwnd_dlg,UINT uMsg,WPARAM wParam,LPARAM lParam)&#123; switch(uMsg) &#123; case WM_COMMAND: switch(wParam) &#123; case IDCANCEL: EndDialog(hwnd_dlg,IDCANCEL); break; case IDOK: &#123; int nHeight= GetDlgItemInt(hwnd_dlg,IDC_EDIT_SG,NULL,TRUE); double dHeight = nHeight / 100.00; int nWeight = GetDlgItemInt(hwnd_dlg,IDC_EDIT_TZ,NULL,TRUE); double bmi = nWeight/(dHeight*dHeight); char buf[28]; sprintf(buf, &quot;%.3f&quot;, bmi); SetDlgItemText(hwnd_dlg,IDC_EDIT_BMI,buf); &#125; break; &#125; break; &#125; return FALSE;&#125; 其中IDOK，和IDCANCEL为对话框确认按钮和取消按钮所触发消息，IDCANCEL关闭对话框，IDOK消息我们来获取身高和体重Edit中的值，并按照公式体重指数BMI=体重/身高的平方（国际单位kg/㎡）计算BMI,最后将BMI值设置到BMI Edit中： 1234567int nHeight= GetDlgItemInt(hwnd_dlg,IDC_EDIT_SG,NULL,TRUE);double dHeight = nHeight / 100.00;int nWeight = GetDlgItemInt(hwnd_dlg,IDC_EDIT_TZ,NULL,TRUE);double bmi = nWeight/(dHeight*dHeight);char buf[28];sprintf(buf, &quot;%.3f&quot;, bmi);SetDlgItemText(hwnd_dlg,IDC_EDIT_BMI,buf); 注意：要在文件头部引用资源头文件：#include “resource.h”最终效果如下：附day01.cpp源码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445// day01.cpp : Defines the entry point for the application.//#include &quot;stdafx.h&quot;#include &quot;resource.h&quot;#include &quot;stdio.h&quot;BOOL CALLBACK DlGFUNC(HWND hwnd_dlg,UINT uMsg,WPARAM wParam,LPARAM lParam)&#123; switch(uMsg) &#123; case WM_COMMAND: switch(wParam) &#123; case IDCANCEL: EndDialog(hwnd_dlg,IDCANCEL); break; case IDOK: &#123; int nHeight= GetDlgItemInt(hwnd_dlg,IDC_EDIT_SG,NULL,TRUE); double dHeight = nHeight / 100.00; int nWeight = GetDlgItemInt(hwnd_dlg,IDC_EDIT_TZ,NULL,TRUE); double bmi = nWeight/(dHeight*dHeight); char buf[28]; sprintf(buf, &quot;%.3f&quot;, bmi); SetDlgItemText(hwnd_dlg,IDC_EDIT_BMI,buf); &#125; break; &#125; break; &#125; return FALSE;&#125;int APIENTRY WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)&#123; // TODO: Place code here. DialogBox(hInstance,(LPCTSTR)IDD_DIALOG_BMI,NULL,DlGFUNC); return 0;&#125; 后记： DialogProc是一个窗口过程函数。该函数为一个应用程序定义可与DialogBox函数一起使用的回调函数。它处理发送到一个模态的或无模式对话框的消息。DLGPROC类型定义了一个指向此回调函数的指针。DialogProc函数是应用程序定义函数名的一个占位符。函数原型： 123456BOOL CALLBACK DialogProc(HWND hwndDlg,UINT UMsg,WPARAM wParam,LPARAM lParam); hwndDlg指定对话框。uMsg指定消息。wParam指定消息特定的其他信息。Iparam指定消息特定的其他信息。 项目源码可以访问我的码云来fork： 1https://gitee.com/AmuUncle/MFC_CSDN.git]]></content>
      <categories>
        <category>MFC从入门到放弃</category>
      </categories>
      <tags>
        <tag>MFC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows编程基础--第1节 第一个win32软件]]></title>
    <url>%2F2017%2F10%2F28%2FMFC01%2F</url>
    <content type="text"><![CDATA[Windows编程基础–第1节 第一个win32软件下面新建一个win32程序，来演示win32程序开发的原理（操作系统：win10 64位 IDE：vc++ 6.0） 1、执行File -&gt; new命令，来新建一个工程，如下图： 2、点击 OK按钮，然后选择A simple win32 application，单击Finish完成创建； 3、此时右边项目视图会显示我们刚才创建好的项目，双击Globals下面的WinMain函数 4、现在来新建一个简单的对话框 1MessageBox(NULL,&quot;Hello World!!&quot;,&quot;My First Win32 App&quot;,MB_OK); 5、单击状态栏上的 “build”，或者直接按键进行编译，然后单击状态栏的 ！ 来运行程序，或者ctrl+F5;以下是MessageBox的原型： 123456int WINAPI MessageBox( HWND hWnd, // handle of owner window LPCTSTR lpText, // address of text in message box LPCTSTR lpCaption, // address of title of message box UINT uType // style of message box); hWnd是消息框的拥有窗口。如果此参数为NULL，则消息框没有拥有窗口。lpText为消息框的内容。lpCaption为消息框的标题。uType指定一个决定对话框的内容和行为（按钮、图标、形态及其他）的位标志集。附其它常用属性 系统默认图标，可在消息框上显示X错误 MB_ICONHAND, MB_ICONSTOP, and MB_ICONERROR?询问 MB_ICONQUESTION!警告 MB_ICONEXCLAMATION and MB_ICONWARNINGi信息 MB_ICONASTERISK and MB_ICONINFORMATION 按钮的形式 MB_OK 默认MB_OKCANCEL 确定取消MB_YESNO 是否MB_YESNOCANCEL 是否取消 返回值 IDCANCEL 取消被选IDNO 否被选IDOK 确定被选IDYES 是被选6、对照函数说明，我们可以简单根据对话框返回值来执行不同的代码，如图： 12345678910111213141516171819#include &quot;stdafx.h&quot;int APIENTRY WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)&#123; // TODO: Place code here. int ret = MessageBox(NULL,&quot;Hello World!!&quot;,&quot;My First Win32 App&quot;,MB_OKCANCEL ); if(IDCANCEL == ret) &#123; MessageBox(NULL,&quot;CANCEL is clicked&quot;,&quot;My First Win32 App&quot;,MB_OK); &#125; else if(IDOK == ret) &#123; MessageBox(NULL,&quot;OK is clicked&quot;,&quot;My First Win32 App&quot;,MB_OK); &#125; return 0;&#125; 项目源码可以访问我的码云来fork： 1https://gitee.com/AmuUncle/MFC_CSDN.git]]></content>
      <categories>
        <category>MFC从入门到放弃</category>
      </categories>
      <tags>
        <tag>MFC</tag>
      </tags>
  </entry>
</search>
